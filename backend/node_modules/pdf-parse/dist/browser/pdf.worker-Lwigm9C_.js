var Wh = {
  /***/
  34: (
    /***/
    ((t, e, n) => {
      var a = n(4901);
      t.exports = function(i) {
        return typeof i == "object" ? i !== null : a(i);
      };
    })
  ),
  /***/
  81: (
    /***/
    ((t, e, n) => {
      var a = n(9565), i = n(9306), s = n(8551), r = n(6823), o = n(851), c = TypeError;
      t.exports = function(l, h) {
        var f = arguments.length < 2 ? o(l) : h;
        if (i(f)) return s(a(f, l));
        throw new c(r(l) + " is not iterable");
      };
    })
  ),
  /***/
  116: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(2652), r = n(9306), o = n(8551), c = n(1767), l = n(9539), h = n(4549), f = h("find", TypeError);
      a({ target: "Iterator", proto: !0, real: !0, forced: f }, {
        find: function(u) {
          o(this);
          try {
            r(u);
          } catch (p) {
            l(this, "throw", p);
          }
          if (f) return i(f, this, u);
          var x = c(this), g = 0;
          return s(x, function(p, m) {
            if (u(p, g++)) return m(p);
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).result;
        }
      });
    })
  ),
  /***/
  283: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(9039), s = n(4901), r = n(9297), o = n(3724), c = n(350).CONFIGURABLE, l = n(3706), h = n(1181), f = h.enforce, d = h.get, u = String, x = Object.defineProperty, g = a("".slice), p = a("".replace), m = a([].join), b = o && !i(function() {
        return x(function() {
        }, "length", { value: 8 }).length !== 8;
      }), y = String(String).split("String"), w = t.exports = function(S, v, k) {
        g(u(v), 0, 7) === "Symbol(" && (v = "[" + p(u(v), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), k && k.getter && (v = "get " + v), k && k.setter && (v = "set " + v), (!r(S, "name") || c && S.name !== v) && (o ? x(S, "name", { value: v, configurable: !0 }) : S.name = v), b && k && r(k, "arity") && S.length !== k.arity && x(S, "length", { value: k.arity });
        try {
          k && r(k, "constructor") && k.constructor ? o && x(S, "prototype", { writable: !1 }) : S.prototype && (S.prototype = void 0);
        } catch {
        }
        var A = f(S);
        return r(A, "source") || (A.source = m(y, typeof v == "string" ? v : "")), S;
      };
      Function.prototype.toString = w(function() {
        return s(this) && d(this).source || l(this);
      }, "toString");
    })
  ),
  /***/
  350: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(9297), s = Function.prototype, r = a && Object.getOwnPropertyDescriptor, o = i(s, "name"), c = o && (function() {
      }).name === "something", l = o && (!a || a && r(s, "name").configurable);
      t.exports = {
        EXISTS: o,
        PROPER: c,
        CONFIGURABLE: l
      };
    })
  ),
  /***/
  397: (
    /***/
    ((t, e, n) => {
      var a = n(7751);
      t.exports = a("document", "documentElement");
    })
  ),
  /***/
  421: (
    /***/
    ((t) => {
      t.exports = {};
    })
  ),
  /***/
  456: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(9504), r = n(4154), o = n(5169), c = s(1.1.toString), l = i.Uint8Array, h = !l || !l.prototype.toHex || !(function() {
        try {
          var f = new l([255, 255, 255, 255, 255, 255, 255, 255]);
          return f.toHex() === "ffffffffffffffff";
        } catch {
          return !1;
        }
      })();
      l && a({ target: "Uint8Array", proto: !0, forced: h }, {
        toHex: function() {
          r(this), o(this.buffer);
          for (var d = "", u = 0, x = this.length; u < x; u++) {
            var g = c(this[u], 16);
            d += g.length === 1 ? "0" + g : g;
          }
          return d;
        }
      });
    })
  ),
  /***/
  507: (
    /***/
    ((t, e, n) => {
      var a = n(9565);
      t.exports = function(i, s, r) {
        for (var o = r ? i : i.iterator, c = i.next, l, h; !(l = a(c, o)).done; )
          if (h = s(l.value), h !== void 0) return h;
      };
    })
  ),
  /***/
  531: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(9306), r = n(8551), o = n(1767), c = n(8646), l = n(9462), h = n(9539), f = n(6395), d = n(684), u = n(4549), x = !f && !d("flatMap", function() {
      }), g = !f && !x && u("flatMap", TypeError), p = f || x || g, m = l(function() {
        for (var b = this.iterator, y = this.mapper, w, S; ; ) {
          if (S = this.inner) try {
            if (w = r(i(S.next, S.iterator)), !w.done) return w.value;
            this.inner = null;
          } catch (v) {
            h(b, "throw", v);
          }
          if (w = r(i(this.next, b)), this.done = !!w.done) return;
          try {
            this.inner = c(y(w.value, this.counter++), !1);
          } catch (v) {
            h(b, "throw", v);
          }
        }
      });
      a({ target: "Iterator", proto: !0, real: !0, forced: p }, {
        flatMap: function(y) {
          r(this);
          try {
            s(y);
          } catch (w) {
            h(this, "throw", w);
          }
          return g ? i(g, this, y) : new m(o(this), {
            mapper: y,
            inner: null
          });
        }
      });
    })
  ),
  /***/
  616: (
    /***/
    ((t, e, n) => {
      var a = n(9039);
      t.exports = !a(function() {
        var i = (function() {
        }).bind();
        return typeof i != "function" || i.hasOwnProperty("prototype");
      });
    })
  ),
  /***/
  655: (
    /***/
    ((t, e, n) => {
      var a = n(6955), i = String;
      t.exports = function(s) {
        if (a(s) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return i(s);
      };
    })
  ),
  /***/
  679: (
    /***/
    ((t, e, n) => {
      var a = n(1625), i = TypeError;
      t.exports = function(s, r) {
        if (a(r, s)) return s;
        throw new i("Incorrect invocation");
      };
    })
  ),
  /***/
  684: (
    /***/
    ((t) => {
      t.exports = function(e, n) {
        var a = typeof Iterator == "function" && Iterator.prototype[e];
        if (a) try {
          a.call({ next: null }, n).next();
        } catch {
          return !0;
        }
      };
    })
  ),
  /***/
  741: (
    /***/
    ((t) => {
      var e = Math.ceil, n = Math.floor;
      t.exports = Math.trunc || function(i) {
        var s = +i;
        return (s > 0 ? n : e)(s);
      };
    })
  ),
  /***/
  757: (
    /***/
    ((t, e, n) => {
      var a = n(7751), i = n(4901), s = n(1625), r = n(7040), o = Object;
      t.exports = r ? function(c) {
        return typeof c == "symbol";
      } : function(c) {
        var l = a("Symbol");
        return i(l) && s(l.prototype, o(c));
      };
    })
  ),
  /***/
  851: (
    /***/
    ((t, e, n) => {
      var a = n(6955), i = n(5966), s = n(4117), r = n(6269), o = n(8227), c = o("iterator");
      t.exports = function(l) {
        if (!s(l)) return i(l, c) || i(l, "@@iterator") || r[a(l)];
      };
    })
  ),
  /***/
  944: (
    /***/
    ((t) => {
      var e = TypeError;
      t.exports = function(n) {
        var a = n && n.alphabet;
        if (a === void 0 || a === "base64" || a === "base64url") return a || "base64";
        throw new e("Incorrect `alphabet` option");
      };
    })
  ),
  /***/
  1072: (
    /***/
    ((t, e, n) => {
      var a = n(1828), i = n(8727);
      t.exports = Object.keys || function(r) {
        return a(r, i);
      };
    })
  ),
  /***/
  1103: (
    /***/
    ((t) => {
      t.exports = function(e) {
        try {
          return { error: !1, value: e() };
        } catch (n) {
          return { error: !0, value: n };
        }
      };
    })
  ),
  /***/
  1108: (
    /***/
    ((t, e, n) => {
      var a = n(6955);
      t.exports = function(i) {
        var s = a(i);
        return s === "BigInt64Array" || s === "BigUint64Array";
      };
    })
  ),
  /***/
  1148: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(2652), r = n(9306), o = n(8551), c = n(1767), l = n(9539), h = n(4549), f = h("every", TypeError);
      a({ target: "Iterator", proto: !0, real: !0, forced: f }, {
        every: function(u) {
          o(this);
          try {
            r(u);
          } catch (p) {
            l(this, "throw", p);
          }
          if (f) return i(f, this, u);
          var x = c(this), g = 0;
          return !s(x, function(p, m) {
            if (!u(p, g++)) return m();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    })
  ),
  /***/
  1181: (
    /***/
    ((t, e, n) => {
      var a = n(8622), i = n(4576), s = n(34), r = n(6699), o = n(9297), c = n(7629), l = n(6119), h = n(421), f = "Object already initialized", d = i.TypeError, u = i.WeakMap, x, g, p, m = function(S) {
        return p(S) ? g(S) : x(S, {});
      }, b = function(S) {
        return function(v) {
          var k;
          if (!s(v) || (k = g(v)).type !== S)
            throw new d("Incompatible receiver, " + S + " required");
          return k;
        };
      };
      if (a || c.state) {
        var y = c.state || (c.state = new u());
        y.get = y.get, y.has = y.has, y.set = y.set, x = function(S, v) {
          if (y.has(S)) throw new d(f);
          return v.facade = S, y.set(S, v), v;
        }, g = function(S) {
          return y.get(S) || {};
        }, p = function(S) {
          return y.has(S);
        };
      } else {
        var w = l("state");
        h[w] = !0, x = function(S, v) {
          if (o(S, w)) throw new d(f);
          return v.facade = S, r(S, w, v), v;
        }, g = function(S) {
          return o(S, w) ? S[w] : {};
        }, p = function(S) {
          return o(S, w);
        };
      }
      t.exports = {
        set: x,
        get: g,
        has: p,
        enforce: m,
        getterFor: b
      };
    })
  ),
  /***/
  1291: (
    /***/
    ((t, e, n) => {
      var a = n(741);
      t.exports = function(i) {
        var s = +i;
        return s !== s || s === 0 ? 0 : a(s);
      };
    })
  ),
  /***/
  1385: (
    /***/
    ((t, e, n) => {
      var a = n(9539);
      t.exports = function(i, s, r) {
        for (var o = i.length - 1; o >= 0; o--)
          if (i[o] !== void 0)
            try {
              r = a(i[o].iterator, s, r);
            } catch (c) {
              s = "throw", r = c;
            }
        if (s === "throw") throw r;
        return r;
      };
    })
  ),
  /***/
  1548: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(9039), s = n(9519), r = n(4215), o = a.structuredClone;
      t.exports = !!o && !i(function() {
        if (r === "DENO" && s > 92 || r === "NODE" && s > 94 || r === "BROWSER" && s > 97) return !1;
        var c = new ArrayBuffer(8), l = o(c, { transfer: [c] });
        return c.byteLength !== 0 || l.byteLength !== 8;
      });
    })
  ),
  /***/
  1549: (
    /***/
    ((t, e, n) => {
      n(6632);
    })
  ),
  /***/
  1625: (
    /***/
    ((t, e, n) => {
      var a = n(9504);
      t.exports = a({}.isPrototypeOf);
    })
  ),
  /***/
  1689: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(8745), r = n(7680), o = n(6043), c = n(9306), l = n(1103), h = i.Promise, f = !1, d = !h || !h.try || l(function() {
        h.try(function(u) {
          f = u === 8;
        }, 8);
      }).error || !f;
      a({ target: "Promise", stat: !0, forced: d }, {
        try: function(u) {
          var x = arguments.length > 1 ? r(arguments, 1) : [], g = o.f(this), p = l(function() {
            return s(c(u), void 0, x);
          });
          return (p.error ? g.reject : g.resolve)(p.value), g.promise;
        }
      });
    })
  ),
  /***/
  1698: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4204), s = n(9835), r = n(4916), o = !r("union") || !s("union");
      a({ target: "Set", proto: !0, real: !0, forced: o }, {
        union: i
      });
    })
  ),
  /***/
  1701: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(9306), r = n(8551), o = n(1767), c = n(9462), l = n(6319), h = n(9539), f = n(684), d = n(4549), u = n(6395), x = !u && !f("map", function() {
      }), g = !u && !x && d("map", TypeError), p = u || x || g, m = c(function() {
        var b = this.iterator, y = r(i(this.next, b)), w = this.done = !!y.done;
        if (!w) return l(b, this.mapper, [y.value, this.counter++], !0);
      });
      a({ target: "Iterator", proto: !0, real: !0, forced: p }, {
        map: function(y) {
          r(this);
          try {
            s(y);
          } catch (w) {
            h(this, "throw", w);
          }
          return g ? i(g, this, y) : new m(o(this), {
            mapper: y
          });
        }
      });
    })
  ),
  /***/
  1767: (
    /***/
    ((t) => {
      t.exports = function(e) {
        return {
          iterator: e,
          next: e.next,
          done: !1
        };
      };
    })
  ),
  /***/
  1806: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(8551), s = n(2652), r = n(1767), o = [].push;
      a({ target: "Iterator", proto: !0, real: !0 }, {
        toArray: function() {
          var l = [];
          return s(r(i(this)), o, { that: l, IS_RECORD: !0 }), l;
        }
      });
    })
  ),
  /***/
  1828: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(9297), s = n(5397), r = n(9617).indexOf, o = n(421), c = a([].push);
      t.exports = function(l, h) {
        var f = s(l), d = 0, u = [], x;
        for (x in f) !i(o, x) && i(f, x) && c(u, x);
        for (; h.length > d; ) i(f, x = h[d++]) && (~r(u, x) || c(u, x));
        return u;
      };
    })
  ),
  /***/
  2106: (
    /***/
    ((t, e, n) => {
      var a = n(283), i = n(4913);
      t.exports = function(s, r, o) {
        return o.get && a(o.get, r, { getter: !0 }), o.set && a(o.set, r, { setter: !0 }), i.f(s, r, o);
      };
    })
  ),
  /***/
  2140: (
    /***/
    ((t, e, n) => {
      var a = n(8227), i = a("toStringTag"), s = {};
      s[i] = "z", t.exports = String(s) === "[object z]";
    })
  ),
  /***/
  2195: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = a({}.toString), s = a("".slice);
      t.exports = function(r) {
        return s(i(r), 8, -1);
      };
    })
  ),
  /***/
  2211: (
    /***/
    ((t, e, n) => {
      var a = n(9039);
      t.exports = !a(function() {
        function i() {
        }
        return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
      });
    })
  ),
  /***/
  2303: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(9504), s = a.Uint8Array, r = a.SyntaxError, o = a.parseInt, c = Math.min, l = /[^\da-f]/i, h = i(l.exec), f = i("".slice);
      t.exports = function(d, u) {
        var x = d.length;
        if (x % 2 !== 0) throw new r("String should be an even number of characters");
        for (var g = u ? c(u.length, x / 2) : x / 2, p = u || new s(g), m = 0, b = 0; b < g; ) {
          var y = f(d, m, m += 2);
          if (h(l, y)) throw new r("String should only contain hex characters");
          p[b++] = o(y, 16);
        }
        return { bytes: p, read: m };
      };
    })
  ),
  /***/
  2360: (
    /***/
    ((t, e, n) => {
      var a = n(8551), i = n(6801), s = n(8727), r = n(421), o = n(397), c = n(4055), l = n(6119), h = ">", f = "<", d = "prototype", u = "script", x = l("IE_PROTO"), g = function() {
      }, p = function(S) {
        return f + u + h + S + f + "/" + u + h;
      }, m = function(S) {
        S.write(p("")), S.close();
        var v = S.parentWindow.Object;
        return S = null, v;
      }, b = function() {
        var S = c("iframe"), v = "java" + u + ":", k;
        return S.style.display = "none", o.appendChild(S), S.src = String(v), k = S.contentWindow.document, k.open(), k.write(p("document.F=Object")), k.close(), k.F;
      }, y, w = function() {
        try {
          y = new ActiveXObject("htmlfile");
        } catch {
        }
        w = typeof document < "u" ? document.domain && y ? m(y) : b() : m(y);
        for (var S = s.length; S--; ) delete w[d][s[S]];
        return w();
      };
      r[x] = !0, t.exports = Object.create || function(v, k) {
        var A;
        return v !== null ? (g[d] = a(v), A = new g(), g[d] = null, A[x] = v) : A = w(), k === void 0 ? A : i.f(A, k);
      };
    })
  ),
  /***/
  2475: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(8527), s = n(4916), r = !s("isSupersetOf", function(o) {
        return !o;
      });
      a({ target: "Set", proto: !0, real: !0, forced: r }, {
        isSupersetOf: i
      });
    })
  ),
  /***/
  2489: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(9306), r = n(8551), o = n(1767), c = n(9462), l = n(6319), h = n(6395), f = n(9539), d = n(684), u = n(4549), x = !h && !d("filter", function() {
      }), g = !h && !x && u("filter", TypeError), p = h || x || g, m = c(function() {
        for (var b = this.iterator, y = this.predicate, w = this.next, S, v, k; ; ) {
          if (S = r(i(w, b)), v = this.done = !!S.done, v) return;
          if (k = S.value, l(b, y, [k, this.counter++], !0)) return k;
        }
      });
      a({ target: "Iterator", proto: !0, real: !0, forced: p }, {
        filter: function(y) {
          r(this);
          try {
            s(y);
          } catch (w) {
            f(this, "throw", w);
          }
          return g ? i(g, this, y) : new m(o(this), {
            predicate: y
          });
        }
      });
    })
  ),
  /***/
  2529: (
    /***/
    ((t) => {
      t.exports = function(e, n) {
        return { value: e, done: n };
      };
    })
  ),
  /***/
  2603: (
    /***/
    ((t, e, n) => {
      var a = n(655);
      t.exports = function(i, s) {
        return i === void 0 ? arguments.length < 2 ? "" : s : a(i);
      };
    })
  ),
  /***/
  2652: (
    /***/
    ((t, e, n) => {
      var a = n(6080), i = n(9565), s = n(8551), r = n(6823), o = n(4209), c = n(6198), l = n(1625), h = n(81), f = n(851), d = n(9539), u = TypeError, x = function(p, m) {
        this.stopped = p, this.result = m;
      }, g = x.prototype;
      t.exports = function(p, m, b) {
        var y = b && b.that, w = !!(b && b.AS_ENTRIES), S = !!(b && b.IS_RECORD), v = !!(b && b.IS_ITERATOR), k = !!(b && b.INTERRUPTED), A = a(m, y), C, T, M, O, N, H, J, U = function(P) {
          return C && d(C, "normal"), new x(!0, P);
        }, j = function(P) {
          return w ? (s(P), k ? A(P[0], P[1], U) : A(P[0], P[1])) : k ? A(P, U) : A(P);
        };
        if (S)
          C = p.iterator;
        else if (v)
          C = p;
        else {
          if (T = f(p), !T) throw new u(r(p) + " is not iterable");
          if (o(T)) {
            for (M = 0, O = c(p); O > M; M++)
              if (N = j(p[M]), N && l(g, N)) return N;
            return new x(!1);
          }
          C = h(p, T);
        }
        for (H = S ? p.next : C.next; !(J = i(H, C)).done; ) {
          try {
            N = j(J.value);
          } catch (P) {
            d(C, "throw", P);
          }
          if (typeof N == "object" && N && l(g, N)) return N;
        }
        return new x(!1);
      };
    })
  ),
  /***/
  2777: (
    /***/
    ((t, e, n) => {
      var a = n(9565), i = n(34), s = n(757), r = n(5966), o = n(4270), c = n(8227), l = TypeError, h = c("toPrimitive");
      t.exports = function(f, d) {
        if (!i(f) || s(f)) return f;
        var u = r(f, h), x;
        if (u) {
          if (d === void 0 && (d = "default"), x = a(u, f, d), !i(x) || s(x)) return x;
          throw new l("Can't convert object to primitive value");
        }
        return d === void 0 && (d = "number"), o(f, d);
      };
    })
  ),
  /***/
  2787: (
    /***/
    ((t, e, n) => {
      var a = n(9297), i = n(4901), s = n(8981), r = n(6119), o = n(2211), c = r("IE_PROTO"), l = Object, h = l.prototype;
      t.exports = o ? l.getPrototypeOf : function(f) {
        var d = s(f);
        if (a(d, c)) return d[c];
        var u = d.constructor;
        return i(u) && d instanceof u ? u.prototype : d instanceof l ? h : null;
      };
    })
  ),
  /***/
  2796: (
    /***/
    ((t, e, n) => {
      var a = n(9039), i = n(4901), s = /#|\.prototype\./, r = function(f, d) {
        var u = c[o(f)];
        return u === h ? !0 : u === l ? !1 : i(d) ? a(d) : !!d;
      }, o = r.normalize = function(f) {
        return String(f).replace(s, ".").toLowerCase();
      }, c = r.data = {}, l = r.NATIVE = "N", h = r.POLYFILL = "P";
      t.exports = r;
    })
  ),
  /***/
  2804: (
    /***/
    ((t) => {
      var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", n = e + "+/", a = e + "-_", i = function(s) {
        for (var r = {}, o = 0; o < 64; o++) r[s.charAt(o)] = o;
        return r;
      };
      t.exports = {
        i2c: n,
        c2i: i(n),
        i2cUrl: a,
        c2iUrl: i(a)
      };
    })
  ),
  /***/
  2812: (
    /***/
    ((t) => {
      var e = TypeError;
      t.exports = function(n, a) {
        if (n < a) throw new e("Not enough arguments");
        return n;
      };
    })
  ),
  /***/
  2839: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = a.navigator, s = i && i.userAgent;
      t.exports = s ? String(s) : "";
    })
  ),
  /***/
  2967: (
    /***/
    ((t, e, n) => {
      var a = n(6706), i = n(34), s = n(7750), r = n(3506);
      t.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
        var o = !1, c = {}, l;
        try {
          l = a(Object.prototype, "__proto__", "set"), l(c, []), o = c instanceof Array;
        } catch {
        }
        return function(f, d) {
          return s(f), r(d), i(f) && (o ? l(f, d) : f.__proto__ = d), f;
        };
      })() : void 0);
    })
  ),
  /***/
  3068: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9504), s = n(2652), r = RangeError, o = TypeError, c = 1 / 0, l = NaN, h = Math.abs, f = Math.pow, d = i([].push), u = f(2, 1023), x = f(2, 53) - 1, g = Number.MAX_VALUE, p = f(2, 971), m = {}, b = {}, y = {}, w = {}, S = {}, v = function(k, A) {
        var C = k + A, T = A - (C - k);
        return { hi: C, lo: T };
      };
      a({ target: "Math", stat: !0 }, {
        // eslint-disable-next-line max-statements -- ok
        sumPrecise: function(A) {
          var C = [], T = 0, M = w;
          switch (s(A, function(R) {
            if (++T >= x) throw new r("Maximum allowed index exceeded");
            if (typeof R != "number") throw new o("Value is not a number");
            M !== m && (R !== R ? M = m : R === c ? M = M === b ? m : y : R === -c ? M = M === y ? m : b : (R !== 0 || 1 / R === c) && (M === w || M === S) && (M = S, d(C, R)));
          }), M) {
            case m:
              return l;
            case b:
              return -c;
            case y:
              return c;
            case w:
              return -0;
          }
          for (var O = [], N = 0, H, J, U, j, P, K, xe = 0; xe < C.length; xe++) {
            H = C[xe];
            for (var X = 0, ye = 0; ye < O.length; ye++) {
              if (J = O[ye], h(H) < h(J) && (K = H, H = J, J = K), U = v(H, J), j = U.hi, P = U.lo, h(j) === c) {
                var we = j === c ? 1 : -1;
                N += we, H = H - we * u - we * u, h(H) < h(J) && (K = H, H = J, J = K), U = v(H, J), j = U.hi, P = U.lo;
              }
              P !== 0 && (O[X++] = P), H = j;
            }
            O.length = X, H !== 0 && d(O, H);
          }
          var D = O.length - 1;
          if (j = 0, P = 0, N !== 0) {
            var G = D >= 0 ? O[D] : 0;
            if (D--, h(N) > 1 || N > 0 && G > 0 || N < 0 && G < 0)
              return N > 0 ? c : -c;
            if (U = v(N * u, G / 2), j = U.hi, P = U.lo, P *= 2, h(2 * j) === c)
              return j > 0 ? j === u && P === -(p / 2) && D >= 0 && O[D] < 0 ? g : c : j === -u && P === p / 2 && D >= 0 && O[D] > 0 ? -g : -c;
            P !== 0 && (O[++D] = P, P = 0), j *= 2;
          }
          for (; D >= 0 && (U = v(j, O[D--]), j = U.hi, P = U.lo, P === 0); )
            ;
          return D >= 0 && (P < 0 && O[D] < 0 || P > 0 && O[D] > 0) && (J = P * 2, H = j + J, J === H - j && (j = H)), j;
        }
      });
    })
  ),
  /***/
  3167: (
    /***/
    ((t, e, n) => {
      var a = n(4901), i = n(34), s = n(2967);
      t.exports = function(r, o, c) {
        var l, h;
        return (
          // it can work only with native `setPrototypeOf`
          s && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          a(l = o.constructor) && l !== c && i(h = l.prototype) && h !== c.prototype && s(r, h), r
        );
      };
    })
  ),
  /***/
  3238: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(7811), s = n(7394), r = a.DataView;
      t.exports = function(o) {
        if (!i || s(o) !== 0) return !1;
        try {
          return new r(o), !1;
        } catch {
          return !0;
        }
      };
    })
  ),
  /***/
  3392: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = 0, s = Math.random(), r = a(1.1.toString);
      t.exports = function(o) {
        return "Symbol(" + (o === void 0 ? "" : o) + ")_" + r(++i + s, 36);
      };
    })
  ),
  /***/
  3440: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(4402), s = n(9286), r = n(5170), o = n(3789), c = n(8469), l = n(507), h = i.has, f = i.remove;
      t.exports = function(u) {
        var x = a(this), g = o(u), p = s(x);
        return r(x) <= g.size ? c(x, function(m) {
          g.includes(m) && f(p, m);
        }) : l(g.getIterator(), function(m) {
          h(p, m) && f(p, m);
        }), p;
      };
    })
  ),
  /***/
  3463: (
    /***/
    ((t) => {
      var e = TypeError;
      t.exports = function(n) {
        if (typeof n == "string") return n;
        throw new e("Argument is not a string");
      };
    })
  ),
  /***/
  3506: (
    /***/
    ((t, e, n) => {
      var a = n(3925), i = String, s = TypeError;
      t.exports = function(r) {
        if (a(r)) return r;
        throw new s("Can't set " + i(r) + " as a prototype");
      };
    })
  ),
  /***/
  3579: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(2652), r = n(9306), o = n(8551), c = n(1767), l = n(9539), h = n(4549), f = h("some", TypeError);
      a({ target: "Iterator", proto: !0, real: !0, forced: f }, {
        some: function(u) {
          o(this);
          try {
            r(u);
          } catch (p) {
            l(this, "throw", p);
          }
          if (f) return i(f, this, u);
          var x = c(this), g = 0;
          return s(x, function(p, m) {
            if (u(p, g++)) return m();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    })
  ),
  /***/
  3611: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(2106), r = n(3724), o = TypeError, c = Object.defineProperty, l = i.self !== i;
      try {
        if (r) {
          var h = Object.getOwnPropertyDescriptor(i, "self");
          (l || !h || !h.get || !h.enumerable) && s(i, "self", {
            get: function() {
              return i;
            },
            set: function(d) {
              if (this !== i) throw new o("Illegal invocation");
              c(i, "self", {
                value: d,
                writable: !0,
                configurable: !0,
                enumerable: !0
              });
            },
            configurable: !0,
            enumerable: !0
          });
        } else a({ global: !0, simple: !0, forced: l }, {
          self: i
        });
      } catch {
      }
    })
  ),
  /***/
  3650: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(4402), s = n(9286), r = n(3789), o = n(507), c = i.add, l = i.has, h = i.remove;
      t.exports = function(d) {
        var u = a(this), x = r(d).getIterator(), g = s(u);
        return o(x, function(p) {
          l(u, p) ? h(g, p) : c(g, p);
        }), g;
      };
    })
  ),
  /***/
  3706: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(4901), s = n(7629), r = a(Function.toString);
      i(s.inspectSource) || (s.inspectSource = function(o) {
        return r(o);
      }), t.exports = s.inspectSource;
    })
  ),
  /***/
  3717: (
    /***/
    ((t, e) => {
      e.f = Object.getOwnPropertySymbols;
    })
  ),
  /***/
  3724: (
    /***/
    ((t, e, n) => {
      var a = n(9039);
      t.exports = !a(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    })
  ),
  /***/
  3789: (
    /***/
    ((t, e, n) => {
      var a = n(9306), i = n(8551), s = n(9565), r = n(1291), o = n(1767), c = "Invalid size", l = RangeError, h = TypeError, f = Math.max, d = function(u, x) {
        this.set = u, this.size = f(x, 0), this.has = a(u.has), this.keys = a(u.keys);
      };
      d.prototype = {
        getIterator: function() {
          return o(i(s(this.keys, this.set)));
        },
        includes: function(u) {
          return s(this.has, this.set, u);
        }
      }, t.exports = function(u) {
        i(u);
        var x = +u.size;
        if (x !== x) throw new h(c);
        var g = r(x);
        if (g < 0) throw new l(c);
        return new d(u, g);
      };
    })
  ),
  /***/
  3838: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(5170), s = n(8469), r = n(3789);
      t.exports = function(c) {
        var l = a(this), h = r(c);
        return i(l) > h.size ? !1 : s(l, function(f) {
          if (!h.includes(f)) return !1;
        }, !0) !== !1;
      };
    })
  ),
  /***/
  3853: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4449), s = n(4916), r = !s("isDisjointFrom", function(o) {
        return !o;
      });
      a({ target: "Set", proto: !0, real: !0, forced: r }, {
        isDisjointFrom: i
      });
    })
  ),
  /***/
  3925: (
    /***/
    ((t, e, n) => {
      var a = n(34);
      t.exports = function(i) {
        return a(i) || i === null;
      };
    })
  ),
  /***/
  3972: (
    /***/
    ((t, e, n) => {
      var a = n(34), i = String, s = TypeError;
      t.exports = function(r) {
        if (r === void 0 || a(r)) return r;
        throw new s(i(r) + " is not an object or undefined");
      };
    })
  ),
  /***/
  4055: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(34), s = a.document, r = i(s) && i(s.createElement);
      t.exports = function(o) {
        return r ? s.createElement(o) : {};
      };
    })
  ),
  /***/
  4114: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(8981), s = n(6198), r = n(4527), o = n(6837), c = n(9039), l = c(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      }), h = function() {
        try {
          Object.defineProperty([], "length", { writable: !1 }).push();
        } catch (d) {
          return d instanceof TypeError;
        }
      }, f = l || !h();
      a({ target: "Array", proto: !0, arity: 1, forced: f }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function(u) {
          var x = i(this), g = s(x), p = arguments.length;
          o(g + p);
          for (var m = 0; m < p; m++)
            x[g] = arguments[m], g++;
          return r(x, g), g;
        }
      });
    })
  ),
  /***/
  4117: (
    /***/
    ((t) => {
      t.exports = function(e) {
        return e == null;
      };
    })
  ),
  /***/
  4154: (
    /***/
    ((t, e, n) => {
      var a = n(6955), i = TypeError;
      t.exports = function(s) {
        if (a(s) === "Uint8Array") return s;
        throw new i("Argument is not an Uint8Array");
      };
    })
  ),
  /***/
  4204: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(4402).add, s = n(9286), r = n(3789), o = n(507);
      t.exports = function(l) {
        var h = a(this), f = r(l).getIterator(), d = s(h);
        return o(f, function(u) {
          i(d, u);
        }), d;
      };
    })
  ),
  /***/
  4209: (
    /***/
    ((t, e, n) => {
      var a = n(8227), i = n(6269), s = a("iterator"), r = Array.prototype;
      t.exports = function(o) {
        return o !== void 0 && (i.Array === o || r[s] === o);
      };
    })
  ),
  /***/
  4215: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(2839), s = n(2195), r = function(o) {
        return i.slice(0, o.length) === o;
      };
      t.exports = (function() {
        return r("Bun/") ? "BUN" : r("Cloudflare-Workers") ? "CLOUDFLARE" : r("Deno/") ? "DENO" : r("Node.js/") ? "NODE" : a.Bun && typeof Bun.version == "string" ? "BUN" : a.Deno && typeof Deno.version == "object" ? "DENO" : s(a.process) === "process" ? "NODE" : a.window && a.document ? "BROWSER" : "REST";
      })();
    })
  ),
  /***/
  4226: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(3463), r = n(4154), o = n(5169), c = n(2303);
      i.Uint8Array && a({ target: "Uint8Array", proto: !0 }, {
        setFromHex: function(h) {
          r(this), s(h), o(this.buffer);
          var f = c(h, this).read;
          return { read: f, written: f / 2 };
        }
      });
    })
  ),
  /***/
  4235: (
    /***/
    ((t, e, n) => {
      n(3068);
    })
  ),
  /***/
  4270: (
    /***/
    ((t, e, n) => {
      var a = n(9565), i = n(4901), s = n(34), r = TypeError;
      t.exports = function(o, c) {
        var l, h;
        if (c === "string" && i(l = o.toString) && !s(h = a(l, o)) || i(l = o.valueOf) && !s(h = a(l, o)) || c !== "string" && i(l = o.toString) && !s(h = a(l, o))) return h;
        throw new r("Can't convert object to primitive value");
      };
    })
  ),
  /***/
  4376: (
    /***/
    ((t, e, n) => {
      var a = n(2195);
      t.exports = Array.isArray || function(s) {
        return a(s) === "Array";
      };
    })
  ),
  /***/
  4402: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = Set.prototype;
      t.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: a(i.add),
        has: a(i.has),
        remove: a(i.delete),
        proto: i
      };
    })
  ),
  /***/
  4449: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(4402).has, s = n(5170), r = n(3789), o = n(8469), c = n(507), l = n(9539);
      t.exports = function(f) {
        var d = a(this), u = r(f);
        if (s(d) <= u.size) return o(d, function(g) {
          if (u.includes(g)) return !1;
        }, !0) !== !1;
        var x = u.getIterator();
        return c(x, function(g) {
          if (i(d, g)) return l(x, "normal", !1);
        }) !== !1;
      };
    })
  ),
  /***/
  4483: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(9429), s = n(1548), r = a.structuredClone, o = a.ArrayBuffer, c = a.MessageChannel, l = !1, h, f, d, u;
      if (s)
        l = function(x) {
          r(x, { transfer: [x] });
        };
      else if (o) try {
        c || (h = i("worker_threads"), h && (c = h.MessageChannel)), c && (f = new c(), d = new o(2), u = function(x) {
          f.port1.postMessage(null, [x]);
        }, d.byteLength === 2 && (u(d), d.byteLength === 0 && (l = u)));
      } catch {
      }
      t.exports = l;
    })
  ),
  /***/
  4495: (
    /***/
    ((t, e, n) => {
      var a = n(9519), i = n(9039), s = n(4576), r = s.String;
      t.exports = !!Object.getOwnPropertySymbols && !i(function() {
        var o = Symbol("symbol detection");
        return !r(o) || !(Object(o) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && a && a < 41;
      });
    })
  ),
  /***/
  4527: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(4376), s = TypeError, r = Object.getOwnPropertyDescriptor, o = a && !(function() {
        if (this !== void 0) return !0;
        try {
          Object.defineProperty([], "length", { writable: !1 }).length = 1;
        } catch (c) {
          return c instanceof TypeError;
        }
      })();
      t.exports = o ? function(c, l) {
        if (i(c) && !r(c, "length").writable)
          throw new s("Cannot set read only .length");
        return c.length = l;
      } : function(c, l) {
        return c.length = l;
      };
    })
  ),
  /***/
  4549: (
    /***/
    ((t, e, n) => {
      var a = n(4576);
      t.exports = function(i, s) {
        var r = a.Iterator, o = r && r.prototype, c = o && o[i], l = !1;
        if (c) try {
          c.call({
            next: function() {
              return { done: !0 };
            },
            return: function() {
              l = !0;
            }
          }, -1);
        } catch (h) {
          h instanceof s || (l = !1);
        }
        if (!l) return c;
      };
    })
  ),
  /***/
  4576: (
    /***/
    (function(t) {
      var e = function(n) {
        return n && n.Math === Math && n;
      };
      t.exports = // eslint-disable-next-line es/no-global-this -- safe
      e(typeof globalThis == "object" && globalThis) || e(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      e(typeof self == "object" && self) || e(typeof global == "object" && global) || e(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ (function() {
        return this;
      })() || Function("return this")();
    })
  ),
  /***/
  4603: (
    /***/
    ((t, e, n) => {
      var a = n(6840), i = n(9504), s = n(655), r = n(2812), o = URLSearchParams, c = o.prototype, l = i(c.append), h = i(c.delete), f = i(c.forEach), d = i([].push), u = new o("a=1&a=2&b=3");
      u.delete("a", 1), u.delete("b", void 0), u + "" != "a=2" && a(c, "delete", function(x) {
        var g = arguments.length, p = g < 2 ? void 0 : arguments[1];
        if (g && p === void 0) return h(this, x);
        var m = [];
        f(this, function(C, T) {
          d(m, { key: T, value: C });
        }), r(g, 1);
        for (var b = s(x), y = s(p), w = 0, S = 0, v = !1, k = m.length, A; w < k; )
          A = m[w++], v || A.key === b ? (v = !0, h(this, A.key)) : S++;
        for (; S < k; )
          A = m[S++], A.key === b && A.value === y || l(this, A.key, A.value);
      }, { enumerable: !0, unsafe: !0 });
    })
  ),
  /***/
  4628: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(6043);
      a({ target: "Promise", stat: !0 }, {
        withResolvers: function() {
          var r = i.f(this);
          return {
            promise: r.promise,
            resolve: r.resolve,
            reject: r.reject
          };
        }
      });
    })
  ),
  /***/
  4644: (
    /***/
    ((t, e, n) => {
      var a = n(7811), i = n(3724), s = n(4576), r = n(4901), o = n(34), c = n(9297), l = n(6955), h = n(6823), f = n(6699), d = n(6840), u = n(2106), x = n(1625), g = n(2787), p = n(2967), m = n(8227), b = n(3392), y = n(1181), w = y.enforce, S = y.get, v = s.Int8Array, k = v && v.prototype, A = s.Uint8ClampedArray, C = A && A.prototype, T = v && g(v), M = k && g(k), O = Object.prototype, N = s.TypeError, H = m("toStringTag"), J = b("TYPED_ARRAY_TAG"), U = "TypedArrayConstructor", j = a && !!p && l(s.opera) !== "Opera", P = !1, K, xe, X, ye = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, we = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, D = function(de) {
        if (!o(de)) return !1;
        var fe = l(de);
        return fe === "DataView" || c(ye, fe) || c(we, fe);
      }, G = function(_) {
        var de = g(_);
        if (o(de)) {
          var fe = S(de);
          return fe && c(fe, U) ? fe[U] : G(de);
        }
      }, R = function(_) {
        if (!o(_)) return !1;
        var de = l(_);
        return c(ye, de) || c(we, de);
      }, L = function(_) {
        if (R(_)) return _;
        throw new N("Target is not a typed array");
      }, V = function(_) {
        if (r(_) && (!p || x(T, _))) return _;
        throw new N(h(_) + " is not a typed array constructor");
      }, he = function(_, de, fe, Ee) {
        if (i) {
          if (fe) for (var Ae in ye) {
            var ie = s[Ae];
            if (ie && c(ie.prototype, _)) try {
              delete ie.prototype[_];
            } catch {
              try {
                ie.prototype[_] = de;
              } catch {
              }
            }
          }
          (!M[_] || fe) && d(M, _, fe ? de : j && k[_] || de, Ee);
        }
      }, te = function(_, de, fe) {
        var Ee, Ae;
        if (i) {
          if (p) {
            if (fe) {
              for (Ee in ye)
                if (Ae = s[Ee], Ae && c(Ae, _)) try {
                  delete Ae[_];
                } catch {
                }
            }
            if (!T[_] || fe)
              try {
                return d(T, _, fe ? de : j && T[_] || de);
              } catch {
              }
            else return;
          }
          for (Ee in ye)
            Ae = s[Ee], Ae && (!Ae[_] || fe) && d(Ae, _, de);
        }
      };
      for (K in ye)
        xe = s[K], X = xe && xe.prototype, X ? w(X)[U] = xe : j = !1;
      for (K in we)
        xe = s[K], X = xe && xe.prototype, X && (w(X)[U] = xe);
      if ((!j || !r(T) || T === Function.prototype) && (T = function() {
        throw new N("Incorrect invocation");
      }, j))
        for (K in ye)
          s[K] && p(s[K], T);
      if ((!j || !M || M === O) && (M = T.prototype, j))
        for (K in ye)
          s[K] && p(s[K].prototype, M);
      if (j && g(C) !== M && p(C, M), i && !c(M, H)) {
        P = !0, u(M, H, {
          configurable: !0,
          get: function() {
            return o(this) ? this[J] : void 0;
          }
        });
        for (K in ye) s[K] && f(s[K], J, K);
      }
      t.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: j,
        TYPED_ARRAY_TAG: P && J,
        aTypedArray: L,
        aTypedArrayConstructor: V,
        exportTypedArrayMethod: he,
        exportTypedArrayStaticMethod: te,
        getTypedArrayConstructor: G,
        isView: D,
        isTypedArray: R,
        TypedArray: T,
        TypedArrayPrototype: M
      };
    })
  ),
  /***/
  4659: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(4913), s = n(6980);
      t.exports = function(r, o, c) {
        a ? i.f(r, o, s(0, c)) : r[o] = c;
      };
    })
  ),
  /***/
  4901: (
    /***/
    ((t) => {
      var e = typeof document == "object" && document.all;
      t.exports = typeof e > "u" && e !== void 0 ? function(n) {
        return typeof n == "function" || n === e;
      } : function(n) {
        return typeof n == "function";
      };
    })
  ),
  /***/
  4913: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(5917), s = n(8686), r = n(8551), o = n(6969), c = TypeError, l = Object.defineProperty, h = Object.getOwnPropertyDescriptor, f = "enumerable", d = "configurable", u = "writable";
      e.f = a ? s ? function(g, p, m) {
        if (r(g), p = o(p), r(m), typeof g == "function" && p === "prototype" && "value" in m && u in m && !m[u]) {
          var b = h(g, p);
          b && b[u] && (g[p] = m.value, m = {
            configurable: d in m ? m[d] : b[d],
            enumerable: f in m ? m[f] : b[f],
            writable: !1
          });
        }
        return l(g, p, m);
      } : l : function(g, p, m) {
        if (r(g), p = o(p), r(m), i) try {
          return l(g, p, m);
        } catch {
        }
        if ("get" in m || "set" in m) throw new c("Accessors not supported");
        return "value" in m && (g[p] = m.value), g;
      };
    })
  ),
  /***/
  4916: (
    /***/
    ((t, e, n) => {
      var a = n(7751), i = function(r) {
        return {
          size: r,
          has: function() {
            return !1;
          },
          keys: function() {
            return {
              next: function() {
                return { done: !0 };
              }
            };
          }
        };
      }, s = function(r) {
        return {
          size: r,
          has: function() {
            return !0;
          },
          keys: function() {
            throw new Error("e");
          }
        };
      };
      t.exports = function(r, o) {
        var c = a("Set");
        try {
          new c()[r](i(0));
          try {
            return new c()[r](i(-1)), !1;
          } catch {
            if (!o) return !0;
            try {
              return new c()[r](s(-1 / 0)), !1;
            } catch {
              var l = new c();
              return l.add(1), l.add(2), o(l[r](s(1 / 0)));
            }
          }
        } catch {
          return !1;
        }
      };
    })
  ),
  /***/
  4979: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(7751), r = n(6980), o = n(4913).f, c = n(9297), l = n(679), h = n(3167), f = n(2603), d = n(5002), u = n(8574), x = n(3724), g = n(6395), p = "DOMException", m = s("Error"), b = s(p), y = function() {
        l(this, w);
        var U = arguments.length, j = f(U < 1 ? void 0 : arguments[0]), P = f(U < 2 ? void 0 : arguments[1], "Error"), K = new b(j, P), xe = new m(j);
        return xe.name = p, o(K, "stack", r(1, u(xe.stack, 1))), h(K, this, y), K;
      }, w = y.prototype = b.prototype, S = "stack" in new m(p), v = "stack" in new b(1, 2), k = b && x && Object.getOwnPropertyDescriptor(i, p), A = !!k && !(k.writable && k.configurable), C = S && !A && !v;
      a({ global: !0, constructor: !0, forced: g || C }, {
        // TODO: fix export logic
        DOMException: C ? y : b
      });
      var T = s(p), M = T.prototype;
      if (M.constructor !== T) {
        g || o(M, "constructor", r(1, T));
        for (var O in d) if (c(d, O)) {
          var N = d[O], H = N.s;
          c(T, H) || o(T, H, r(6, N.c));
        }
      }
    })
  ),
  /***/
  5002: (
    /***/
    ((t) => {
      t.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    })
  ),
  /***/
  5024: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(3650), s = n(9835), r = n(4916), o = !r("symmetricDifference") || !s("symmetricDifference");
      a({ target: "Set", proto: !0, real: !0, forced: o }, {
        symmetricDifference: i
      });
    })
  ),
  /***/
  5031: (
    /***/
    ((t, e, n) => {
      var a = n(7751), i = n(9504), s = n(8480), r = n(3717), o = n(8551), c = i([].concat);
      t.exports = a("Reflect", "ownKeys") || function(h) {
        var f = s.f(o(h)), d = r.f;
        return d ? c(f, d(h)) : f;
      };
    })
  ),
  /***/
  5169: (
    /***/
    ((t, e, n) => {
      var a = n(3238), i = TypeError;
      t.exports = function(s) {
        if (a(s)) throw new i("ArrayBuffer is detached");
        return s;
      };
    })
  ),
  /***/
  5170: (
    /***/
    ((t, e, n) => {
      var a = n(6706), i = n(4402);
      t.exports = a(i.proto, "size", "get") || function(s) {
        return s.size;
      };
    })
  ),
  /***/
  5213: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(5370), r = n(9143), o = i.Uint8Array, c = !o || !o.fromBase64 || !(function() {
        try {
          o.fromBase64("a");
          return;
        } catch {
        }
        try {
          o.fromBase64("", null);
        } catch {
          return !0;
        }
      })();
      o && a({ target: "Uint8Array", stat: !0, forced: c }, {
        fromBase64: function(h) {
          var f = r(h, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
          return s(o, f.bytes);
        }
      });
    })
  ),
  /***/
  5370: (
    /***/
    ((t, e, n) => {
      var a = n(6198);
      t.exports = function(i, s, r) {
        for (var o = 0, c = arguments.length > 2 ? r : a(s), l = new i(c); c > o; ) l[o] = s[o++];
        return l;
      };
    })
  ),
  /***/
  5397: (
    /***/
    ((t, e, n) => {
      var a = n(7055), i = n(7750);
      t.exports = function(s) {
        return a(i(s));
      };
    })
  ),
  /***/
  5610: (
    /***/
    ((t, e, n) => {
      var a = n(1291), i = Math.max, s = Math.min;
      t.exports = function(r, o) {
        var c = a(r);
        return c < 0 ? i(c + o, 0) : s(c, o);
      };
    })
  ),
  /***/
  5623: (
    /***/
    ((t, e, n) => {
      n(456);
    })
  ),
  /***/
  5636: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(9504), s = n(6706), r = n(7696), o = n(5169), c = n(7394), l = n(4483), h = n(1548), f = a.structuredClone, d = a.ArrayBuffer, u = a.DataView, x = Math.min, g = d.prototype, p = u.prototype, m = i(g.slice), b = s(g, "resizable", "get"), y = s(g, "maxByteLength", "get"), w = i(p.getInt8), S = i(p.setInt8);
      t.exports = (h || l) && function(v, k, A) {
        var C = c(v), T = k === void 0 ? C : r(k), M = !b || !b(v), O;
        if (o(v), h && (v = f(v, { transfer: [v] }), C === T && (A || M)))
          return v;
        if (C >= T && (!A || M))
          O = m(v, 0, T);
        else {
          var N = A && !M && y ? { maxByteLength: y(v) } : void 0;
          O = new d(T, N);
          for (var H = new u(v), J = new u(O), U = x(T, C), j = 0; j < U; j++) S(J, j, w(H, j));
        }
        return h || l(v), O;
      };
    })
  ),
  /***/
  5745: (
    /***/
    ((t, e, n) => {
      var a = n(7629);
      t.exports = function(i, s) {
        return a[i] || (a[i] = s || {});
      };
    })
  ),
  /***/
  5781: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(7751), s = n(2812), r = n(655), o = n(7416), c = i("URL");
      a({ target: "URL", stat: !0, forced: !o }, {
        parse: function(h) {
          var f = s(arguments.length, 1), d = r(h), u = f < 2 || arguments[1] === void 0 ? void 0 : r(arguments[1]);
          try {
            return new c(d, u);
          } catch {
            return null;
          }
        }
      });
    })
  ),
  /***/
  5854: (
    /***/
    ((t, e, n) => {
      var a = n(2777), i = TypeError;
      t.exports = function(s) {
        var r = a(s, "number");
        if (typeof r == "number") throw new i("Can't convert number to bigint");
        return BigInt(r);
      };
    })
  ),
  /***/
  5876: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(3838), s = n(4916), r = !s("isSubsetOf", function(o) {
        return o;
      });
      a({ target: "Set", proto: !0, real: !0, forced: r }, {
        isSubsetOf: i
      });
    })
  ),
  /***/
  5917: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(9039), s = n(4055);
      t.exports = !a && !i(function() {
        return Object.defineProperty(s("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    })
  ),
  /***/
  5966: (
    /***/
    ((t, e, n) => {
      var a = n(9306), i = n(4117);
      t.exports = function(s, r) {
        var o = s[r];
        return i(o) ? void 0 : a(o);
      };
    })
  ),
  /***/
  6043: (
    /***/
    ((t, e, n) => {
      var a = n(9306), i = TypeError, s = function(r) {
        var o, c;
        this.promise = new r(function(l, h) {
          if (o !== void 0 || c !== void 0) throw new i("Bad Promise constructor");
          o = l, c = h;
        }), this.resolve = a(o), this.reject = a(c);
      };
      t.exports.f = function(r) {
        return new s(r);
      };
    })
  ),
  /***/
  6080: (
    /***/
    ((t, e, n) => {
      var a = n(7476), i = n(9306), s = n(616), r = a(a.bind);
      t.exports = function(o, c) {
        return i(o), c === void 0 ? o : s ? r(o, c) : function() {
          return o.apply(c, arguments);
        };
      };
    })
  ),
  /***/
  6119: (
    /***/
    ((t, e, n) => {
      var a = n(5745), i = n(3392), s = a("keys");
      t.exports = function(r) {
        return s[r] || (s[r] = i(r));
      };
    })
  ),
  /***/
  6193: (
    /***/
    ((t, e, n) => {
      var a = n(4215);
      t.exports = a === "NODE";
    })
  ),
  /***/
  6198: (
    /***/
    ((t, e, n) => {
      var a = n(8014);
      t.exports = function(i) {
        return a(i.length);
      };
    })
  ),
  /***/
  6269: (
    /***/
    ((t) => {
      t.exports = {};
    })
  ),
  /***/
  6279: (
    /***/
    ((t, e, n) => {
      var a = n(6840);
      t.exports = function(i, s, r) {
        for (var o in s) a(i, o, s[o], r);
        return i;
      };
    })
  ),
  /***/
  6319: (
    /***/
    ((t, e, n) => {
      var a = n(8551), i = n(9539);
      t.exports = function(s, r, o, c) {
        try {
          return c ? r(a(o)[0], o[1]) : r(o);
        } catch (l) {
          i(s, "throw", l);
        }
      };
    })
  ),
  /***/
  6395: (
    /***/
    ((t) => {
      t.exports = !1;
    })
  ),
  /***/
  6518: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(7347).f, s = n(6699), r = n(6840), o = n(9433), c = n(7740), l = n(2796);
      t.exports = function(h, f) {
        var d = h.target, u = h.global, x = h.stat, g, p, m, b, y, w;
        if (u ? p = a : x ? p = a[d] || o(d, {}) : p = a[d] && a[d].prototype, p) for (m in f) {
          if (y = f[m], h.dontCallGetSet ? (w = i(p, m), b = w && w.value) : b = p[m], g = l(u ? m : d + (x ? "." : "#") + m, h.forced), !g && b !== void 0) {
            if (typeof y == typeof b) continue;
            c(y, b);
          }
          (h.sham || b && b.sham) && s(y, "sham", !0), r(p, m, y, h);
        }
      };
    })
  ),
  /***/
  6573: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(2106), s = n(3238), r = ArrayBuffer.prototype;
      a && !("detached" in r) && i(r, "detached", {
        configurable: !0,
        get: function() {
          return s(this);
        }
      });
    })
  ),
  /***/
  6632: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(9143), r = n(4154), o = i.Uint8Array, c = !o || !o.prototype.setFromBase64 || !(function() {
        var l = new o([255, 255, 255, 255, 255]);
        try {
          l.setFromBase64("", null);
          return;
        } catch {
        }
        try {
          l.setFromBase64("a");
          return;
        } catch {
        }
        try {
          l.setFromBase64("MjYyZg===");
        } catch {
          return l[0] === 50 && l[1] === 54 && l[2] === 50 && l[3] === 255 && l[4] === 255;
        }
      })();
      o && a({ target: "Uint8Array", proto: !0, forced: c }, {
        setFromBase64: function(h) {
          r(this);
          var f = s(h, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
          return { read: f.read, written: f.written };
        }
      });
    })
  ),
  /***/
  6699: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(4913), s = n(6980);
      t.exports = a ? function(r, o, c) {
        return i.f(r, o, s(1, c));
      } : function(r, o, c) {
        return r[o] = c, r;
      };
    })
  ),
  /***/
  6706: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(9306);
      t.exports = function(s, r, o) {
        try {
          return a(i(Object.getOwnPropertyDescriptor(s, r)[o]));
        } catch {
        }
      };
    })
  ),
  /***/
  6801: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(8686), s = n(4913), r = n(8551), o = n(5397), c = n(1072);
      e.f = a && !i ? Object.defineProperties : function(h, f) {
        r(h);
        for (var d = o(f), u = c(f), x = u.length, g = 0, p; x > g; ) s.f(h, p = u[g++], d[p]);
        return h;
      };
    })
  ),
  /***/
  6823: (
    /***/
    ((t) => {
      var e = String;
      t.exports = function(n) {
        try {
          return e(n);
        } catch {
          return "Object";
        }
      };
    })
  ),
  /***/
  6837: (
    /***/
    ((t) => {
      var e = TypeError, n = 9007199254740991;
      t.exports = function(a) {
        if (a > n) throw e("Maximum allowed index exceeded");
        return a;
      };
    })
  ),
  /***/
  6840: (
    /***/
    ((t, e, n) => {
      var a = n(4901), i = n(4913), s = n(283), r = n(9433);
      t.exports = function(o, c, l, h) {
        h || (h = {});
        var f = h.enumerable, d = h.name !== void 0 ? h.name : c;
        if (a(l) && s(l, d, h), h.global)
          f ? o[c] = l : r(c, l);
        else {
          try {
            h.unsafe ? o[c] && (f = !0) : delete o[c];
          } catch {
          }
          f ? o[c] = l : i.f(o, c, {
            value: l,
            enumerable: !1,
            configurable: !h.nonConfigurable,
            writable: !h.nonWritable
          });
        }
        return o;
      };
    })
  ),
  /***/
  6955: (
    /***/
    ((t, e, n) => {
      var a = n(2140), i = n(4901), s = n(2195), r = n(8227), o = r("toStringTag"), c = Object, l = s(/* @__PURE__ */ (function() {
        return arguments;
      })()) === "Arguments", h = function(f, d) {
        try {
          return f[d];
        } catch {
        }
      };
      t.exports = a ? s : function(f) {
        var d, u, x;
        return f === void 0 ? "Undefined" : f === null ? "Null" : typeof (u = h(d = c(f), o)) == "string" ? u : l ? s(d) : (x = s(d)) === "Object" && i(d.callee) ? "Arguments" : x;
      };
    })
  ),
  /***/
  6969: (
    /***/
    ((t, e, n) => {
      var a = n(2777), i = n(757);
      t.exports = function(s) {
        var r = a(s, "string");
        return i(r) ? r : r + "";
      };
    })
  ),
  /***/
  6980: (
    /***/
    ((t) => {
      t.exports = function(e, n) {
        return {
          enumerable: !(e & 1),
          configurable: !(e & 2),
          writable: !(e & 4),
          value: n
        };
      };
    })
  ),
  /***/
  7040: (
    /***/
    ((t, e, n) => {
      var a = n(4495);
      t.exports = a && !Symbol.sham && typeof Symbol.iterator == "symbol";
    })
  ),
  /***/
  7055: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(9039), s = n(2195), r = Object, o = a("".split);
      t.exports = i(function() {
        return !r("z").propertyIsEnumerable(0);
      }) ? function(c) {
        return s(c) === "String" ? o(c, "") : r(c);
      } : r;
    })
  ),
  /***/
  7080: (
    /***/
    ((t, e, n) => {
      var a = n(4402).has;
      t.exports = function(i) {
        return a(i), i;
      };
    })
  ),
  /***/
  7347: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(9565), s = n(8773), r = n(6980), o = n(5397), c = n(6969), l = n(9297), h = n(5917), f = Object.getOwnPropertyDescriptor;
      e.f = a ? f : function(u, x) {
        if (u = o(u), x = c(x), h) try {
          return f(u, x);
        } catch {
        }
        if (l(u, x)) return r(!i(s.f, u, x), u[x]);
      };
    })
  ),
  /***/
  7394: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(6706), s = n(2195), r = a.ArrayBuffer, o = a.TypeError;
      t.exports = r && i(r.prototype, "byteLength", "get") || function(c) {
        if (s(c) !== "ArrayBuffer") throw new o("ArrayBuffer expected");
        return c.byteLength;
      };
    })
  ),
  /***/
  7416: (
    /***/
    ((t, e, n) => {
      var a = n(9039), i = n(8227), s = n(3724), r = n(6395), o = i("iterator");
      t.exports = !a(function() {
        var c = new URL("b?a=1&b=2&c=3", "https://a"), l = c.searchParams, h = new URLSearchParams("a=1&a=2&b=3"), f = "";
        return c.pathname = "c%20d", l.forEach(function(d, u) {
          l.delete("b"), f += u + d;
        }), h.delete("a", 2), h.delete("b", void 0), r && (!c.toJSON || !h.has("a", 1) || h.has("a", 2) || !h.has("a", void 0) || h.has("b")) || !l.size && (r || !s) || !l.sort || c.href !== "https://a/c%20d?a=1&c=3" || l.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !l[o] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://").host !== "xn--e1aybc" || new URL("https://a#").hash !== "#%D0%B1" || f !== "a1c3" || new URL("https://x", void 0).host !== "x";
      });
    })
  ),
  /***/
  7476: (
    /***/
    ((t, e, n) => {
      var a = n(2195), i = n(9504);
      t.exports = function(s) {
        if (a(s) === "Function") return i(s);
      };
    })
  ),
  /***/
  7566: (
    /***/
    ((t, e, n) => {
      var a = n(6840), i = n(9504), s = n(655), r = n(2812), o = URLSearchParams, c = o.prototype, l = i(c.getAll), h = i(c.has), f = new o("a=1");
      (f.has("a", 2) || !f.has("a", void 0)) && a(c, "has", function(u) {
        var x = arguments.length, g = x < 2 ? void 0 : arguments[1];
        if (x && g === void 0) return h(this, u);
        var p = l(this, u);
        r(x, 1);
        for (var m = s(g), b = 0; b < p.length; )
          if (p[b++] === m) return !0;
        return !1;
      }, { enumerable: !0, unsafe: !0 });
    })
  ),
  /***/
  7588: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9565), s = n(2652), r = n(9306), o = n(8551), c = n(1767), l = n(9539), h = n(4549), f = h("forEach", TypeError);
      a({ target: "Iterator", proto: !0, real: !0, forced: f }, {
        forEach: function(u) {
          o(this);
          try {
            r(u);
          } catch (p) {
            l(this, "throw", p);
          }
          if (f) return i(f, this, u);
          var x = c(this), g = 0;
          s(x, function(p) {
            u(p, g++);
          }, { IS_RECORD: !0 });
        }
      });
    })
  ),
  /***/
  7594: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(9039), s = a.RegExp, r = !i(function() {
        var o = !0;
        try {
          s(".", "d");
        } catch {
          o = !1;
        }
        var c = {}, l = "", h = o ? "dgimsy" : "gimsy", f = function(g, p) {
          Object.defineProperty(c, g, { get: function() {
            return l += p, !0;
          } });
        }, d = {
          dotAll: "s",
          global: "g",
          ignoreCase: "i",
          multiline: "m",
          sticky: "y"
        };
        o && (d.hasIndices = "d");
        for (var u in d) f(u, d[u]);
        var x = Object.getOwnPropertyDescriptor(s.prototype, "flags").get.call(c);
        return x !== h || l !== h;
      });
      t.exports = { correct: r };
    })
  ),
  /***/
  7629: (
    /***/
    ((t, e, n) => {
      var a = n(6395), i = n(4576), s = n(9433), r = "__core-js_shared__", o = t.exports = i[r] || s(r, {});
      (o.versions || (o.versions = [])).push({
        version: "3.45.1",
        mode: a ? "pure" : "global",
        copyright: " 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    })
  ),
  /***/
  7642: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(3440), s = n(9039), r = n(4916), o = !r("difference", function(l) {
        return l.size === 0;
      }), c = o || s(function() {
        var l = {
          size: 1,
          has: function() {
            return !0;
          },
          keys: function() {
            var f = 0;
            return {
              next: function() {
                var d = f++ > 1;
                return h.has(1) && h.clear(), { done: d, value: 2 };
              }
            };
          }
        }, h = /* @__PURE__ */ new Set([1, 2, 3, 4]);
        return h.difference(l).size !== 3;
      });
      a({ target: "Set", proto: !0, real: !0, forced: c }, {
        difference: i
      });
    })
  ),
  /***/
  7657: (
    /***/
    ((t, e, n) => {
      var a = n(9039), i = n(4901), s = n(34), r = n(2360), o = n(2787), c = n(6840), l = n(8227), h = n(6395), f = l("iterator"), d = !1, u, x, g;
      [].keys && (g = [].keys(), "next" in g ? (x = o(o(g)), x !== Object.prototype && (u = x)) : d = !0);
      var p = !s(u) || a(function() {
        var m = {};
        return u[f].call(m) !== m;
      });
      p ? u = {} : h && (u = r(u)), i(u[f]) || c(u, f, function() {
        return this;
      }), t.exports = {
        IteratorPrototype: u,
        BUGGY_SAFARI_ITERATORS: d
      };
    })
  ),
  /***/
  7680: (
    /***/
    ((t, e, n) => {
      var a = n(9504);
      t.exports = a([].slice);
    })
  ),
  /***/
  7696: (
    /***/
    ((t, e, n) => {
      var a = n(1291), i = n(8014), s = RangeError;
      t.exports = function(r) {
        if (r === void 0) return 0;
        var o = a(r), c = i(o);
        if (o !== c) throw new s("Wrong length or index");
        return c;
      };
    })
  ),
  /***/
  7740: (
    /***/
    ((t, e, n) => {
      var a = n(9297), i = n(5031), s = n(7347), r = n(4913);
      t.exports = function(o, c, l) {
        for (var h = i(c), f = r.f, d = s.f, u = 0; u < h.length; u++) {
          var x = h[u];
          !a(o, x) && !(l && a(l, x)) && f(o, x, d(c, x));
        }
      };
    })
  ),
  /***/
  7750: (
    /***/
    ((t, e, n) => {
      var a = n(4117), i = TypeError;
      t.exports = function(s) {
        if (a(s)) throw new i("Can't call method on " + s);
        return s;
      };
    })
  ),
  /***/
  7751: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(4901), s = function(r) {
        return i(r) ? r : void 0;
      };
      t.exports = function(r, o) {
        return arguments.length < 2 ? s(a[r]) : a[r] && a[r][o];
      };
    })
  ),
  /***/
  7811: (
    /***/
    ((t) => {
      t.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    })
  ),
  /***/
  7936: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(5636);
      i && a({ target: "ArrayBuffer", proto: !0 }, {
        transferToFixedLength: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !1);
        }
      });
    })
  ),
  /***/
  7979: (
    /***/
    ((t, e, n) => {
      var a = n(8551);
      t.exports = function() {
        var i = a(this), s = "";
        return i.hasIndices && (s += "d"), i.global && (s += "g"), i.ignoreCase && (s += "i"), i.multiline && (s += "m"), i.dotAll && (s += "s"), i.unicode && (s += "u"), i.unicodeSets && (s += "v"), i.sticky && (s += "y"), s;
      };
    })
  ),
  /***/
  8004: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(9039), s = n(8750), r = n(4916), o = !r("intersection", function(c) {
        return c.size === 2 && c.has(1) && c.has(2);
      }) || i(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      a({ target: "Set", proto: !0, real: !0, forced: o }, {
        intersection: s
      });
    })
  ),
  /***/
  8014: (
    /***/
    ((t, e, n) => {
      var a = n(1291), i = Math.min;
      t.exports = function(s) {
        var r = a(s);
        return r > 0 ? i(r, 9007199254740991) : 0;
      };
    })
  ),
  /***/
  8100: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(5636);
      i && a({ target: "ArrayBuffer", proto: !0 }, {
        transfer: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !0);
        }
      });
    })
  ),
  /***/
  8111: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(679), r = n(8551), o = n(4901), c = n(2787), l = n(2106), h = n(4659), f = n(9039), d = n(9297), u = n(8227), x = n(7657).IteratorPrototype, g = n(3724), p = n(6395), m = "constructor", b = "Iterator", y = u("toStringTag"), w = TypeError, S = i[b], v = p || !o(S) || S.prototype !== x || !f(function() {
        S({});
      }), k = function() {
        if (s(this, x), c(this) === x) throw new w("Abstract class Iterator not directly constructable");
      }, A = function(C, T) {
        g ? l(x, C, {
          configurable: !0,
          get: function() {
            return T;
          },
          set: function(M) {
            if (r(this), this === x) throw new w("You can't redefine this property");
            d(this, C) ? this[C] = M : h(this, C, M);
          }
        }) : x[C] = T;
      };
      d(x, y) || A(y, b), (v || !d(x, m) || x[m] === Object) && A(m, k), k.prototype = x, a({ global: !0, constructor: !0, forced: v }, {
        Iterator: k
      });
    })
  ),
  /***/
  8227: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(5745), s = n(9297), r = n(3392), o = n(4495), c = n(7040), l = a.Symbol, h = i("wks"), f = c ? l.for || l : l && l.withoutSetter || r;
      t.exports = function(d) {
        return s(h, d) || (h[d] = o && s(l, d) ? l[d] : f("Symbol." + d)), h[d];
      };
    })
  ),
  /***/
  8237: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(2652), s = n(9306), r = n(8551), o = n(1767), c = n(9539), l = n(4549), h = n(8745), f = n(9039), d = TypeError, u = f(function() {
        [].keys().reduce(function() {
        }, void 0);
      }), x = !u && l("reduce", d);
      a({ target: "Iterator", proto: !0, real: !0, forced: u || x }, {
        reduce: function(p) {
          r(this);
          try {
            s(p);
          } catch (S) {
            c(this, "throw", S);
          }
          var m = arguments.length < 2, b = m ? void 0 : arguments[1];
          if (x)
            return h(x, this, m ? [p] : [p, b]);
          var y = o(this), w = 0;
          if (i(y, function(S) {
            m ? (m = !1, b = S) : b = p(b, S, w), w++;
          }, { IS_RECORD: !0 }), m) throw new d("Reduce of empty iterator with no initial value");
          return b;
        }
      });
    })
  ),
  /***/
  8469: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(507), s = n(4402), r = s.Set, o = s.proto, c = a(o.forEach), l = a(o.keys), h = l(new r()).next;
      t.exports = function(f, d, u) {
        return u ? i({ iterator: l(f), next: h }, d) : c(f, d);
      };
    })
  ),
  /***/
  8480: (
    /***/
    ((t, e, n) => {
      var a = n(1828), i = n(8727), s = i.concat("length", "prototype");
      e.f = Object.getOwnPropertyNames || function(o) {
        return a(o, s);
      };
    })
  ),
  /***/
  8527: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(4402).has, s = n(5170), r = n(3789), o = n(507), c = n(9539);
      t.exports = function(h) {
        var f = a(this), d = r(h);
        if (s(f) < d.size) return !1;
        var u = d.getIterator();
        return o(u, function(x) {
          if (!i(f, x)) return c(u, "normal", !1);
        }) !== !1;
      };
    })
  ),
  /***/
  8551: (
    /***/
    ((t, e, n) => {
      var a = n(34), i = String, s = TypeError;
      t.exports = function(r) {
        if (a(r)) return r;
        throw new s(i(r) + " is not an object");
      };
    })
  ),
  /***/
  8574: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = Error, s = a("".replace), r = (function(l) {
        return String(new i(l).stack);
      })("zxcasd"), o = /\n\s*at [^:]*:[^\n]*/, c = o.test(r);
      t.exports = function(l, h) {
        if (c && typeof l == "string" && !i.prepareStackTrace)
          for (; h--; ) l = s(l, o, "");
        return l;
      };
    })
  ),
  /***/
  8622: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(4901), s = a.WeakMap;
      t.exports = i(s) && /native code/.test(String(s));
    })
  ),
  /***/
  8646: (
    /***/
    ((t, e, n) => {
      var a = n(9565), i = n(8551), s = n(1767), r = n(851);
      t.exports = function(o, c) {
        (!c || typeof o != "string") && i(o);
        var l = r(o);
        return s(i(l !== void 0 ? a(l, o) : o));
      };
    })
  ),
  /***/
  8686: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(9039);
      t.exports = a && i(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: !1
        }).prototype !== 42;
      });
    })
  ),
  /***/
  8721: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(9504), s = n(2106), r = URLSearchParams.prototype, o = i(r.forEach);
      a && !("size" in r) && s(r, "size", {
        get: function() {
          var l = 0;
          return o(this, function() {
            l++;
          }), l;
        },
        configurable: !0,
        enumerable: !0
      });
    })
  ),
  /***/
  8727: (
    /***/
    ((t) => {
      t.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    })
  ),
  /***/
  8745: (
    /***/
    ((t, e, n) => {
      var a = n(616), i = Function.prototype, s = i.apply, r = i.call;
      t.exports = typeof Reflect == "object" && Reflect.apply || (a ? r.bind(s) : function() {
        return r.apply(s, arguments);
      });
    })
  ),
  /***/
  8750: (
    /***/
    ((t, e, n) => {
      var a = n(7080), i = n(4402), s = n(5170), r = n(3789), o = n(8469), c = n(507), l = i.Set, h = i.add, f = i.has;
      t.exports = function(u) {
        var x = a(this), g = r(u), p = new l();
        return s(x) > g.size ? c(g.getIterator(), function(m) {
          f(x, m) && h(p, m);
        }) : o(x, function(m) {
          g.includes(m) && h(p, m);
        }), p;
      };
    })
  ),
  /***/
  8773: (
    /***/
    ((t, e) => {
      var n = {}.propertyIsEnumerable, a = Object.getOwnPropertyDescriptor, i = a && !n.call({ 1: 2 }, 1);
      e.f = i ? function(r) {
        var o = a(this, r);
        return !!o && o.enumerable;
      } : n;
    })
  ),
  /***/
  8981: (
    /***/
    ((t, e, n) => {
      var a = n(7750), i = Object;
      t.exports = function(s) {
        return i(a(s));
      };
    })
  ),
  /***/
  9039: (
    /***/
    ((t) => {
      t.exports = function(e) {
        try {
          return !!e();
        } catch {
          return !0;
        }
      };
    })
  ),
  /***/
  9143: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(9504), s = n(3972), r = n(3463), o = n(9297), c = n(2804), l = n(944), h = n(5169), f = c.c2i, d = c.c2iUrl, u = a.SyntaxError, x = a.TypeError, g = i("".charAt), p = function(y, w) {
        for (var S = y.length; w < S; w++) {
          var v = g(y, w);
          if (v !== " " && v !== "	" && v !== `
` && v !== "\f" && v !== "\r") break;
        }
        return w;
      }, m = function(y, w, S) {
        var v = y.length;
        v < 4 && (y += v === 2 ? "AA" : "A");
        var k = (w[g(y, 0)] << 18) + (w[g(y, 1)] << 12) + (w[g(y, 2)] << 6) + w[g(y, 3)], A = [
          k >> 16 & 255,
          k >> 8 & 255,
          k & 255
        ];
        if (v === 2) {
          if (S && A[1] !== 0)
            throw new u("Extra bits");
          return [A[0]];
        }
        if (v === 3) {
          if (S && A[2] !== 0)
            throw new u("Extra bits");
          return [A[0], A[1]];
        }
        return A;
      }, b = function(y, w, S) {
        for (var v = w.length, k = 0; k < v; k++)
          y[S + k] = w[k];
        return S + v;
      };
      t.exports = function(y, w, S, v) {
        r(y), s(w);
        var k = l(w) === "base64" ? f : d, A = w ? w.lastChunkHandling : void 0;
        if (A === void 0 && (A = "loose"), A !== "loose" && A !== "strict" && A !== "stop-before-partial")
          throw new x("Incorrect `lastChunkHandling` option");
        S && h(S.buffer);
        var C = y.length, T = S || [], M = 0, O = 0, N = "", H = 0;
        if (v) for (; ; ) {
          if (H = p(y, H), H === C) {
            if (N.length > 0) {
              if (A === "stop-before-partial")
                break;
              if (A === "loose") {
                if (N.length === 1)
                  throw new u("Malformed padding: exactly one additional character");
                M = b(T, m(N, k, !1), M);
              } else
                throw new u("Missing padding");
            }
            O = C;
            break;
          }
          var J = g(y, H);
          if (++H, J === "=") {
            if (N.length < 2)
              throw new u("Padding is too early");
            if (H = p(y, H), N.length === 2) {
              if (H === C) {
                if (A === "stop-before-partial")
                  break;
                throw new u("Malformed padding: only one =");
              }
              g(y, H) === "=" && (++H, H = p(y, H));
            }
            if (H < C)
              throw new u("Unexpected character after padding");
            M = b(T, m(N, k, A === "strict"), M), O = C;
            break;
          }
          if (!o(k, J))
            throw new u("Unexpected character");
          var U = v - M;
          if (U === 1 && N.length === 2 || U === 2 && N.length === 3 || (N += J, N.length === 4 && (M = b(T, m(N, k, !1), M), N = "", O = H, M === v)))
            break;
        }
        return { bytes: T, read: O, written: M };
      };
    })
  ),
  /***/
  9286: (
    /***/
    ((t, e, n) => {
      var a = n(4402), i = n(8469), s = a.Set, r = a.add;
      t.exports = function(o) {
        var c = new s();
        return i(o, function(l) {
          r(c, l);
        }), c;
      };
    })
  ),
  /***/
  9297: (
    /***/
    ((t, e, n) => {
      var a = n(9504), i = n(8981), s = a({}.hasOwnProperty);
      t.exports = Object.hasOwn || function(o, c) {
        return s(i(o), c);
      };
    })
  ),
  /***/
  9306: (
    /***/
    ((t, e, n) => {
      var a = n(4901), i = n(6823), s = TypeError;
      t.exports = function(r) {
        if (a(r)) return r;
        throw new s(i(r) + " is not a function");
      };
    })
  ),
  /***/
  9429: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(6193);
      t.exports = function(s) {
        if (i) {
          try {
            return a.process.getBuiltinModule(s);
          } catch {
          }
          try {
            return Function('return require("' + s + '")')();
          } catch {
          }
        }
      };
    })
  ),
  /***/
  9432: (
    /***/
    ((t, e, n) => {
      n(5213);
    })
  ),
  /***/
  9433: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = Object.defineProperty;
      t.exports = function(s, r) {
        try {
          i(a, s, { value: r, configurable: !0, writable: !0 });
        } catch {
          a[s] = r;
        }
        return r;
      };
    })
  ),
  /***/
  9462: (
    /***/
    ((t, e, n) => {
      var a = n(9565), i = n(2360), s = n(6699), r = n(6279), o = n(8227), c = n(1181), l = n(5966), h = n(7657).IteratorPrototype, f = n(2529), d = n(9539), u = n(1385), x = o("toStringTag"), g = "IteratorHelper", p = "WrapForValidIterator", m = "normal", b = "throw", y = c.set, w = function(k) {
        var A = c.getterFor(k ? p : g);
        return r(i(h), {
          next: function() {
            var T = A(this);
            if (k) return T.nextHandler();
            if (T.done) return f(void 0, !0);
            try {
              var M = T.nextHandler();
              return T.returnHandlerResult ? M : f(M, T.done);
            } catch (O) {
              throw T.done = !0, O;
            }
          },
          return: function() {
            var C = A(this), T = C.iterator;
            if (C.done = !0, k) {
              var M = l(T, "return");
              return M ? a(M, T) : f(void 0, !0);
            }
            if (C.inner) try {
              d(C.inner.iterator, m);
            } catch (O) {
              return d(T, b, O);
            }
            if (C.openIters) try {
              u(C.openIters, m);
            } catch (O) {
              return d(T, b, O);
            }
            return T && d(T, m), f(void 0, !0);
          }
        });
      }, S = w(!0), v = w(!1);
      s(v, x, "Iterator Helper"), t.exports = function(k, A, C) {
        var T = function(O, N) {
          N ? (N.iterator = O.iterator, N.next = O.next) : N = O, N.type = A ? p : g, N.returnHandlerResult = !!C, N.nextHandler = k, N.counter = 0, N.done = !1, y(this, N);
        };
        return T.prototype = A ? S : v, T;
      };
    })
  ),
  /***/
  9479: (
    /***/
    ((t, e, n) => {
      var a = n(3724), i = n(2106), s = n(7594), r = n(7979);
      a && !s.correct && (i(RegExp.prototype, "flags", {
        configurable: !0,
        get: r
      }), s.correct = !0);
    })
  ),
  /***/
  9486: (
    /***/
    ((t, e, n) => {
      var a = n(6518), i = n(4576), s = n(9504), r = n(3972), o = n(4154), c = n(5169), l = n(2804), h = n(944), f = l.i2c, d = l.i2cUrl, u = s("".charAt), x = i.Uint8Array, g = !x || !x.prototype.toBase64 || !(function() {
        try {
          var p = new x();
          p.toBase64(null);
        } catch {
          return !0;
        }
      })();
      x && a({ target: "Uint8Array", proto: !0, forced: g }, {
        toBase64: function() {
          var m = o(this), b = arguments.length ? r(arguments[0]) : void 0, y = h(b) === "base64" ? f : d, w = !!b && !!b.omitPadding;
          c(this.buffer);
          for (var S = "", v = 0, k = m.length, A, C = function(T) {
            return u(y, A >> 6 * T & 63);
          }; v + 2 < k; v += 3)
            A = (m[v] << 16) + (m[v + 1] << 8) + m[v + 2], S += C(3) + C(2) + C(1) + C(0);
          return v + 2 === k ? (A = (m[v] << 16) + (m[v + 1] << 8), S += C(3) + C(2) + C(1) + (w ? "" : "=")) : v + 1 === k && (A = m[v] << 16, S += C(3) + C(2) + (w ? "" : "==")), S;
        }
      });
    })
  ),
  /***/
  9504: (
    /***/
    ((t, e, n) => {
      var a = n(616), i = Function.prototype, s = i.call, r = a && i.bind.bind(s, s);
      t.exports = a ? r : function(o) {
        return function() {
          return s.apply(o, arguments);
        };
      };
    })
  ),
  /***/
  9519: (
    /***/
    ((t, e, n) => {
      var a = n(4576), i = n(2839), s = a.process, r = a.Deno, o = s && s.versions || r && r.version, c = o && o.v8, l, h;
      c && (l = c.split("."), h = l[0] > 0 && l[0] < 4 ? 1 : +(l[0] + l[1])), !h && i && (l = i.match(/Edge\/(\d+)/), (!l || l[1] >= 74) && (l = i.match(/Chrome\/(\d+)/), l && (h = +l[1]))), t.exports = h;
    })
  ),
  /***/
  9539: (
    /***/
    ((t, e, n) => {
      var a = n(9565), i = n(8551), s = n(5966);
      t.exports = function(r, o, c) {
        var l, h;
        i(r);
        try {
          if (l = s(r, "return"), !l) {
            if (o === "throw") throw c;
            return c;
          }
          l = a(l, r);
        } catch (f) {
          h = !0, l = f;
        }
        if (o === "throw") throw c;
        if (h) throw l;
        return i(l), c;
      };
    })
  ),
  /***/
  9565: (
    /***/
    ((t, e, n) => {
      var a = n(616), i = Function.prototype.call;
      t.exports = a ? i.bind(i) : function() {
        return i.apply(i, arguments);
      };
    })
  ),
  /***/
  9577: (
    /***/
    ((t, e, n) => {
      var a = n(9928), i = n(4644), s = n(1108), r = n(1291), o = n(5854), c = i.aTypedArray, l = i.getTypedArrayConstructor, h = i.exportTypedArrayMethod, f = (function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (u) {
          return u === 8;
        }
      })(), d = f && (function() {
        try {
          new Int8Array(1).with(-0.5, 1);
        } catch {
          return !0;
        }
      })();
      h("with", function(u, x) {
        var g = c(this), p = r(u), m = s(g) ? o(x) : +x;
        return a(g, l(g), p, m);
      }, !f || d);
    })
  ),
  /***/
  9617: (
    /***/
    ((t, e, n) => {
      var a = n(5397), i = n(5610), s = n(6198), r = function(o) {
        return function(c, l, h) {
          var f = a(c), d = s(f);
          if (d === 0) return !o && -1;
          var u = i(h, d), x;
          if (o && l !== l) {
            for (; d > u; )
              if (x = f[u++], x !== x) return !0;
          } else for (; d > u; u++)
            if ((o || u in f) && f[u] === l) return o || u || 0;
          return !o && -1;
        };
      };
      t.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: r(!0),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: r(!1)
      };
    })
  ),
  /***/
  9631: (
    /***/
    ((t, e, n) => {
      n(9486);
    })
  ),
  /***/
  9797: (
    /***/
    ((t, e, n) => {
      n(4226);
    })
  ),
  /***/
  9835: (
    /***/
    ((t) => {
      t.exports = function(e) {
        try {
          var n = /* @__PURE__ */ new Set(), a = {
            size: 0,
            has: function() {
              return !0;
            },
            keys: function() {
              return Object.defineProperty({}, "next", {
                get: function() {
                  return n.clear(), n.add(4), function() {
                    return { done: !0 };
                  };
                }
              });
            }
          }, i = n[e](a);
          return i.size === 1 && i.values().next().value === 4;
        } catch {
          return !1;
        }
      };
    })
  ),
  /***/
  9928: (
    /***/
    ((t, e, n) => {
      var a = n(6198), i = n(1291), s = RangeError;
      t.exports = function(r, o, c, l) {
        var h = a(r), f = i(c), d = f < 0 ? h + f : f;
        if (d >= h || d < 0) throw new s("Incorrect index");
        for (var u = new o(h), x = 0; x < h; x++) u[x] = x === d ? l : r[x];
        return u;
      };
    })
  )
  /******/
}, pc = {};
function We(t) {
  var e = pc[t];
  if (e !== void 0)
    return e.exports;
  var n = pc[t] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return Wh[t].call(n.exports, n, n.exports, We), n.exports;
}
We.d = (t, e) => {
  for (var n in e)
    We.o(e, n) && !We.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] });
};
We.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
We(4114);
We(6573);
We(8100);
We(7936);
We(8111);
We(2489);
We(1701);
We(3579);
We(4628);
We(7642);
We(8004);
We(3853);
We(5876);
We(2475);
We(5024);
We(1698);
We(9577);
We(1549);
We(9797);
We(9631);
We(5623);
We(3611);
We(8237);
We(1689);
We(4235);
We(9432);
We(4979);
We(5781);
const Vh = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), ti = [1e-3, 0, 0, 1e-3, 0, 0], ua = 1.35, Pr = 0.35, mc = Pr / ua, tn = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, Ql = "pdfjs_internal_editor_", Xn = {
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15,
  SIGNATURE: 101
}, bc = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, e1 = {
  FILL: 0,
  ADD_TO_PATH_FLAG: 4
}, Nt = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, Mt = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, K0 = {
  GROUP: "Group",
  REPLY: "R"
}, Tt = {
  INVISIBLE: 1,
  HIDDEN: 2,
  PRINT: 4,
  NOROTATE: 16,
  NOVIEW: 32,
  LOCKED: 128,
  LOCKEDCONTENTS: 512
}, Hn = {
  READONLY: 1,
  REQUIRED: 2,
  MULTILINE: 4096,
  PASSWORD: 8192,
  RADIO: 32768,
  PUSHBUTTON: 65536,
  COMBO: 131072,
  FILESELECT: 1048576,
  MULTISELECT: 2097152,
  DONOTSCROLL: 8388608,
  COMB: 16777216
}, gi = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, t1 = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
}, Xh = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
}, qh = {
  O: "PageOpen",
  C: "PageClose"
}, Cs = {
  WARNINGS: 1,
  INFOS: 5
}, I = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93,
  rawFillPath: 94
}, Et = {
  moveTo: 0,
  lineTo: 1,
  curveTo: 2,
  closePath: 3
}, yc = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let n0 = Cs.WARNINGS;
function Kh(t) {
  Number.isInteger(t) && (n0 = t);
}
function Yh() {
  return n0;
}
function Ue(t) {
  n0 >= Cs.INFOS && console.info(`Info: ${t}`);
}
function F(t) {
  n0 >= Cs.WARNINGS && console.warn(`Warning: ${t}`);
}
function _e(t) {
  throw new Error(t);
}
function at(t, e) {
  t || _e(e);
}
function Jh(t) {
  switch (t?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function Nr(t, e = null, n = null) {
  if (!t)
    return null;
  if (n && typeof t == "string" && (n.addDefaultProtocol && t.startsWith("www.") && t.match(/\./g)?.length >= 2 && (t = `http://${t}`), n.tryConvertEncoding))
    try {
      t = Es(t);
    } catch {
    }
  const a = e ? URL.parse(t, e) : URL.parse(t);
  return Jh(a) ? a : null;
}
function ae(t, e, n, a = !1) {
  return Object.defineProperty(t, e, {
    value: n,
    enumerable: !a,
    configurable: !0,
    writable: !1
  }), n;
}
const cn = (function() {
  function e(n, a) {
    this.message = n, this.name = a;
  }
  return e.prototype = new Error(), e.constructor = e, e;
})();
class Is extends cn {
  constructor(e, n) {
    super(e, "PasswordException"), this.code = n;
  }
}
class v0 extends cn {
  constructor(e, n) {
    super(e, "UnknownErrorException"), this.details = n;
  }
}
class Ts extends cn {
  constructor(e) {
    super(e, "InvalidPDFException");
  }
}
class wc extends cn {
  constructor(e, n, a) {
    super(e, "ResponseException"), this.status = n, this.missing = a;
  }
}
class W extends cn {
  constructor(e) {
    super(e, "FormatError");
  }
}
class _t extends cn {
  constructor(e) {
    super(e, "AbortException");
  }
}
function xn(t) {
  (typeof t != "object" || t?.length === void 0) && _e("Invalid argument for bytesToString");
  const e = t.length, n = 8192;
  if (e < n)
    return String.fromCharCode.apply(null, t);
  const a = [];
  for (let i = 0; i < e; i += n) {
    const s = Math.min(i + n, e), r = t.subarray(i, s);
    a.push(String.fromCharCode.apply(null, r));
  }
  return a.join("");
}
function Vt(t) {
  typeof t != "string" && _e("Invalid argument for stringToBytes");
  const e = t.length, n = new Uint8Array(e);
  for (let a = 0; a < e; ++a)
    n[a] = t.charCodeAt(a) & 255;
  return n;
}
function Wt(t) {
  return String.fromCharCode(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255);
}
function Mo(t) {
  return Object.keys(t).length;
}
function Zh() {
  const t = new Uint8Array(4);
  return t[0] = 1, new Uint32Array(t.buffer, 0, 1)[0] === 1;
}
function Qh() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class gn {
  static get isLittleEndian() {
    return ae(this, "isLittleEndian", Zh());
  }
  static get isEvalSupported() {
    return ae(this, "isEvalSupported", Qh());
  }
  static get isOffscreenCanvasSupported() {
    return ae(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get isImageDecoderSupported() {
    return ae(this, "isImageDecoderSupported", typeof ImageDecoder < "u");
  }
  static get platform() {
    const {
      platform: e,
      userAgent: n
    } = navigator;
    return ae(this, "platform", {
      isAndroid: n.includes("Android"),
      isLinux: e.includes("Linux"),
      isMac: e.includes("Mac"),
      isWindows: e.includes("Win"),
      isFirefox: n.includes("Firefox")
    });
  }
  static get isCSSRoundSupported() {
    return ae(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const Fi = Array.from(Array(256).keys(), (t) => t.toString(16).padStart(2, "0"));
class Je {
  static makeHexColor(e, n, a) {
    return `#${Fi[e]}${Fi[n]}${Fi[a]}`;
  }
  static domMatrixToTransform(e) {
    return [e.a, e.b, e.c, e.d, e.e, e.f];
  }
  static scaleMinMax(e, n) {
    let a;
    e[0] ? (e[0] < 0 && (a = n[0], n[0] = n[2], n[2] = a), n[0] *= e[0], n[2] *= e[0], e[3] < 0 && (a = n[1], n[1] = n[3], n[3] = a), n[1] *= e[3], n[3] *= e[3]) : (a = n[0], n[0] = n[1], n[1] = a, a = n[2], n[2] = n[3], n[3] = a, e[1] < 0 && (a = n[1], n[1] = n[3], n[3] = a), n[1] *= e[1], n[3] *= e[1], e[2] < 0 && (a = n[0], n[0] = n[2], n[2] = a), n[0] *= e[2], n[2] *= e[2]), n[0] += e[4], n[1] += e[5], n[2] += e[4], n[3] += e[5];
  }
  static transform(e, n) {
    return [e[0] * n[0] + e[2] * n[1], e[1] * n[0] + e[3] * n[1], e[0] * n[2] + e[2] * n[3], e[1] * n[2] + e[3] * n[3], e[0] * n[4] + e[2] * n[5] + e[4], e[1] * n[4] + e[3] * n[5] + e[5]];
  }
  static multiplyByDOMMatrix(e, n) {
    return [e[0] * n.a + e[2] * n.b, e[1] * n.a + e[3] * n.b, e[0] * n.c + e[2] * n.d, e[1] * n.c + e[3] * n.d, e[0] * n.e + e[2] * n.f + e[4], e[1] * n.e + e[3] * n.f + e[5]];
  }
  static applyTransform(e, n, a = 0) {
    const i = e[a], s = e[a + 1];
    e[a] = i * n[0] + s * n[2] + n[4], e[a + 1] = i * n[1] + s * n[3] + n[5];
  }
  static applyTransformToBezier(e, n, a = 0) {
    const i = n[0], s = n[1], r = n[2], o = n[3], c = n[4], l = n[5];
    for (let h = 0; h < 6; h += 2) {
      const f = e[a + h], d = e[a + h + 1];
      e[a + h] = f * i + d * r + c, e[a + h + 1] = f * s + d * o + l;
    }
  }
  static applyInverseTransform(e, n) {
    const a = e[0], i = e[1], s = n[0] * n[3] - n[1] * n[2];
    e[0] = (a * n[3] - i * n[2] + n[2] * n[5] - n[4] * n[3]) / s, e[1] = (-a * n[1] + i * n[0] + n[4] * n[1] - n[5] * n[0]) / s;
  }
  static axialAlignedBoundingBox(e, n, a) {
    const i = n[0], s = n[1], r = n[2], o = n[3], c = n[4], l = n[5], h = e[0], f = e[1], d = e[2], u = e[3];
    let x = i * h + c, g = x, p = i * d + c, m = p, b = o * f + l, y = b, w = o * u + l, S = w;
    if (s !== 0 || r !== 0) {
      const v = s * h, k = s * d, A = r * f, C = r * u;
      x += A, m += A, p += C, g += C, b += v, S += v, w += k, y += k;
    }
    a[0] = Math.min(a[0], x, p, g, m), a[1] = Math.min(a[1], b, w, y, S), a[2] = Math.max(a[2], x, p, g, m), a[3] = Math.max(a[3], b, w, y, S);
  }
  static inverseTransform(e) {
    const n = e[0] * e[3] - e[1] * e[2];
    return [e[3] / n, -e[1] / n, -e[2] / n, e[0] / n, (e[2] * e[5] - e[4] * e[3]) / n, (e[4] * e[1] - e[5] * e[0]) / n];
  }
  static singularValueDecompose2dScale(e, n) {
    const a = e[0], i = e[1], s = e[2], r = e[3], o = a ** 2 + i ** 2, c = a * s + i * r, l = s ** 2 + r ** 2, h = (o + l) / 2, f = Math.sqrt(h ** 2 - (o * l - c ** 2));
    n[0] = Math.sqrt(h + f || 1), n[1] = Math.sqrt(h - f || 1);
  }
  static normalizeRect(e) {
    const n = e.slice(0);
    return e[0] > e[2] && (n[0] = e[2], n[2] = e[0]), e[1] > e[3] && (n[1] = e[3], n[3] = e[1]), n;
  }
  static intersect(e, n) {
    const a = Math.max(Math.min(e[0], e[2]), Math.min(n[0], n[2])), i = Math.min(Math.max(e[0], e[2]), Math.max(n[0], n[2]));
    if (a > i)
      return null;
    const s = Math.max(Math.min(e[1], e[3]), Math.min(n[1], n[3])), r = Math.min(Math.max(e[1], e[3]), Math.max(n[1], n[3]));
    return s > r ? null : [a, s, i, r];
  }
  static pointBoundingBox(e, n, a) {
    a[0] = Math.min(a[0], e), a[1] = Math.min(a[1], n), a[2] = Math.max(a[2], e), a[3] = Math.max(a[3], n);
  }
  static rectBoundingBox(e, n, a, i, s) {
    s[0] = Math.min(s[0], e, a), s[1] = Math.min(s[1], n, i), s[2] = Math.max(s[2], e, a), s[3] = Math.max(s[3], n, i);
  }
  static #e(e, n, a, i, s, r, o, c, l, h) {
    if (l <= 0 || l >= 1)
      return;
    const f = 1 - l, d = l * l, u = d * l, x = f * (f * (f * e + 3 * l * n) + 3 * d * a) + u * i, g = f * (f * (f * s + 3 * l * r) + 3 * d * o) + u * c;
    h[0] = Math.min(h[0], x), h[1] = Math.min(h[1], g), h[2] = Math.max(h[2], x), h[3] = Math.max(h[3], g);
  }
  static #t(e, n, a, i, s, r, o, c, l, h, f, d) {
    if (Math.abs(l) < 1e-12) {
      Math.abs(h) >= 1e-12 && this.#e(e, n, a, i, s, r, o, c, -f / h, d);
      return;
    }
    const u = h ** 2 - 4 * f * l;
    if (u < 0)
      return;
    const x = Math.sqrt(u), g = 2 * l;
    this.#e(e, n, a, i, s, r, o, c, (-h + x) / g, d), this.#e(e, n, a, i, s, r, o, c, (-h - x) / g, d);
  }
  static bezierBoundingBox(e, n, a, i, s, r, o, c, l) {
    l[0] = Math.min(l[0], e, o), l[1] = Math.min(l[1], n, c), l[2] = Math.max(l[2], e, o), l[3] = Math.max(l[3], n, c), this.#t(e, a, s, o, n, i, r, c, 3 * (-e + 3 * (a - s) + o), 6 * (e - 2 * a + s), 3 * (a - e), l), this.#t(e, a, s, o, n, i, r, c, 3 * (-n + 3 * (i - r) + c), 6 * (n - 2 * i + r), 3 * (i - n), l);
  }
}
const ef = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function Ve(t, e = !1) {
  if (t[0] >= "") {
    let a;
    if (t[0] === "" && t[1] === "" ? (a = "utf-16be", t.length % 2 === 1 && (t = t.slice(0, -1))) : t[0] === "" && t[1] === "" ? (a = "utf-16le", t.length % 2 === 1 && (t = t.slice(0, -1))) : t[0] === "" && t[1] === "" && t[2] === "" && (a = "utf-8"), a)
      try {
        const i = new TextDecoder(a, {
          fatal: !0
        }), s = Vt(t), r = i.decode(s);
        return e || !r.includes("\x1B") ? r : r.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
      } catch (i) {
        F(`stringToPDFString: "${i}".`);
      }
  }
  const n = [];
  for (let a = 0, i = t.length; a < i; a++) {
    const s = t.charCodeAt(a);
    if (!e && s === 27) {
      for (; ++a < i && t.charCodeAt(a) !== 27; )
        ;
      continue;
    }
    const r = ef[s];
    n.push(r ? String.fromCharCode(r) : t.charAt(a));
  }
  return n.join("");
}
function Es(t) {
  return decodeURIComponent(escape(t));
}
function Y0(t) {
  return unescape(encodeURIComponent(t));
}
function Fs(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0, a = t.length; n < a; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function ci(t = /* @__PURE__ */ new Date()) {
  return t instanceof Date || (t = new Date(t)), [t.getUTCFullYear().toString(), (t.getUTCMonth() + 1).toString().padStart(2, "0"), t.getUTCDate().toString().padStart(2, "0"), t.getUTCHours().toString().padStart(2, "0"), t.getUTCMinutes().toString().padStart(2, "0"), t.getUTCSeconds().toString().padStart(2, "0")].join("");
}
let S0 = null, vc = null;
function tf(t) {
  return S0 || (S0 = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, vc = /* @__PURE__ */ new Map([["", "t"]])), t.replaceAll(S0, (e, n, a) => n ? n.normalize("NFKC") : vc.get(a));
}
const nf = "pdfjs_internal_id_";
function af(t, e, n) {
  if (!Array.isArray(n) || n.length < 2)
    return !1;
  const [a, i, ...s] = n;
  if (!t(a) && !Number.isInteger(a) || !e(i))
    return !1;
  const r = s.length;
  let o = !0;
  switch (i.name) {
    case "XYZ":
      if (r < 2 || r > 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return r === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (r > 1)
        return !1;
      break;
    case "FitR":
      if (r !== 4)
        return !1;
      o = !1;
      break;
    default:
      return !1;
  }
  for (const c of s)
    if (!(typeof c == "number" || o && c === null))
      return !1;
  return !0;
}
function Lt(t, e, n) {
  return Math.min(Math.max(t, e), n);
}
function Sc(t) {
  return Uint8Array.prototype.toHex ? t.toHex() : Array.from(t, (e) => Fi[e]).join("");
}
function sf(t) {
  return Uint8Array.fromBase64 ? Uint8Array.fromBase64(t) : Vt(atob(t));
}
typeof Math.sumPrecise != "function" && (Math.sumPrecise = function(t) {
  return t.reduce((e, n) => e + n, 0);
});
typeof AbortSignal.any != "function" && (AbortSignal.any = function(t) {
  const e = new AbortController(), {
    signal: n
  } = e;
  for (const a of t)
    if (a.aborted)
      return e.abort(a.reason), n;
  for (const a of t)
    a.addEventListener("abort", () => {
      e.abort(a.reason);
    }, {
      signal: n
    });
  return n;
});
We(1148);
const rf = Symbol("CIRCULAR_REF"), Dt = Symbol("EOF");
let n1 = /* @__PURE__ */ Object.create(null), a1 = /* @__PURE__ */ Object.create(null), Tr = /* @__PURE__ */ Object.create(null);
function of() {
  n1 = /* @__PURE__ */ Object.create(null), a1 = /* @__PURE__ */ Object.create(null), Tr = /* @__PURE__ */ Object.create(null);
}
class Z {
  constructor(e) {
    this.name = e;
  }
  static get(e) {
    return a1[e] ||= new Z(e);
  }
}
class Ct {
  constructor(e) {
    this.cmd = e;
  }
  static get(e) {
    return n1[e] ||= new Ct(e);
  }
}
const i1 = function() {
  return i1;
};
class B {
  constructor(e = null) {
    this._map = /* @__PURE__ */ new Map(), this.xref = e, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = i1;
  }
  assignXref(e) {
    this.xref = e;
  }
  get size() {
    return this._map.size;
  }
  get(e, n, a) {
    let i = this._map.get(e);
    return i === void 0 && n !== void 0 && (i = this._map.get(n), i === void 0 && a !== void 0 && (i = this._map.get(a))), i instanceof le && this.xref ? this.xref.fetch(i, this.suppressEncryption) : i;
  }
  async getAsync(e, n, a) {
    let i = this._map.get(e);
    return i === void 0 && n !== void 0 && (i = this._map.get(n), i === void 0 && a !== void 0 && (i = this._map.get(a))), i instanceof le && this.xref ? this.xref.fetchAsync(i, this.suppressEncryption) : i;
  }
  getArray(e, n, a) {
    let i = this._map.get(e);
    if (i === void 0 && n !== void 0 && (i = this._map.get(n), i === void 0 && a !== void 0 && (i = this._map.get(a))), i instanceof le && this.xref && (i = this.xref.fetch(i, this.suppressEncryption)), Array.isArray(i)) {
      i = i.slice();
      for (let s = 0, r = i.length; s < r; s++)
        i[s] instanceof le && this.xref && (i[s] = this.xref.fetch(i[s], this.suppressEncryption));
    }
    return i;
  }
  getRaw(e) {
    return this._map.get(e);
  }
  getKeys() {
    return [...this._map.keys()];
  }
  getRawValues() {
    return [...this._map.values()];
  }
  set(e, n) {
    this._map.set(e, n);
  }
  setIfNotExists(e, n) {
    this.has(e) || this.set(e, n);
  }
  setIfNumber(e, n) {
    typeof n == "number" && this.set(e, n);
  }
  setIfArray(e, n) {
    (Array.isArray(n) || ArrayBuffer.isView(n)) && this.set(e, n);
  }
  setIfDefined(e, n) {
    n != null && this.set(e, n);
  }
  setIfName(e, n) {
    typeof n == "string" ? this.set(e, Z.get(n)) : n instanceof Z && this.set(e, n);
  }
  has(e) {
    return this._map.has(e);
  }
  *[Symbol.iterator]() {
    for (const [e, n] of this._map)
      yield [e, n instanceof le && this.xref ? this.xref.fetch(n, this.suppressEncryption) : n];
  }
  static get empty() {
    const e = new B(null);
    return e.set = (n, a) => {
      _e("Should not call `set` on the empty dictionary.");
    }, ae(this, "empty", e);
  }
  static merge({
    xref: e,
    dictArray: n,
    mergeSubDicts: a = !1
  }) {
    const i = new B(e), s = /* @__PURE__ */ new Map();
    for (const r of n)
      if (r instanceof B)
        for (const [o, c] of r._map) {
          let l = s.get(o);
          if (l === void 0)
            l = [], s.set(o, l);
          else if (!a || !(c instanceof B))
            continue;
          l.push(c);
        }
    for (const [r, o] of s) {
      if (o.length === 1 || !(o[0] instanceof B)) {
        i._map.set(r, o[0]);
        continue;
      }
      const c = new B(e);
      for (const l of o)
        for (const [h, f] of l._map)
          c._map.has(h) || c._map.set(h, f);
      c.size > 0 && i._map.set(r, c);
    }
    return s.clear(), i.size > 0 ? i : B.empty;
  }
  clone() {
    const e = new B(this.xref);
    for (const n of this.getKeys())
      e.set(n, this.getRaw(n));
    return e;
  }
  delete(e) {
    this._map.delete(e);
  }
}
class le {
  constructor(e, n) {
    this.num = e, this.gen = n;
  }
  toString() {
    return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(e) {
    const n = Tr[e];
    if (n)
      return n;
    const a = /^(\d+)R(\d*)$/.exec(e);
    return !a || a[1] === "0" ? null : Tr[e] = new le(parseInt(a[1]), a[2] ? parseInt(a[2]) : 0);
  }
  static get(e, n) {
    const a = n === 0 ? `${e}R` : `${e}R${n}`;
    return Tr[a] ||= new le(e, n);
  }
}
class St {
  constructor(e = null) {
    this._set = new Set(e?._set);
  }
  has(e) {
    return this._set.has(e.toString());
  }
  put(e) {
    this._set.add(e.toString());
  }
  remove(e) {
    this._set.delete(e.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
}
class un {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(e) {
    return this._map.get(e.toString());
  }
  has(e) {
    return this._map.has(e.toString());
  }
  put(e, n) {
    this._map.set(e.toString(), n);
  }
  putAlias(e, n) {
    this._map.set(e.toString(), this.get(n));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *values() {
    yield* this._map.values();
  }
  *items() {
    for (const [e, n] of this._map)
      yield [le.fromString(e), n];
  }
}
function dt(t, e) {
  return t instanceof Z && (e === void 0 || t.name === e);
}
function Bt(t, e) {
  return t instanceof Ct && (e === void 0 || t.cmd === e);
}
function s1(t, e) {
  return t instanceof B && (e === void 0 || dt(t.get("Type"), e));
}
function Dr(t, e) {
  return t.num === e.num && t.gen === e.gen;
}
class Ne {
  get length() {
    _e("Abstract getter `length` accessed");
  }
  get isEmpty() {
    _e("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return ae(this, "isDataLoaded", !0);
  }
  getByte() {
    _e("Abstract method `getByte` called");
  }
  getBytes(e) {
    _e("Abstract method `getBytes` called");
  }
  async getImageData(e, n) {
    return this.getBytes(e, n);
  }
  async asyncGetBytes() {
    _e("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return !1;
  }
  get isAsyncDecoder() {
    return !1;
  }
  get canAsyncDecodeImageFromBuffer() {
    return !1;
  }
  async getTransferableImage() {
    return null;
  }
  peekByte() {
    const e = this.getByte();
    return e !== -1 && this.pos--, e;
  }
  peekBytes(e) {
    const n = this.getBytes(e);
    return this.pos -= n.length, n;
  }
  getUint16() {
    const e = this.getByte(), n = this.getByte();
    return e === -1 || n === -1 ? -1 : (e << 8) + n;
  }
  getInt32() {
    const e = this.getByte(), n = this.getByte(), a = this.getByte(), i = this.getByte();
    return (e << 24) + (n << 16) + (a << 8) + i;
  }
  getByteRange(e, n) {
    _e("Abstract method `getByteRange` called");
  }
  getString(e) {
    return xn(this.getBytes(e));
  }
  skip(e) {
    this.pos += e || 1;
  }
  reset() {
    _e("Abstract method `reset` called");
  }
  moveStart() {
    _e("Abstract method `moveStart` called");
  }
  makeSubStream(e, n, a = null) {
    _e("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
}
const r1 = /^[1-9]\.\d$/, J0 = 2 ** 31 - 1, cf = -2147483648, $n = [1, 0, 0, 1, 0, 0], Z0 = ["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"], Q0 = ["ExtGState", "Font", "Properties", "XObject"];
function ut(t) {
  let e;
  return function() {
    return t && (e = /* @__PURE__ */ Object.create(null), t(e), t = null), e;
  };
}
class ht extends cn {
  constructor(e, n) {
    super(`Missing data [${e}, ${n})`, "MissingDataException"), this.begin = e, this.end = n;
  }
}
class eo extends cn {
  constructor(e) {
    super(e, "ParserEOFException");
  }
}
class Ea extends cn {
  constructor(e) {
    super(e, "XRefEntryException");
  }
}
class Ri extends cn {
  constructor(e) {
    super(e, "XRefParseException");
  }
}
function o1(t) {
  const e = t.length;
  if (e === 0)
    return new Uint8Array(0);
  if (e === 1)
    return new Uint8Array(t[0]);
  let n = 0;
  for (let s = 0; s < e; s++)
    n += t[s].byteLength;
  const a = new Uint8Array(n);
  let i = 0;
  for (let s = 0; s < e; s++) {
    const r = new Uint8Array(t[s]);
    a.set(r, i), i += r.byteLength;
  }
  return a;
}
async function to(t) {
  const e = await fetch(t);
  if (!e.ok)
    throw new Error(`Failed to fetch file "${t}" with "${e.statusText}".`);
  return new Uint8Array(await e.arrayBuffer());
}
function Bn({
  dict: t,
  key: e,
  getArray: n = !1,
  stopWhenFound: a = !0
}) {
  let i;
  const s = new St();
  for (; t instanceof B && !(t.objId && s.has(t.objId)); ) {
    t.objId && s.put(t.objId);
    const r = n ? t.getArray(e) : t.get(e);
    if (r !== void 0) {
      if (a)
        return r;
      (i ||= []).push(r);
    }
    t = t.get("Parent");
  }
  return i;
}
function lf(t, e, n) {
  const a = new St(), i = t, s = {
    dict: null,
    ref: null
  };
  for (; t instanceof B && !a.has(e) && (a.put(e), !t.has("T")); ) {
    if (e = t.getRaw("Parent"), !(e instanceof le))
      return s;
    t = n.fetch(e);
  }
  return t instanceof B && t !== i && (s.dict = t, s.ref = e), s;
}
const k0 = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function hf(t, e = !1) {
  at(Number.isInteger(t) && t > 0, "The number should be a positive integer.");
  const n = "M".repeat(t / 1e3 | 0) + k0[t % 1e3 / 100 | 0] + k0[10 + (t % 100 / 10 | 0)] + k0[20 + t % 10];
  return e ? n.toLowerCase() : n;
}
function Po(t) {
  return t > 0 ? Math.ceil(Math.log2(t)) : 0;
}
function Kn(t, e) {
  return t[e] << 24 >> 24;
}
function ha(t, e) {
  return (t[e] << 24 | t[e + 1] << 16) >> 16;
}
function Ge(t, e) {
  return t[e] << 8 | t[e + 1];
}
function nt(t, e) {
  return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
function An(t) {
  return t === 32 || t === 9 || t === 13 || t === 10;
}
function ff(t, e) {
  return Array.isArray(t) && t.length === e && t.every((n) => typeof n == "boolean");
}
function an(t, e) {
  return Array.isArray(t) ? (e === null || t.length === e) && t.every((n) => typeof n == "number") : ArrayBuffer.isView(t) && !(t instanceof BigInt64Array || t instanceof BigUint64Array) && (e === null || t.length === e);
}
function Fa(t, e) {
  return an(t, 6) ? t : e;
}
function no(t, e) {
  return an(t, 4) ? t : e;
}
function ma(t, e) {
  return an(t, 4) ? Je.normalizeRect(t) : e;
}
function c1(t) {
  const e = /(.+)\[(\d+)\]$/;
  return t.split(".").map((n) => {
    const a = n.match(e);
    return a ? {
      name: a[1],
      pos: parseInt(a[2], 10)
    } : {
      name: n,
      pos: 0
    };
  });
}
function No(t) {
  const e = [];
  let n = 0;
  for (let a = 0, i = t.length; a < i; a++) {
    const s = t.charCodeAt(a);
    (s < 33 || s > 126 || s === 35 || s === 40 || s === 41 || s === 60 || s === 62 || s === 91 || s === 93 || s === 123 || s === 125 || s === 47 || s === 37) && (n < a && e.push(t.substring(n, a)), e.push(`#${s.toString(16)}`), n = a + 1);
  }
  return e.length === 0 ? t : (n < t.length && e.push(t.substring(n, t.length)), e.join(""));
}
function Di(t) {
  return t.replaceAll(/([()\\\n\r])/g, (e) => e === `
` ? "\\n" : e === "\r" ? "\\r" : `\\${e}`);
}
function Lr(t, e, n, a) {
  if (!t)
    return;
  let i = null;
  if (t instanceof le) {
    if (a.has(t))
      return;
    i = t, a.put(i), t = e.fetch(t);
  }
  if (Array.isArray(t))
    for (const s of t)
      Lr(s, e, n, a);
  else if (t instanceof B) {
    if (dt(t.get("S"), "JavaScript")) {
      const s = t.get("JS");
      let r;
      s instanceof Ne ? r = s.getString() : typeof s == "string" && (r = s), r &&= Ve(r, !0).replaceAll("\0", ""), r && n.push(r.trim());
    }
    Lr(t.getRaw("Next"), e, n, a);
  }
  i && a.remove(i);
}
function a0(t, e, n) {
  const a = /* @__PURE__ */ Object.create(null), i = Bn({
    dict: e,
    key: "AA",
    stopWhenFound: !1
  });
  if (i)
    for (let s = i.length - 1; s >= 0; s--) {
      const r = i[s];
      if (r instanceof B)
        for (const o of r.getKeys()) {
          const c = n[o];
          if (!c)
            continue;
          const l = r.getRaw(o), h = new St(), f = [];
          Lr(l, t, f, h), f.length > 0 && (a[c] = f);
        }
    }
  if (e.has("A")) {
    const s = e.get("A"), r = new St(), o = [];
    Lr(s, t, o, r), o.length > 0 && (a.Action = o);
  }
  return Mo(a) > 0 ? a : null;
}
const uf = {
  60: "&lt;",
  62: "&gt;",
  38: "&amp;",
  34: "&quot;",
  39: "&apos;"
};
function* df(t) {
  for (let e = 0, n = t.length; e < n; e++) {
    const a = t.codePointAt(e);
    a > 55295 && (a < 57344 || a > 65533) && e++, yield a;
  }
}
function Oi(t) {
  const e = [];
  let n = 0;
  for (let a = 0, i = t.length; a < i; a++) {
    const s = t.codePointAt(a);
    if (32 <= s && s <= 126) {
      const r = uf[s];
      r && (n < a && e.push(t.substring(n, a)), e.push(r), n = a + 1);
    } else
      n < a && e.push(t.substring(n, a)), e.push(`&#x${s.toString(16).toUpperCase()};`), s > 55295 && (s < 57344 || s > 65533) && a++, n = a + 1;
  }
  return e.length === 0 ? t : (n < t.length && e.push(t.substring(n, t.length)), e.join(""));
}
function ao(t, e = !1) {
  const n = /^("|').*("|')$/.exec(t);
  if (n && n[1] === n[2]) {
    if (new RegExp(`[^\\\\]${n[1]}`).test(t.slice(1, -1)))
      return e && F(`FontFamily contains unescaped ${n[1]}: ${t}.`), !1;
  } else
    for (const a of t.split(/[ \t]+/))
      if (/^(\d|(-(\d|-)))/.test(a) || !/^[\w-\\]+$/.test(a))
        return e && F(`FontFamily contains invalid <custom-ident>: ${t}.`), !1;
  return !0;
}
function xf(t) {
  const a = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
    fontFamily: i,
    fontWeight: s,
    italicAngle: r
  } = t;
  if (!ao(i, !0))
    return !1;
  const o = s ? s.toString() : "";
  t.fontWeight = a.has(o) ? o : "400";
  const c = parseFloat(r);
  return t.italicAngle = isNaN(c) || c < -90 || c > 90 ? "14" : r.toString(), !0;
}
function l1(t) {
  const e = ["app.launchURL", "window.open", "xfa.host.gotoURL"], a = new RegExp("^\\s*(" + e.join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(t);
  return a?.[2] ? {
    url: a[2],
    newWindow: a[1] === "app.launchURL" && a[3] === "true"
  } : null;
}
function ze(t) {
  if (Number.isInteger(t))
    return t.toString();
  const e = Math.round(t * 100);
  return e % 100 === 0 ? (e / 100).toString() : e % 10 === 0 ? t.toFixed(1) : t.toFixed(2);
}
function h1(t) {
  if (!t)
    return null;
  const e = /* @__PURE__ */ new Map();
  for (const [n, a] of t) {
    if (!n.startsWith(Ql))
      continue;
    let i = e.get(a.pageIndex);
    i || (i = [], e.set(a.pageIndex, i)), i.push(a);
  }
  return e.size > 0 ? e : null;
}
function kn(t) {
  return t == null || gf(t) ? t : f1(t, !0);
}
function gf(t) {
  return typeof t != "string" ? !1 : !t || /^[\x00-\x7F]*$/.test(t);
}
function pf(t) {
  const e = [];
  for (let n = 0, a = t.length; n < a; n++) {
    const i = t.charCodeAt(n);
    e.push(Fi[i >> 8 & 255], Fi[i & 255]);
  }
  return e.join("");
}
function f1(t, e = !1) {
  const n = [];
  e && n.push("");
  for (let a = 0, i = t.length; a < i; a++) {
    const s = t.charCodeAt(a);
    n.push(String.fromCharCode(s >> 8 & 255), String.fromCharCode(s & 255));
  }
  return n.join("");
}
function Ur(t, e, n) {
  switch (t) {
    case 90:
      return [0, 1, -1, 0, e, 0];
    case 180:
      return [-1, 0, 0, -1, e, n];
    case 270:
      return [0, -1, 1, 0, 0, n];
    default:
      throw new Error("Invalid rotation");
  }
}
function kc(t) {
  return Math.ceil(Math.ceil(Math.log2(1 + t)) / 8);
}
We(4603);
We(7566);
We(8721);
class Pt {
  static #e = null;
  static _memory = null;
  static _mustAddAlpha = !1;
  static _destBuffer = null;
  static _destOffset = 0;
  static _destLength = 0;
  static _cssColor = "";
  static _makeHexColor = null;
  static get _memoryArray() {
    const e = this.#e;
    return e?.byteLength ? e : this.#e = new Uint8Array(this._memory.buffer);
  }
}
function mf(t, e) {
  const {
    _mustAddAlpha: n,
    _destBuffer: a,
    _destOffset: i,
    _destLength: s,
    _memoryArray: r
  } = Pt;
  if (e === s) {
    a.set(r.subarray(t, t + e), i);
    return;
  }
  if (n)
    for (let o = t, c = t + e, l = i; o < c; o += 3, l += 4)
      a[l] = r[o], a[l + 1] = r[o + 1], a[l + 2] = r[o + 2], a[l + 3] = 255;
  else
    for (let o = t, c = t + e, l = i; o < c; o += 3, l += 4)
      a[l] = r[o], a[l + 1] = r[o + 1], a[l + 2] = r[o + 2];
}
function bf(t) {
  const {
    _destBuffer: e,
    _destOffset: n,
    _memoryArray: a
  } = Pt;
  e[n] = a[t], e[n + 1] = a[t + 1], e[n + 2] = a[t + 2];
}
function yf(t) {
  const {
    _memoryArray: e
  } = Pt;
  Pt._cssColor = Pt._makeHexColor(e[t], e[t + 1], e[t + 2]);
}
let sn;
const u1 = typeof TextDecoder < "u" ? new TextDecoder("utf-8", {
  ignoreBOM: !0,
  fatal: !0
}) : {
  decode: () => {
    throw Error("TextDecoder not available");
  }
};
typeof TextDecoder < "u" && u1.decode();
let us = null;
function d1() {
  return (us === null || us.byteLength === 0) && (us = new Uint8Array(sn.memory.buffer)), us;
}
function wf(t, e) {
  return t = t >>> 0, u1.decode(d1().subarray(t, t + e));
}
let Do = 0;
function x1(t, e) {
  const n = e(t.length * 1, 1) >>> 0;
  return d1().set(t, n / 1), Do = t.length, n;
}
function vf(t, e) {
  const n = x1(e, sn.__wbindgen_malloc), a = Do;
  sn.qcms_convert_array(t, n, a);
}
function Sf(t, e, n) {
  sn.qcms_convert_one(t, e, n);
}
function kf(t, e, n, a, i) {
  sn.qcms_convert_three(t, e, n, a, i);
}
function Af(t, e, n, a, i, s) {
  sn.qcms_convert_four(t, e, n, a, i, s);
}
function Cf(t, e, n) {
  const a = x1(t, sn.__wbindgen_malloc), i = Do;
  return sn.qcms_transformer_from_memory(a, i, e, n) >>> 0;
}
function If(t) {
  sn.qcms_drop_transformer(t);
}
const A0 = Object.freeze({
  RGB8: 0,
  0: "RGB8",
  RGBA8: 1,
  1: "RGBA8",
  BGRA8: 2,
  2: "BGRA8",
  Gray8: 3,
  3: "Gray8",
  GrayA8: 4,
  4: "GrayA8",
  CMYK: 5,
  5: "CMYK"
}), Tf = Object.freeze({
  Perceptual: 0,
  0: "Perceptual",
  RelativeColorimetric: 1,
  1: "RelativeColorimetric",
  Saturation: 2,
  2: "Saturation",
  AbsoluteColorimetric: 3,
  3: "AbsoluteColorimetric"
});
function Ef() {
  const t = {};
  return t.wbg = {}, t.wbg.__wbg_copyresult_b08ee7d273f295dd = function(e, n) {
    mf(e >>> 0, n >>> 0);
  }, t.wbg.__wbg_copyrgb_d60ce17bb05d9b67 = function(e) {
    bf(e >>> 0);
  }, t.wbg.__wbg_makecssRGB_893bf0cd9fdb302d = function(e) {
    yf(e >>> 0);
  }, t.wbg.__wbindgen_init_externref_table = function() {
    const e = sn.__wbindgen_export_0, n = e.grow(4);
    e.set(0, void 0), e.set(n + 0, void 0), e.set(n + 1, null), e.set(n + 2, !0), e.set(n + 3, !1);
  }, t.wbg.__wbindgen_throw = function(e, n) {
    throw new Error(wf(e, n));
  }, t;
}
function Ff(t, e) {
  return sn = t.exports, us = null, sn.__wbindgen_start(), sn;
}
function Rf(t) {
  if (sn !== void 0) return sn;
  typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? {
    module: t
  } = t : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
  const e = Ef();
  t instanceof WebAssembly.Module || (t = new WebAssembly.Module(t));
  const n = new WebAssembly.Instance(t, e);
  return Ff(n);
}
function Of(t, e, n, a, i, s, r) {
  r = r !== 1 ? 0 : r;
  const c = n / i, l = a / s;
  let h = 0, f;
  const d = new Uint16Array(i), u = n * 3;
  for (let x = 0; x < i; x++)
    d[x] = Math.floor(x * c) * 3;
  for (let x = 0; x < s; x++) {
    const g = Math.floor(x * l) * u;
    for (let p = 0; p < i; p++)
      f = g + d[p], e[h++] = t[f++], e[h++] = t[f++], e[h++] = t[f++], h += r;
  }
}
function Bf(t, e, n, a, i, s, r) {
  const o = n / i, c = a / s;
  let l = 0;
  const h = new Uint16Array(i);
  if (r === 1) {
    for (let x = 0; x < i; x++)
      h[x] = Math.floor(x * o);
    const f = new Uint32Array(t.buffer), d = new Uint32Array(e.buffer), u = gn.isLittleEndian ? 16777215 : 4294967040;
    for (let x = 0; x < s; x++) {
      const g = f.subarray(Math.floor(x * c) * n);
      for (let p = 0; p < i; p++)
        d[l++] |= g[h[p]] & u;
    }
  } else {
    const d = n * 4;
    for (let u = 0; u < i; u++)
      h[u] = Math.floor(u * o) * 4;
    for (let u = 0; u < s; u++) {
      const x = t.subarray(Math.floor(u * c) * d);
      for (let g = 0; g < i; g++) {
        const p = h[g];
        e[l++] = x[p], e[l++] = x[p + 1], e[l++] = x[p + 2];
      }
    }
  }
}
function Mf(t, e, n) {
  if (n === 1) {
    const a = new Uint32Array(t.buffer), i = new Uint32Array(e.buffer), s = gn.isLittleEndian ? 16777215 : 4294967040;
    for (let r = 0, o = a.length; r < o; r++)
      i[r] |= a[r] & s;
  } else {
    let a = 0;
    for (let i = 0, s = t.length; i < s; i += 4)
      e[a++] = t[i], e[a++] = t[i + 1], e[a++] = t[i + 2];
  }
}
class jt {
  static #e = new Uint8ClampedArray(3);
  constructor(e, n) {
    this.name = e, this.numComps = n;
  }
  getRgb(e, n, a = new Uint8ClampedArray(3)) {
    return this.getRgbItem(e, n, a, 0), a;
  }
  getRgbHex(e, n) {
    const a = this.getRgb(e, n, jt.#e);
    return Je.makeHexColor(a[0], a[1], a[2]);
  }
  getRgbItem(e, n, a, i) {
    _e("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    _e("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(e, n) {
    _e("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(e) {
    return !1;
  }
  isDefaultDecode(e, n) {
    return jt.isDefaultDecode(e, this.numComps);
  }
  fillRgb(e, n, a, i, s, r, o, c, l) {
    const h = n * a;
    let f = null;
    const d = 1 << o, u = a !== s || n !== i;
    if (this.isPassthrough(o))
      f = c;
    else if (this.numComps === 1 && h > d && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const x = o <= 8 ? new Uint8Array(d) : new Uint16Array(d);
      for (let p = 0; p < d; p++)
        x[p] = p;
      const g = new Uint8ClampedArray(d * 3);
      if (this.getRgbBuffer(x, 0, d, g, 0, o, 0), u) {
        f = new Uint8Array(h * 3);
        let p = 0;
        for (let m = 0; m < h; ++m) {
          const b = c[m] * 3;
          f[p++] = g[b], f[p++] = g[b + 1], f[p++] = g[b + 2];
        }
      } else {
        let p = 0;
        for (let m = 0; m < h; ++m) {
          const b = c[m] * 3;
          e[p++] = g[b], e[p++] = g[b + 1], e[p++] = g[b + 2], p += l;
        }
      }
    } else u ? (f = new Uint8ClampedArray(h * 3), this.getRgbBuffer(c, 0, h, f, 0, o, 0)) : this.getRgbBuffer(c, 0, i * r, e, 0, o, l);
    if (f)
      if (u)
        Of(f, e, n, a, i, s, l);
      else {
        let x = 0, g = 0;
        for (let p = 0, m = i * r; p < m; p++)
          e[x++] = f[g++], e[x++] = f[g++], e[x++] = f[g++], x += l;
      }
  }
  get usesZeroToOneRange() {
    return ae(this, "usesZeroToOneRange", !0);
  }
  static isDefaultDecode(e, n) {
    if (!Array.isArray(e))
      return !0;
    if (n * 2 !== e.length)
      return F("The decode map is not the correct length"), !0;
    for (let a = 0, i = e.length; a < i; a += 2)
      if (e[a] !== 0 || e[a + 1] !== 1)
        return !1;
    return !0;
  }
}
class Pf extends jt {
  constructor(e, n, a) {
    super("Alternate", e), this.base = n, this.tintFn = a, this.tmpBuf = new Float32Array(n.numComps);
  }
  getRgbItem(e, n, a, i) {
    const s = this.tmpBuf;
    this.tintFn(e, n, s, 0), this.base.getRgbItem(s, 0, a, i);
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const c = this.tintFn, l = this.base, h = 1 / ((1 << r) - 1), f = l.numComps, d = l.usesZeroToOneRange, u = (l.isPassthrough(8) || !d) && o === 0;
    let x = u ? s : 0;
    const g = u ? i : new Uint8ClampedArray(f * a), p = this.numComps, m = new Float32Array(p), b = new Float32Array(f);
    let y, w;
    for (y = 0; y < a; y++) {
      for (w = 0; w < p; w++)
        m[w] = e[n++] * h;
      if (c(m, 0, b, 0), d)
        for (w = 0; w < f; w++)
          g[x++] = b[w] * 255;
      else
        l.getRgbItem(b, 0, g, x), x += f;
    }
    u || l.getRgbBuffer(g, 0, a, i, s, 8, o);
  }
  getOutputLength(e, n) {
    return this.base.getOutputLength(e * this.base.numComps / this.numComps, n);
  }
}
class Ac extends jt {
  constructor(e) {
    super("Pattern", null), this.base = e;
  }
  isDefaultDecode(e, n) {
    _e("Should not call PatternCS.isDefaultDecode");
  }
}
class Nf extends jt {
  constructor(e, n, a) {
    super("Indexed", 1), this.base = e, this.highVal = n;
    const i = e.numComps * (n + 1);
    if (this.lookup = new Uint8Array(i), a instanceof Ne) {
      const s = a.getBytes(i);
      this.lookup.set(s);
    } else if (typeof a == "string")
      for (let s = 0; s < i; ++s)
        this.lookup[s] = a.charCodeAt(s) & 255;
    else
      throw new W(`IndexedCS - unrecognized lookup table: ${a}`);
  }
  getRgbItem(e, n, a, i) {
    const {
      base: s,
      highVal: r,
      lookup: o
    } = this, c = Lt(Math.round(e[n]), 0, r) * s.numComps;
    s.getRgbBuffer(o, c, 1, a, i, 8, 0);
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const {
      base: c,
      highVal: l,
      lookup: h
    } = this, {
      numComps: f
    } = c, d = c.getOutputLength(f, o);
    for (let u = 0; u < a; ++u) {
      const x = Lt(Math.round(e[n++]), 0, l) * f;
      c.getRgbBuffer(h, x, 1, i, s, 8, o), s += d;
    }
  }
  getOutputLength(e, n) {
    return this.base.getOutputLength(e * this.base.numComps, n);
  }
  isDefaultDecode(e, n) {
    return Array.isArray(e) ? e.length !== 2 ? (F("Decode map length is not correct"), !0) : !Number.isInteger(n) || n < 1 ? (F("Bits per component is not correct"), !0) : e[0] === 0 && e[1] === (1 << n) - 1 : !0;
  }
}
class Df extends jt {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(e, n, a, i) {
    const s = e[n] * 255;
    a[i] = a[i + 1] = a[i + 2] = s;
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const c = 255 / ((1 << r) - 1);
    let l = n, h = s;
    for (let f = 0; f < a; ++f) {
      const d = c * e[l++];
      i[h++] = d, i[h++] = d, i[h++] = d, h += o;
    }
  }
  getOutputLength(e, n) {
    return e * (3 + n);
  }
}
class Lf extends jt {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(e, n, a, i) {
    a[i] = e[n] * 255, a[i + 1] = e[n + 1] * 255, a[i + 2] = e[n + 2] * 255;
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    if (r === 8 && o === 0) {
      i.set(e.subarray(n, n + a * 3), s);
      return;
    }
    const c = 255 / ((1 << r) - 1);
    let l = n, h = s;
    for (let f = 0; f < a; ++f)
      i[h++] = c * e[l++], i[h++] = c * e[l++], i[h++] = c * e[l++], h += o;
  }
  getOutputLength(e, n) {
    return e * (3 + n) / 3 | 0;
  }
  isPassthrough(e) {
    return e === 8;
  }
}
class Uf extends jt {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(e, n) {
    return e * 4;
  }
  isPassthrough(e) {
    return e === 8;
  }
  fillRgb(e, n, a, i, s, r, o, c, l) {
    a !== s || n !== i ? Bf(c, e, n, a, i, s, l) : Mf(c, e, l);
  }
}
class g1 extends jt {
  constructor() {
    super("DeviceCMYK", 4);
  }
  #e(e, n, a, i, s) {
    const r = e[n] * a, o = e[n + 1] * a, c = e[n + 2] * a, l = e[n + 3] * a;
    i[s] = 255 + r * (-4.387332384609988 * r + 54.48615194189176 * o + 18.82290502165302 * c + 212.25662451639585 * l + -285.2331026137004) + o * (1.7149763477362134 * o - 5.6096736904047315 * c + -17.873870861415444 * l - 5.497006427196366) + c * (-2.5217340131683033 * c - 21.248923337353073 * l + 17.5119270841813) + l * (-21.86122147463605 * l - 189.48180835922747), i[s + 1] = 255 + r * (8.841041422036149 * r + 60.118027045597366 * o + 6.871425592049007 * c + 31.159100130055922 * l + -79.2970844816548) + o * (-15.310361306967817 * o + 17.575251261109482 * c + 131.35250912493976 * l - 190.9453302588951) + c * (4.444339102852739 * c + 9.8632861493405 * l - 24.86741582555878) + l * (-20.737325471181034 * l - 187.80453709719578), i[s + 2] = 255 + r * (0.8842522430003296 * r + 8.078677503112928 * o + 30.89978309703729 * c - 0.23883238689178934 * l + -14.183576799673286) + o * (10.49593273432072 * o + 63.02378494754052 * c + 50.606957656360734 * l - 112.23884253719248) + c * (0.03296041114873217 * c + 115.60384449646641 * l + -193.58209356861505) + l * (-22.33816807309886 * l - 180.12613974708367);
  }
  getRgbItem(e, n, a, i) {
    this.#e(e, n, 1, a, i);
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const c = 1 / ((1 << r) - 1);
    for (let l = 0; l < a; l++)
      this.#e(e, n, c, i, s), n += 4, s += 3 + o;
  }
  getOutputLength(e, n) {
    return e / 4 * (3 + n) | 0;
  }
}
class jf extends jt {
  constructor(e, n, a) {
    if (super("CalGray", 1), !e)
      throw new W("WhitePoint missing - required for color space CalGray");
    if ([this.XW, this.YW, this.ZW] = e, [this.XB, this.YB, this.ZB] = n || [0, 0, 0], this.G = a || 1, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
      throw new W(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (Ue(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && F(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (Ue(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
  }
  #e(e, n, a, i, s) {
    const o = (e[n] * s) ** this.G, c = this.YW * o, l = Math.max(295.8 * c ** 0.3333333333333333 - 40.8, 0);
    a[i] = l, a[i + 1] = l, a[i + 2] = l;
  }
  getRgbItem(e, n, a, i) {
    this.#e(e, n, a, i, 1);
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const c = 1 / ((1 << r) - 1);
    for (let l = 0; l < a; ++l)
      this.#e(e, n, i, s, c), n += 1, s += 3 + o;
  }
  getOutputLength(e, n) {
    return e * (3 + n);
  }
}
class Yt extends jt {
  static #e = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  static #t = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
  static #n = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
  static #a = new Float32Array([1, 1, 1]);
  static #s = new Float32Array(3);
  static #r = new Float32Array(3);
  static #c = new Float32Array(3);
  static #i = (24 / 116) ** 3 / 8;
  constructor(e, n, a, i) {
    if (super("CalRGB", 3), !e)
      throw new W("WhitePoint missing - required for color space CalRGB");
    const [s, r, o] = this.whitePoint = e, [c, l, h] = this.blackPoint = n || new Float32Array(3);
    if ([this.GR, this.GG, this.GB] = a || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = i || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), s < 0 || o < 0 || r !== 1)
      throw new W(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (c < 0 || l < 0 || h < 0) && (Ue(`Invalid BlackPoint for ${this.name} [${c}, ${l}, ${h}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (Ue(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
  }
  #o(e, n, a) {
    a[0] = e[0] * n[0] + e[1] * n[1] + e[2] * n[2], a[1] = e[3] * n[0] + e[4] * n[1] + e[5] * n[2], a[2] = e[6] * n[0] + e[7] * n[1] + e[8] * n[2];
  }
  #l(e, n, a) {
    a[0] = n[0] * 1 / e[0], a[1] = n[1] * 1 / e[1], a[2] = n[2] * 1 / e[2];
  }
  #h(e, n, a) {
    a[0] = n[0] * 0.95047 / e[0], a[1] = n[1] * 1 / e[1], a[2] = n[2] * 1.08883 / e[2];
  }
  #u(e) {
    return e <= 31308e-7 ? Lt(12.92 * e, 0, 1) : e >= 0.99554525 ? 1 : Lt((1 + 0.055) * e ** (1 / 2.4) - 0.055, 0, 1);
  }
  #f(e) {
    return e < 0 ? -this.#f(-e) : e > 8 ? ((e + 16) / 116) ** 3 : e * Yt.#i;
  }
  #x(e, n, a) {
    if (e[0] === 0 && e[1] === 0 && e[2] === 0) {
      a[0] = n[0], a[1] = n[1], a[2] = n[2];
      return;
    }
    const i = this.#f(0), s = i, r = this.#f(e[0]), o = i, c = this.#f(e[1]), l = i, h = this.#f(e[2]), f = (1 - s) / (1 - r), d = 1 - f, u = (1 - o) / (1 - c), x = 1 - u, g = (1 - l) / (1 - h), p = 1 - g;
    a[0] = n[0] * f + d, a[1] = n[1] * u + x, a[2] = n[2] * g + p;
  }
  #g(e, n, a) {
    if (e[0] === 1 && e[2] === 1) {
      a[0] = n[0], a[1] = n[1], a[2] = n[2];
      return;
    }
    const i = a;
    this.#o(Yt.#e, n, i);
    const s = Yt.#s;
    this.#l(e, i, s), this.#o(Yt.#t, s, a);
  }
  #p(e, n, a) {
    const i = a;
    this.#o(Yt.#e, n, i);
    const s = Yt.#s;
    this.#h(e, i, s), this.#o(Yt.#t, s, a);
  }
  #d(e, n, a, i, s) {
    const r = Lt(e[n] * s, 0, 1), o = Lt(e[n + 1] * s, 0, 1), c = Lt(e[n + 2] * s, 0, 1), l = r === 1 ? 1 : r ** this.GR, h = o === 1 ? 1 : o ** this.GG, f = c === 1 ? 1 : c ** this.GB, d = this.MXA * l + this.MXB * h + this.MXC * f, u = this.MYA * l + this.MYB * h + this.MYC * f, x = this.MZA * l + this.MZB * h + this.MZC * f, g = Yt.#r;
    g[0] = d, g[1] = u, g[2] = x;
    const p = Yt.#c;
    this.#g(this.whitePoint, g, p);
    const m = Yt.#r;
    this.#x(this.blackPoint, p, m);
    const b = Yt.#c;
    this.#p(Yt.#a, m, b);
    const y = Yt.#r;
    this.#o(Yt.#n, b, y), a[i] = this.#u(y[0]) * 255, a[i + 1] = this.#u(y[1]) * 255, a[i + 2] = this.#u(y[2]) * 255;
  }
  getRgbItem(e, n, a, i) {
    this.#d(e, n, a, i, 1);
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const c = 1 / ((1 << r) - 1);
    for (let l = 0; l < a; ++l)
      this.#d(e, n, i, s, c), n += 3, s += 3 + o;
  }
  getOutputLength(e, n) {
    return e * (3 + n) / 3 | 0;
  }
}
class Hf extends jt {
  constructor(e, n, a) {
    if (super("Lab", 3), !e)
      throw new W("WhitePoint missing - required for color space Lab");
    if ([this.XW, this.YW, this.ZW] = e, [this.amin, this.amax, this.bmin, this.bmax] = a || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = n || [0, 0, 0], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
      throw new W("Invalid WhitePoint components, no fallback available");
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (Ue("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (Ue("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
  }
  #e(e) {
    return e >= 6 / 29 ? e ** 3 : 108 / 841 * (e - 4 / 29);
  }
  #t(e, n, a, i) {
    return a + e * (i - a) / n;
  }
  #n(e, n, a, i, s) {
    let r = e[n], o = e[n + 1], c = e[n + 2];
    a !== !1 && (r = this.#t(r, a, 0, 100), o = this.#t(o, a, this.amin, this.amax), c = this.#t(c, a, this.bmin, this.bmax)), o > this.amax ? o = this.amax : o < this.amin && (o = this.amin), c > this.bmax ? c = this.bmax : c < this.bmin && (c = this.bmin);
    const l = (r + 16) / 116, h = l + o / 500, f = l - c / 200, d = this.XW * this.#e(h), u = this.YW * this.#e(l), x = this.ZW * this.#e(f);
    let g, p, m;
    this.ZW < 1 ? (g = d * 3.1339 + u * -1.617 + x * -0.4906, p = d * -0.9785 + u * 1.916 + x * 0.0333, m = d * 0.072 + u * -0.229 + x * 1.4057) : (g = d * 3.2406 + u * -1.5372 + x * -0.4986, p = d * -0.9689 + u * 1.8758 + x * 0.0415, m = d * 0.0557 + u * -0.204 + x * 1.057), i[s] = Math.sqrt(g) * 255, i[s + 1] = Math.sqrt(p) * 255, i[s + 2] = Math.sqrt(m) * 255;
  }
  getRgbItem(e, n, a, i) {
    this.#n(e, n, !1, a, i);
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    const c = (1 << r) - 1;
    for (let l = 0; l < a; l++)
      this.#n(e, n, c, i, s), n += 3, s += 3 + o;
  }
  getOutputLength(e, n) {
    return e * (3 + n) / 3 | 0;
  }
  isDefaultDecode(e, n) {
    return !0;
  }
  get usesZeroToOneRange() {
    return ae(this, "usesZeroToOneRange", !1);
  }
}
function p1(t) {
  const e = new XMLHttpRequest();
  return e.open("GET", t, !1), e.responseType = "arraybuffer", e.send(null), e.response;
}
class da extends jt {
  #e;
  #t;
  static #n = !0;
  static #a = null;
  static #s = null;
  constructor(e, n, a) {
    if (!da.isUsable)
      throw new Error("No ICC color space support");
    super(n, a);
    let i;
    switch (a) {
      case 1:
        i = A0.Gray8, this.#t = (s, r, o) => Sf(this.#e, s[r] * 255, o);
        break;
      case 3:
        i = A0.RGB8, this.#t = (s, r, o) => kf(this.#e, s[r] * 255, s[r + 1] * 255, s[r + 2] * 255, o);
        break;
      case 4:
        i = A0.CMYK, this.#t = (s, r, o) => Af(this.#e, s[r] * 255, s[r + 1] * 255, s[r + 2] * 255, s[r + 3] * 255, o);
        break;
      default:
        throw new Error(`Unsupported number of components: ${a}`);
    }
    if (this.#e = Cf(e, i, Tf.Perceptual), !this.#e)
      throw new Error("Failed to create ICC color space");
    da.#s ||= new FinalizationRegistry((s) => {
      If(s);
    }), da.#s.register(this, this.#e);
  }
  getRgbHex(e, n) {
    return this.#t(e, n, !0), Pt._cssColor;
  }
  getRgbItem(e, n, a, i) {
    Pt._destBuffer = a, Pt._destOffset = i, Pt._destLength = 3, this.#t(e, n, !1), Pt._destBuffer = null;
  }
  getRgbBuffer(e, n, a, i, s, r, o) {
    if (e = e.subarray(n, n + a * this.numComps), r !== 8) {
      const c = 255 / ((1 << r) - 1);
      for (let l = 0, h = e.length; l < h; l++)
        e[l] *= c;
    }
    Pt._mustAddAlpha = o && i.buffer === e.buffer, Pt._destBuffer = i, Pt._destOffset = s, Pt._destLength = a * (3 + o), vf(this.#e, e), Pt._mustAddAlpha = !1, Pt._destBuffer = null;
  }
  getOutputLength(e, n) {
    return e / this.numComps * (3 + n) | 0;
  }
  static setOptions({
    useWasm: e,
    useWorkerFetch: n,
    wasmUrl: a
  }) {
    if (!n) {
      this.#n = !1;
      return;
    }
    this.#n = e, this.#a = a;
  }
  static get isUsable() {
    let e = !1;
    if (this.#n)
      if (this.#a)
        try {
          this._module = Rf({
            module: p1(`${this.#a}qcms_bg.wasm`)
          }), e = !!this._module, Pt._memory = this._module.memory, Pt._makeHexColor = Je.makeHexColor;
        } catch (n) {
          F(`ICCBased color space: "${n}".`);
        }
      else
        F("No ICC color space support due to missing `wasmUrl` API option");
    return ae(this, "isUsable", e);
  }
}
class Rs extends da {
  static #e;
  constructor() {
    const e = new Uint8Array(p1(`${Rs.#e}CGATS001Compat-v2-micro.icc`));
    super(e, "DeviceCMYK", 4);
  }
  static setOptions({
    iccUrl: e
  }) {
    this.#e = e;
  }
  static get isUsable() {
    let e = !1;
    return da.isUsable && (this.#e ? e = !0 : F("No CMYK ICC profile support due to missing `iccUrl` API option")), ae(this, "isUsable", e);
  }
}
class pt extends Ne {
  constructor(e, n, a, i) {
    super(), this.bytes = e instanceof Uint8Array ? e : new Uint8Array(e), this.start = n || 0, this.pos = this.start, this.end = n + a || this.bytes.length, this.dict = i;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(e) {
    const n = this.bytes, a = this.pos, i = this.end;
    if (!e)
      return n.subarray(a, i);
    let s = a + e;
    return s > i && (s = i), this.pos = s, n.subarray(a, s);
  }
  getByteRange(e, n) {
    return e < 0 && (e = 0), n > this.end && (n = this.end), this.bytes.subarray(e, n);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(e, n, a = null) {
    return new pt(this.bytes.buffer, e, n, a);
  }
}
class rn extends pt {
  constructor(e) {
    super(Vt(e));
  }
}
class io extends pt {
  constructor() {
    super(new Uint8Array(0));
  }
}
class $f extends pt {
  constructor(e, n, a) {
    super(new Uint8Array(e), 0, e, null), this.chunkSize = n, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(e / n), this.manager = a, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const e = [];
    for (let n = 0, a = this.numChunks; n < a; ++n)
      this._loadedChunks.has(n) || e.push(n);
    return e;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(e, n) {
    const a = this.chunkSize;
    if (e % a !== 0)
      throw new Error(`Bad begin offset: ${e}`);
    const i = e + n.byteLength;
    if (i % a !== 0 && i !== this.bytes.length)
      throw new Error(`Bad end offset: ${i}`);
    this.bytes.set(new Uint8Array(n), e);
    const s = Math.floor(e / a), r = Math.floor((i - 1) / a) + 1;
    for (let o = s; o < r; ++o)
      this._loadedChunks.add(o);
  }
  onReceiveProgressiveData(e) {
    let n = this.progressiveDataLength;
    const a = Math.floor(n / this.chunkSize);
    this.bytes.set(new Uint8Array(e), n), n += e.byteLength, this.progressiveDataLength = n;
    const i = n >= this.end ? this.numChunks : Math.floor(n / this.chunkSize);
    for (let s = a; s < i; ++s)
      this._loadedChunks.add(s);
  }
  ensureByte(e) {
    if (e < this.progressiveDataLength)
      return;
    const n = Math.floor(e / this.chunkSize);
    if (!(n > this.numChunks) && n !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(n))
        throw new ht(e, e + 1);
      this.lastSuccessfulEnsureByteChunk = n;
    }
  }
  ensureRange(e, n) {
    if (e >= n || n <= this.progressiveDataLength)
      return;
    const a = Math.floor(e / this.chunkSize);
    if (a > this.numChunks)
      return;
    const i = Math.min(Math.floor((n - 1) / this.chunkSize) + 1, this.numChunks);
    for (let s = a; s < i; ++s)
      if (!this._loadedChunks.has(s))
        throw new ht(e, n);
  }
  nextEmptyChunk(e) {
    const n = this.numChunks;
    for (let a = 0; a < n; ++a) {
      const i = (e + a) % n;
      if (!this._loadedChunks.has(i))
        return i;
    }
    return null;
  }
  hasChunk(e) {
    return this._loadedChunks.has(e);
  }
  getByte() {
    const e = this.pos;
    return e >= this.end ? -1 : (e >= this.progressiveDataLength && this.ensureByte(e), this.bytes[this.pos++]);
  }
  getBytes(e) {
    const n = this.bytes, a = this.pos, i = this.end;
    if (!e)
      return i > this.progressiveDataLength && this.ensureRange(a, i), n.subarray(a, i);
    let s = a + e;
    return s > i && (s = i), s > this.progressiveDataLength && this.ensureRange(a, s), this.pos = s, n.subarray(a, s);
  }
  getByteRange(e, n) {
    return e < 0 && (e = 0), n > this.end && (n = this.end), n > this.progressiveDataLength && this.ensureRange(e, n), this.bytes.subarray(e, n);
  }
  makeSubStream(e, n, a = null) {
    n ? e + n > this.progressiveDataLength && this.ensureRange(e, e + n) : e >= this.progressiveDataLength && this.ensureByte(e);
    function i() {
    }
    i.prototype = Object.create(this), i.prototype.getMissingChunks = function() {
      const r = this.chunkSize, o = Math.floor(this.start / r), c = Math.floor((this.end - 1) / r) + 1, l = [];
      for (let h = o; h < c; ++h)
        this._loadedChunks.has(h) || l.push(h);
      return l;
    }, Object.defineProperty(i.prototype, "isDataLoaded", {
      get() {
        return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
      },
      configurable: !0
    });
    const s = new i();
    return s.pos = s.start = e, s.end = e + n || this.end, s.dict = a, s;
  }
  getBaseStreams() {
    return [this];
  }
}
class Gf {
  constructor(e, n) {
    this.length = n.length, this.chunkSize = n.rangeChunkSize, this.stream = new $f(this.length, this.chunkSize, this), this.pdfNetworkStream = e, this.disableAutoFetch = n.disableAutoFetch, this.msgHandler = n.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(e, n) {
    const a = this.pdfNetworkStream.getRangeReader(e, n);
    a.isStreamingSupported || (a.onProgress = this.onProgress.bind(this));
    let i = [], s = 0;
    return new Promise((r, o) => {
      const c = ({
        value: l,
        done: h
      }) => {
        try {
          if (h) {
            const f = o1(i);
            i = null, r(f);
            return;
          }
          s += l.byteLength, a.isStreamingSupported && this.onProgress({
            loaded: s
          }), i.push(l), a.read().then(c, o);
        } catch (f) {
          o(f);
        }
      };
      a.read().then(c, o);
    }).then((r) => {
      this.aborted || this.onReceiveData({
        chunk: r,
        begin: e
      });
    });
  }
  requestAllChunks(e = !1) {
    if (!e) {
      const n = this.stream.getMissingChunks();
      this._requestChunks(n);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(e) {
    const n = this.currRequestId++, a = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(n, a);
    for (const r of e)
      this.stream.hasChunk(r) || a.add(r);
    if (a.size === 0)
      return Promise.resolve();
    const i = Promise.withResolvers();
    this._promisesByRequest.set(n, i);
    const s = [];
    for (const r of a) {
      let o = this._requestsByChunk.get(r);
      o || (o = [], this._requestsByChunk.set(r, o), s.push(r)), o.push(n);
    }
    if (s.length > 0) {
      const r = this.groupChunks(s);
      for (const o of r) {
        const c = o.beginChunk * this.chunkSize, l = Math.min(o.endChunk * this.chunkSize, this.length);
        this.sendRequest(c, l).catch(i.reject);
      }
    }
    return i.promise.catch((r) => {
      if (!this.aborted)
        throw r;
    });
  }
  getStream() {
    return this.stream;
  }
  requestRange(e, n) {
    n = Math.min(n, this.length);
    const a = this.getBeginChunk(e), i = this.getEndChunk(n), s = [];
    for (let r = a; r < i; ++r)
      s.push(r);
    return this._requestChunks(s);
  }
  requestRanges(e = []) {
    const n = [];
    for (const a of e) {
      const i = this.getBeginChunk(a.begin), s = this.getEndChunk(a.end);
      for (let r = i; r < s; ++r)
        n.includes(r) || n.push(r);
    }
    return n.sort((a, i) => a - i), this._requestChunks(n);
  }
  groupChunks(e) {
    const n = [];
    let a = -1, i = -1;
    for (let s = 0, r = e.length; s < r; ++s) {
      const o = e[s];
      a < 0 && (a = o), i >= 0 && i + 1 !== o && (n.push({
        beginChunk: a,
        endChunk: i + 1
      }), a = o), s + 1 === e.length && n.push({
        beginChunk: a,
        endChunk: o + 1
      }), i = o;
    }
    return n;
  }
  onProgress(e) {
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize + e.loaded,
      total: this.length
    });
  }
  onReceiveData(e) {
    const n = e.chunk, a = e.begin === void 0, i = a ? this.progressiveDataLength : e.begin, s = i + n.byteLength, r = Math.floor(i / this.chunkSize), o = s < this.length ? Math.floor(s / this.chunkSize) : Math.ceil(s / this.chunkSize);
    a ? (this.stream.onReceiveProgressiveData(n), this.progressiveDataLength = s) : this.stream.onReceiveData(i, n), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const c = [];
    for (let l = r; l < o; ++l) {
      const h = this._requestsByChunk.get(l);
      if (h) {
        this._requestsByChunk.delete(l);
        for (const f of h) {
          const d = this._chunksNeededByRequest.get(f);
          d.has(l) && d.delete(l), !(d.size > 0) && c.push(f);
        }
      }
    }
    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let l;
      if (this.stream.numChunksLoaded === 1) {
        const h = this.stream.numChunks - 1;
        this.stream.hasChunk(h) || (l = h);
      } else
        l = this.stream.nextEmptyChunk(o);
      Number.isInteger(l) && this._requestChunks([l]);
    }
    for (const l of c) {
      const h = this._promisesByRequest.get(l);
      this._promisesByRequest.delete(l), h.resolve();
    }
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize,
      total: this.length
    });
  }
  onError(e) {
    this._loadedStreamCapability.reject(e);
  }
  getBeginChunk(e) {
    return Math.floor(e / this.chunkSize);
  }
  getEndChunk(e) {
    return Math.floor((e - 1) / this.chunkSize) + 1;
  }
  abort(e) {
    this.aborted = !0, this.pdfNetworkStream?.cancelAllRequests(e);
    for (const n of this._promisesByRequest.values())
      n.reject(e);
  }
}
function m1(t) {
  switch (t.kind) {
    case Nt.GRAYSCALE_1BPP:
      return so(t);
    case Nt.RGB_24BPP:
      return zf(t);
  }
  return null;
}
function so({
  src: t,
  srcPos: e = 0,
  dest: n,
  width: a,
  height: i,
  nonBlackColor: s = 4294967295,
  inverseDecode: r = !1
}) {
  const o = gn.isLittleEndian ? 4278190080 : 255, [c, l] = r ? [s, o] : [o, s], h = a >> 3, f = a & 7, d = t.length;
  n = new Uint32Array(n.buffer);
  let u = 0;
  for (let x = 0; x < i; x++) {
    for (const p = e + h; e < p; e++) {
      const m = e < d ? t[e] : 255;
      n[u++] = m & 128 ? l : c, n[u++] = m & 64 ? l : c, n[u++] = m & 32 ? l : c, n[u++] = m & 16 ? l : c, n[u++] = m & 8 ? l : c, n[u++] = m & 4 ? l : c, n[u++] = m & 2 ? l : c, n[u++] = m & 1 ? l : c;
    }
    if (f === 0)
      continue;
    const g = e < d ? t[e++] : 255;
    for (let p = 0; p < f; p++)
      n[u++] = g & 1 << 7 - p ? l : c;
  }
  return {
    srcPos: e,
    destPos: u
  };
}
function zf({
  src: t,
  srcPos: e = 0,
  dest: n,
  destPos: a = 0,
  width: i,
  height: s
}) {
  let r = 0;
  const o = i * s * 3, c = o >> 2, l = new Uint32Array(t.buffer, e, c);
  if (gn.isLittleEndian) {
    for (; r < c - 2; r += 3, a += 4) {
      const h = l[r], f = l[r + 1], d = l[r + 2];
      n[a] = h | 4278190080, n[a + 1] = h >>> 24 | f << 8 | 4278190080, n[a + 2] = f >>> 16 | d << 16 | 4278190080, n[a + 3] = d >>> 8 | 4278190080;
    }
    for (let h = r * 4, f = e + o; h < f; h += 3)
      n[a++] = t[h] | t[h + 1] << 8 | t[h + 2] << 16 | 4278190080;
  } else {
    for (; r < c - 2; r += 3, a += 4) {
      const h = l[r], f = l[r + 1], d = l[r + 2];
      n[a] = h | 255, n[a + 1] = h << 24 | f >>> 8 | 255, n[a + 2] = f << 16 | d >>> 16 | 255, n[a + 3] = d << 8 | 255;
    }
    for (let h = r * 4, f = e + o; h < f; h += 3)
      n[a++] = t[h] << 24 | t[h + 1] << 16 | t[h + 2] << 8 | 255;
  }
  return {
    srcPos: e + o,
    destPos: a
  };
}
function _f(t, e) {
  if (gn.isLittleEndian)
    for (let n = 0, a = t.length; n < a; n++)
      e[n] = t[n] * 65793 | 4278190080;
  else
    for (let n = 0, a = t.length; n < a; n++)
      e[n] = t[n] * 16843008 | 255;
}
const Cc = 2048, Wf = 65537, Ic = 128;
class fn {
  static #e = Cc;
  static #t = gn.isImageDecoderSupported;
  constructor(e, n) {
    this._imgData = e, this._isMask = n;
  }
  static get canUseImageDecoder() {
    return ae(this, "canUseImageDecoder", this.#t ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(!1));
  }
  static needsToBeResized(e, n) {
    if (e <= this.#e && n <= this.#e)
      return !1;
    const {
      MAX_DIM: a
    } = this;
    if (e > a || n > a)
      return !0;
    const i = e * n;
    if (this._hasMaxArea)
      return i > this.MAX_AREA;
    if (i < this.#e ** 2)
      return !1;
    if (this._areGoodDims(e, n))
      return this.#e = Math.max(this.#e, Math.floor(Math.sqrt(e * n))), !1;
    this.#e = this._guessMax(this.#e, a, Ic, 0);
    const s = this.MAX_AREA = this.#e ** 2;
    return i > s;
  }
  static getReducePowerForJPX(e, n, a) {
    const i = e * n, s = 2 ** 30 / (a * 4);
    if (!this.needsToBeResized(e, n))
      return i > s ? Math.ceil(Math.log2(i / s)) : 0;
    const {
      MAX_DIM: r,
      MAX_AREA: o
    } = this, c = Math.max(e / r, n / r, Math.sqrt(i / Math.min(s, o)));
    return Math.ceil(Math.log2(c));
  }
  static get MAX_DIM() {
    return ae(this, "MAX_DIM", this._guessMax(Cc, Wf, 0, 1));
  }
  static get MAX_AREA() {
    return this._hasMaxArea = !0, ae(this, "MAX_AREA", this._guessMax(this.#e, this.MAX_DIM, Ic, 0) ** 2);
  }
  static set MAX_AREA(e) {
    e >= 0 && (this._hasMaxArea = !0, ae(this, "MAX_AREA", e));
  }
  static setOptions({
    canvasMaxAreaInBytes: e = -1,
    isImageDecoderSupported: n = !1
  }) {
    this._hasMaxArea || (this.MAX_AREA = e >> 2), this.#t = n;
  }
  static _areGoodDims(e, n) {
    try {
      const a = new OffscreenCanvas(e, n), i = a.getContext("2d");
      i.fillRect(0, 0, 1, 1);
      const s = i.getImageData(0, 0, 1, 1).data[3];
      return a.width = a.height = 1, s !== 0;
    } catch {
      return !1;
    }
  }
  static _guessMax(e, n, a, i) {
    for (; e + a + 1 < n; ) {
      const s = Math.floor((e + n) / 2), r = i || s;
      this._areGoodDims(s, r) ? e = s : n = s;
    }
    return e;
  }
  static async createImage(e, n = !1) {
    return new fn(e, n)._createImage();
  }
  async _createImage() {
    const {
      _imgData: e
    } = this, {
      width: n,
      height: a
    } = e;
    if (n * a * 4 > J0) {
      const b = this.#n();
      if (b)
        return b;
    }
    const i = this._encodeBMP();
    let s, r;
    await fn.canUseImageDecoder ? (s = new ImageDecoder({
      data: i,
      type: "image/bmp",
      preferAnimation: !1,
      transfer: [i.buffer]
    }), r = s.decode().catch((b) => (F(`BMP image decoding failed: ${b}`), createImageBitmap(new Blob([this._encodeBMP().buffer], {
      type: "image/bmp"
    })))).finally(() => {
      s.close();
    })) : r = createImageBitmap(new Blob([i.buffer], {
      type: "image/bmp"
    }));
    const {
      MAX_AREA: o,
      MAX_DIM: c
    } = fn, l = Math.max(n / c, a / c, Math.sqrt(n * a / o)), h = Math.max(l, 2), f = Math.round(10 * (l + 1.25)) / 10 / h, d = Math.floor(Math.log2(f)), u = new Array(d + 2).fill(2);
    u[0] = h, u.splice(-1, 1, f / (1 << d));
    let x = n, g = a;
    const p = await r;
    let m = p.image || p;
    for (const b of u) {
      const y = x, w = g;
      x = Math.floor(x / b) - 1, g = Math.floor(g / b) - 1;
      const S = new OffscreenCanvas(x, g);
      S.getContext("2d").drawImage(m, 0, 0, y, w, 0, 0, x, g), m.close(), m = S.transferToImageBitmap();
    }
    return e.data = null, e.bitmap = m, e.width = x, e.height = g, e;
  }
  #n() {
    const {
      _imgData: e
    } = this, {
      data: n,
      width: a,
      height: i,
      kind: s
    } = e, r = a * i * 4, o = Math.ceil(Math.log2(r / J0)), c = a >> o, l = i >> o;
    let h, f = i;
    try {
      h = new Uint8Array(r);
    } catch {
      let w = Math.floor(Math.log2(r + 1));
      for (; ; )
        try {
          h = new Uint8Array(2 ** w - 1);
          break;
        } catch {
          w -= 1;
        }
      f = Math.floor((2 ** w - 1) / (a * 4));
      const S = a * f * 4;
      S < h.length && (h = new Uint8Array(S));
    }
    const d = new Uint32Array(h.buffer), u = new Uint32Array(c * l);
    let x = 0, g = 0;
    const p = Math.ceil(i / f), m = i % f === 0 ? i : i % f;
    for (let w = 0; w < p; w++) {
      const S = w < p - 1 ? f : m;
      ({
        srcPos: x
      } = m1({
        kind: s,
        src: n,
        dest: d,
        width: a,
        height: S,
        inverseDecode: this._isMask,
        srcPos: x
      }));
      for (let v = 0, k = S >> o; v < k; v++) {
        const A = d.subarray((v << o) * a);
        for (let C = 0; C < c; C++)
          u[g++] = A[C << o];
      }
    }
    if (fn.needsToBeResized(c, l))
      return e.data = u, e.width = c, e.height = l, e.kind = Nt.RGBA_32BPP, null;
    const b = new OffscreenCanvas(c, l);
    return b.getContext("2d", {
      willReadFrequently: !0
    }).putImageData(new ImageData(new Uint8ClampedArray(u.buffer), c, l), 0, 0), e.data = null, e.bitmap = b.transferToImageBitmap(), e.width = c, e.height = l, e;
  }
  _encodeBMP() {
    const {
      width: e,
      height: n,
      kind: a
    } = this._imgData;
    let i = this._imgData.data, s, r = new Uint8Array(0), o = r, c = 0;
    switch (a) {
      case Nt.GRAYSCALE_1BPP: {
        s = 1, r = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const g = e + 7 >> 3, p = g + 3 & -4;
        if (g !== p) {
          const m = new Uint8Array(p * n);
          let b = 0;
          for (let y = 0, w = n * g; y < w; y += g, b += p)
            m.set(i.subarray(y, y + g), b);
          i = m;
        }
        break;
      }
      case Nt.RGB_24BPP: {
        if (s = 24, e & 3) {
          const g = 3 * e, p = g + 3 & -4, m = p - g, b = new Uint8Array(p * n);
          let y = 0;
          for (let w = 0, S = n * g; w < S; w += g) {
            const v = i.subarray(w, w + g);
            for (let k = 0; k < g; k += 3)
              b[y++] = v[k + 2], b[y++] = v[k + 1], b[y++] = v[k];
            y += m;
          }
          i = b;
        } else
          for (let g = 0, p = i.length; g < p; g += 3) {
            const m = i[g];
            i[g] = i[g + 2], i[g + 2] = m;
          }
        break;
      }
      case Nt.RGBA_32BPP:
        s = 32, c = 3, o = new Uint8Array(68);
        const x = new DataView(o.buffer);
        gn.isLittleEndian ? (x.setUint32(0, 255, !0), x.setUint32(4, 65280, !0), x.setUint32(8, 16711680, !0), x.setUint32(12, 4278190080, !0)) : (x.setUint32(0, 4278190080, !0), x.setUint32(4, 16711680, !0), x.setUint32(8, 65280, !0), x.setUint32(12, 255, !0));
        break;
      default:
        throw new Error("invalid format");
    }
    let l = 0;
    const h = 40 + o.length, f = 14 + h + r.length + i.length, d = new Uint8Array(f), u = new DataView(d.buffer);
    return u.setUint16(l, 19778, !0), l += 2, u.setUint32(l, f, !0), l += 4, u.setUint32(l, 0, !0), l += 4, u.setUint32(l, 14 + h + r.length, !0), l += 4, u.setUint32(l, h, !0), l += 4, u.setInt32(l, e, !0), l += 4, u.setInt32(l, -n, !0), l += 4, u.setUint16(l, 1, !0), l += 2, u.setUint16(l, s, !0), l += 2, u.setUint32(l, c, !0), l += 4, u.setUint32(l, 0, !0), l += 4, u.setInt32(l, 0, !0), l += 4, u.setInt32(l, 0, !0), l += 4, u.setUint32(l, r.length / 4, !0), l += 4, u.setUint32(l, 0, !0), l += 4, d.set(o, l), l += o.length, d.set(r, l), l += r.length, d.set(i, l), d;
  }
}
const Vf = new Uint8Array(0);
class on extends Ne {
  constructor(e) {
    if (super(), this._rawMinBufferLength = e || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = Vf, this.minBufferLength = 512, e)
      for (; this.minBufferLength < e; )
        this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && this.bufferLength === 0; )
      this.readBlock();
    return this.bufferLength === 0;
  }
  ensureBuffer(e) {
    const n = this.buffer;
    if (e <= n.byteLength)
      return n;
    let a = this.minBufferLength;
    for (; a < e; )
      a *= 2;
    const i = new Uint8Array(a);
    return i.set(n), this.buffer = i;
  }
  getByte() {
    const e = this.pos;
    for (; this.bufferLength <= e; ) {
      if (this.eof)
        return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(e, n = null) {
    const a = this.pos;
    let i;
    if (e) {
      for (this.ensureBuffer(a + e), i = a + e; !this.eof && this.bufferLength < i; )
        this.readBlock(n);
      const s = this.bufferLength;
      i > s && (i = s);
    } else {
      for (; !this.eof; )
        this.readBlock(n);
      i = this.bufferLength;
    }
    return this.pos = i, this.buffer.subarray(a, i);
  }
  async getImageData(e, n) {
    if (!this.canAsyncDecodeImageFromBuffer)
      return this.isAsyncDecoder ? this.decodeImage(null, n) : this.getBytes(e, n);
    const a = await this.stream.asyncGetBytes();
    return this.decodeImage(a, n);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(e, n, a = null) {
    if (n === void 0)
      for (; !this.eof; )
        this.readBlock();
    else {
      const i = e + n;
      for (; this.bufferLength <= i && !this.eof; )
        this.readBlock();
    }
    return new pt(this.buffer, e, n, a);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
}
class Xf extends on {
  constructor(e, n = null) {
    e = e.filter((i) => i instanceof Ne);
    let a = 0;
    for (const i of e)
      a += i instanceof on ? i._rawMinBufferLength : i.length;
    super(a), this.streams = e, this._onError = n;
  }
  readBlock() {
    const e = this.streams;
    if (e.length === 0) {
      this.eof = !0;
      return;
    }
    const n = e.shift();
    let a;
    try {
      a = n.getBytes();
    } catch (o) {
      if (this._onError) {
        this._onError(o, n.dict?.objId);
        return;
      }
      throw o;
    }
    const i = this.bufferLength, s = i + a.length;
    this.ensureBuffer(s).set(a, i), this.bufferLength = s;
  }
  getBaseStreams() {
    const e = [];
    for (const n of this.streams) {
      const a = n.getBaseStreams();
      a && e.push(...a);
    }
    return e.length > 0 ? e : null;
  }
}
class Ye {
  static parse({
    cs: e,
    xref: n,
    resources: a = null,
    pdfFunctionFactory: i,
    globalColorSpaceCache: s,
    localColorSpaceCache: r,
    asyncIfNotCached: o = !1
  }) {
    const c = {
      xref: n,
      resources: a,
      pdfFunctionFactory: i,
      globalColorSpaceCache: s,
      localColorSpaceCache: r
    };
    let l, h, f;
    if (e instanceof le) {
      h = e;
      const d = s.getByRef(h) || r.getByRef(h);
      if (d)
        return d;
      e = n.fetch(e);
    }
    if (e instanceof Z) {
      l = e.name;
      const d = r.getByName(l);
      if (d)
        return d;
    }
    try {
      f = this.#t(e, c);
    } catch (d) {
      if (o && !(d instanceof ht))
        return Promise.reject(d);
      throw d;
    }
    return (l || h) && (r.set(l, h, f), h && s.set(null, h, f)), o ? Promise.resolve(f) : f;
  }
  static #e(e, n) {
    const {
      globalColorSpaceCache: a
    } = n;
    let i;
    if (e instanceof le) {
      i = e;
      const r = a.getByRef(i);
      if (r)
        return r;
    }
    const s = this.#t(e, n);
    return i && a.set(null, i, s), s;
  }
  static #t(e, n) {
    const {
      xref: a,
      resources: i,
      pdfFunctionFactory: s,
      globalColorSpaceCache: r
    } = n;
    if (e = a.fetchIfRef(e), e instanceof Z)
      switch (e.name) {
        case "G":
        case "DeviceGray":
          return this.gray;
        case "RGB":
        case "DeviceRGB":
          return this.rgb;
        case "DeviceRGBA":
          return this.rgba;
        case "CMYK":
        case "DeviceCMYK":
          return this.cmyk;
        case "Pattern":
          return new Ac(null);
        default:
          if (i instanceof B) {
            const o = i.get("ColorSpace");
            if (o instanceof B) {
              const c = o.get(e.name);
              if (c) {
                if (c instanceof Z)
                  return this.#t(c, n);
                e = c;
                break;
              }
            }
          }
          return F(`Unrecognized ColorSpace: ${e.name}`), this.gray;
      }
    if (Array.isArray(e)) {
      const o = a.fetchIfRef(e[0]).name;
      let c, l, h, f, d, u;
      switch (o) {
        case "G":
        case "DeviceGray":
          return this.gray;
        case "RGB":
        case "DeviceRGB":
          return this.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.cmyk;
        case "CalGray":
          return c = a.fetchIfRef(e[1]), f = c.getArray("WhitePoint"), d = c.getArray("BlackPoint"), u = c.get("Gamma"), new jf(f, d, u);
        case "CalRGB":
          c = a.fetchIfRef(e[1]), f = c.getArray("WhitePoint"), d = c.getArray("BlackPoint"), u = c.getArray("Gamma");
          const x = c.getArray("Matrix");
          return new Yt(f, d, u, x);
        case "ICCBased":
          const g = e[1] instanceof le;
          if (g) {
            const A = r.getByRef(e[1]);
            if (A)
              return A;
          }
          const p = a.fetchIfRef(e[1]), m = p.dict;
          if (l = m.get("N"), da.isUsable)
            try {
              const A = new da(p.getBytes(), "ICCBased", l);
              return g && r.set(null, e[1], A), A;
            } catch (A) {
              if (A instanceof ht)
                throw A;
              F(`ICCBased color space (${e[1]}): "${A}".`);
            }
          const b = m.getRaw("Alternate");
          if (b) {
            const A = this.#e(b, n);
            if (A.numComps === l)
              return A;
            F("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (l === 1)
            return this.gray;
          if (l === 3)
            return this.rgb;
          if (l === 4)
            return this.cmyk;
          break;
        case "Pattern":
          return h = e[1] || null, h && (h = this.#e(h, n)), new Ac(h);
        case "I":
        case "Indexed":
          h = this.#e(e[1], n);
          const y = Lt(a.fetchIfRef(e[2]), 0, 255), w = a.fetchIfRef(e[3]);
          return new Nf(h, y, w);
        case "Separation":
        case "DeviceN":
          const S = a.fetchIfRef(e[1]);
          l = Array.isArray(S) ? S.length : 1, h = this.#e(e[2], n);
          const v = s.create(e[3]);
          return new Pf(l, h, v);
        case "Lab":
          c = a.fetchIfRef(e[1]), f = c.getArray("WhitePoint"), d = c.getArray("BlackPoint");
          const k = c.getArray("Range");
          return new Hf(f, d, k);
        default:
          return F(`Unimplemented ColorSpace object: ${o}`), this.gray;
      }
    }
    return F(`Unrecognized ColorSpace object: ${e}`), this.gray;
  }
  static get gray() {
    return ae(this, "gray", new Df());
  }
  static get rgb() {
    return ae(this, "rgb", new Lf());
  }
  static get rgba() {
    return ae(this, "rgba", new Uf());
  }
  static get cmyk() {
    if (Rs.isUsable)
      try {
        return ae(this, "cmyk", new Rs());
      } catch {
        F("CMYK fallback: DeviceCMYK");
      }
    return ae(this, "cmyk", new g1());
  }
}
class En extends cn {
  constructor(e) {
    super(e, "JpegError");
  }
}
class ro extends cn {
  constructor(e, n) {
    super(e, "DNLMarkerError"), this.scanLines = n;
  }
}
class b1 extends cn {
  constructor(e) {
    super(e, "EOIMarkerError");
  }
}
const ms = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), sr = 4017, rr = 799, or = 3406, cr = 2276, lr = 1567, hr = 3784, pi = 5793, fr = 2896;
function qf(t, e) {
  let n = 0, a, i, s = 16;
  for (; s > 0 && !t[s - 1]; )
    s--;
  const r = [{
    children: [],
    index: 0
  }];
  let o = r[0], c;
  for (a = 0; a < s; a++) {
    for (i = 0; i < t[a]; i++) {
      for (o = r.pop(), o.children[o.index] = e[n]; o.index > 0; )
        o = r.pop();
      for (o.index++, r.push(o); r.length <= a; )
        r.push(c = {
          children: [],
          index: 0
        }), o.children[o.index] = c.children, o = c;
      n++;
    }
    a + 1 < s && (r.push(c = {
      children: [],
      index: 0
    }), o.children[o.index] = c.children, o = c);
  }
  return r[0].children;
}
function oo(t, e, n) {
  return 64 * ((t.blocksPerLine + 1) * e + n);
}
function Kf(t, e, n, a, i, s, r, o, c, l = !1) {
  const h = n.mcusPerLine, f = n.progressive, d = e;
  let u = 0, x = 0;
  function g() {
    if (x > 0)
      return x--, u >> x & 1;
    if (u = t[e++], u === 255) {
      const R = t[e++];
      if (R) {
        if (R === 220 && l) {
          e += 2;
          const L = Ge(t, e);
          if (e += 2, L > 0 && L !== n.scanLines)
            throw new ro("Found DNL marker (0xFFDC) while parsing scan data", L);
        } else if (R === 217) {
          if (l) {
            const L = M * (n.precision === 8 ? 8 : 0);
            if (L > 0 && Math.round(n.scanLines / L) >= 5)
              throw new ro("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", L);
          }
          throw new b1("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new En(`unexpected marker ${(u << 8 | R).toString(16)}`);
      }
    }
    return x = 7, u >>> 7;
  }
  function p(R) {
    let L = R;
    for (; ; ) {
      switch (L = L[g()], typeof L) {
        case "number":
          return L;
        case "object":
          continue;
      }
      throw new En("invalid huffman sequence");
    }
  }
  function m(R) {
    let L = 0;
    for (; R > 0; )
      L = L << 1 | g(), R--;
    return L;
  }
  function b(R) {
    if (R === 1)
      return g() === 1 ? 1 : -1;
    const L = m(R);
    return L >= 1 << R - 1 ? L : L + (-1 << R) + 1;
  }
  function y(R, L) {
    const V = p(R.huffmanTableDC), he = V === 0 ? 0 : b(V);
    R.blockData[L] = R.pred += he;
    let te = 1;
    for (; te < 64; ) {
      const _ = p(R.huffmanTableAC), de = _ & 15, fe = _ >> 4;
      if (de === 0) {
        if (fe < 15)
          break;
        te += 16;
        continue;
      }
      te += fe;
      const Ee = ms[te];
      R.blockData[L + Ee] = b(de), te++;
    }
  }
  function w(R, L) {
    const V = p(R.huffmanTableDC), he = V === 0 ? 0 : b(V) << c;
    R.blockData[L] = R.pred += he;
  }
  function S(R, L) {
    R.blockData[L] |= g() << c;
  }
  let v = 0;
  function k(R, L) {
    if (v > 0) {
      v--;
      return;
    }
    let V = s;
    const he = r;
    for (; V <= he; ) {
      const te = p(R.huffmanTableAC), _ = te & 15, de = te >> 4;
      if (_ === 0) {
        if (de < 15) {
          v = m(de) + (1 << de) - 1;
          break;
        }
        V += 16;
        continue;
      }
      V += de;
      const fe = ms[V];
      R.blockData[L + fe] = b(_) * (1 << c), V++;
    }
  }
  let A = 0, C;
  function T(R, L) {
    let V = s;
    const he = r;
    let te = 0, _, de;
    for (; V <= he; ) {
      const fe = L + ms[V], Ee = R.blockData[fe] < 0 ? -1 : 1;
      switch (A) {
        case 0:
          if (de = p(R.huffmanTableAC), _ = de & 15, te = de >> 4, _ === 0)
            te < 15 ? (v = m(te) + (1 << te), A = 4) : (te = 16, A = 1);
          else {
            if (_ !== 1)
              throw new En("invalid ACn encoding");
            C = b(_), A = te ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          R.blockData[fe] ? R.blockData[fe] += Ee * (g() << c) : (te--, te === 0 && (A = A === 2 ? 3 : 0));
          break;
        case 3:
          R.blockData[fe] ? R.blockData[fe] += Ee * (g() << c) : (R.blockData[fe] = C << c, A = 0);
          break;
        case 4:
          R.blockData[fe] && (R.blockData[fe] += Ee * (g() << c));
          break;
      }
      V++;
    }
    A === 4 && (v--, v === 0 && (A = 0));
  }
  let M = 0;
  function O(R, L, V, he, te) {
    const _ = V / h | 0, de = V % h;
    M = _ * R.v + he;
    const fe = de * R.h + te, Ee = oo(R, M, fe);
    L(R, Ee);
  }
  function N(R, L, V) {
    M = V / R.blocksPerLine | 0;
    const he = V % R.blocksPerLine, te = oo(R, M, he);
    L(R, te);
  }
  const H = a.length;
  let J, U, j, P, K, xe;
  f ? s === 0 ? xe = o === 0 ? w : S : xe = o === 0 ? k : T : xe = y;
  let X = 0, ye;
  const we = H === 1 ? a[0].blocksPerLine * a[0].blocksPerColumn : h * n.mcusPerColumn;
  let D, G;
  for (; X <= we; ) {
    const R = i ? Math.min(we - X, i) : we;
    if (R > 0) {
      for (U = 0; U < H; U++)
        a[U].pred = 0;
      if (v = 0, H === 1)
        for (J = a[0], K = 0; K < R; K++)
          N(J, xe, X), X++;
      else
        for (K = 0; K < R; K++) {
          for (U = 0; U < H; U++)
            for (J = a[U], D = J.h, G = J.v, j = 0; j < G; j++)
              for (P = 0; P < D; P++)
                O(J, xe, X, j, P);
          X++;
        }
    }
    if (x = 0, ye = i0(t, e), !ye)
      break;
    if (ye.invalid) {
      const L = R > 0 ? "unexpected" : "excessive";
      F(`decodeScan - ${L} MCU data, current marker is: ${ye.invalid}`), e = ye.offset;
    }
    if (ye.marker >= 65488 && ye.marker <= 65495)
      e += 2;
    else
      break;
  }
  return e - d;
}
function Yf(t, e, n) {
  const a = t.quantizationTable, i = t.blockData;
  let s, r, o, c, l, h, f, d, u, x, g, p, m, b, y, w, S;
  if (!a)
    throw new En("missing required Quantization Table.");
  for (let v = 0; v < 64; v += 8) {
    if (u = i[e + v], x = i[e + v + 1], g = i[e + v + 2], p = i[e + v + 3], m = i[e + v + 4], b = i[e + v + 5], y = i[e + v + 6], w = i[e + v + 7], u *= a[v], (x | g | p | m | b | y | w) === 0) {
      S = pi * u + 512 >> 10, n[v] = S, n[v + 1] = S, n[v + 2] = S, n[v + 3] = S, n[v + 4] = S, n[v + 5] = S, n[v + 6] = S, n[v + 7] = S;
      continue;
    }
    x *= a[v + 1], g *= a[v + 2], p *= a[v + 3], m *= a[v + 4], b *= a[v + 5], y *= a[v + 6], w *= a[v + 7], s = pi * u + 128 >> 8, r = pi * m + 128 >> 8, o = g, c = y, l = fr * (x - w) + 128 >> 8, d = fr * (x + w) + 128 >> 8, h = p << 4, f = b << 4, s = s + r + 1 >> 1, r = s - r, S = o * hr + c * lr + 128 >> 8, o = o * lr - c * hr + 128 >> 8, c = S, l = l + f + 1 >> 1, f = l - f, d = d + h + 1 >> 1, h = d - h, s = s + c + 1 >> 1, c = s - c, r = r + o + 1 >> 1, o = r - o, S = l * cr + d * or + 2048 >> 12, l = l * or - d * cr + 2048 >> 12, d = S, S = h * rr + f * sr + 2048 >> 12, h = h * sr - f * rr + 2048 >> 12, f = S, n[v] = s + d, n[v + 7] = s - d, n[v + 1] = r + f, n[v + 6] = r - f, n[v + 2] = o + h, n[v + 5] = o - h, n[v + 3] = c + l, n[v + 4] = c - l;
  }
  for (let v = 0; v < 8; ++v) {
    if (u = n[v], x = n[v + 8], g = n[v + 16], p = n[v + 24], m = n[v + 32], b = n[v + 40], y = n[v + 48], w = n[v + 56], (x | g | p | m | b | y | w) === 0) {
      S = pi * u + 8192 >> 14, S < -2040 ? S = 0 : S >= 2024 ? S = 255 : S = S + 2056 >> 4, i[e + v] = S, i[e + v + 8] = S, i[e + v + 16] = S, i[e + v + 24] = S, i[e + v + 32] = S, i[e + v + 40] = S, i[e + v + 48] = S, i[e + v + 56] = S;
      continue;
    }
    s = pi * u + 2048 >> 12, r = pi * m + 2048 >> 12, o = g, c = y, l = fr * (x - w) + 2048 >> 12, d = fr * (x + w) + 2048 >> 12, h = p, f = b, s = (s + r + 1 >> 1) + 4112, r = s - r, S = o * hr + c * lr + 2048 >> 12, o = o * lr - c * hr + 2048 >> 12, c = S, l = l + f + 1 >> 1, f = l - f, d = d + h + 1 >> 1, h = d - h, s = s + c + 1 >> 1, c = s - c, r = r + o + 1 >> 1, o = r - o, S = l * cr + d * or + 2048 >> 12, l = l * or - d * cr + 2048 >> 12, d = S, S = h * rr + f * sr + 2048 >> 12, h = h * sr - f * rr + 2048 >> 12, f = S, u = s + d, w = s - d, x = r + f, y = r - f, g = o + h, b = o - h, p = c + l, m = c - l, u < 16 ? u = 0 : u >= 4080 ? u = 255 : u >>= 4, x < 16 ? x = 0 : x >= 4080 ? x = 255 : x >>= 4, g < 16 ? g = 0 : g >= 4080 ? g = 255 : g >>= 4, p < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4, m < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4, b < 16 ? b = 0 : b >= 4080 ? b = 255 : b >>= 4, y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4, w < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4, i[e + v] = u, i[e + v + 8] = x, i[e + v + 16] = g, i[e + v + 24] = p, i[e + v + 32] = m, i[e + v + 40] = b, i[e + v + 48] = y, i[e + v + 56] = w;
  }
}
function Jf(t, e) {
  const n = e.blocksPerLine, a = e.blocksPerColumn, i = new Int16Array(64);
  for (let s = 0; s < a; s++)
    for (let r = 0; r < n; r++) {
      const o = oo(e, s, r);
      Yf(e, o, i);
    }
  return e.blockData;
}
function i0(t, e, n = e) {
  const a = t.length - 1;
  let i = n < e ? n : e;
  if (e >= a)
    return null;
  const s = Ge(t, e);
  if (s >= 65472 && s <= 65534)
    return {
      invalid: null,
      marker: s,
      offset: e
    };
  let r = Ge(t, i);
  for (; !(r >= 65472 && r <= 65534); ) {
    if (++i >= a)
      return null;
    r = Ge(t, i);
  }
  return {
    invalid: s.toString(16),
    marker: r,
    offset: i
  };
}
function Zf(t) {
  const e = Math.ceil(t.samplesPerLine / 8 / t.maxH), n = Math.ceil(t.scanLines / 8 / t.maxV);
  for (const a of t.components) {
    const i = Math.ceil(Math.ceil(t.samplesPerLine / 8) * a.h / t.maxH), s = Math.ceil(Math.ceil(t.scanLines / 8) * a.v / t.maxV), r = e * a.h, c = 64 * (n * a.v) * (r + 1);
    a.blockData = new Int16Array(c), a.blocksPerLine = i, a.blocksPerColumn = s;
  }
  t.mcusPerLine = e, t.mcusPerColumn = n;
}
function Tc(t, e) {
  const n = Ge(t, e);
  e += 2;
  let a = e + n - 2;
  const i = i0(t, a, e);
  i?.invalid && (F("readDataBlock - incorrect length, current marker is: " + i.invalid), a = i.offset);
  const s = t.subarray(e, a);
  return {
    appData: s,
    oldOffset: e,
    newOffset: e + s.length
  };
}
function Qf(t, e) {
  const n = Ge(t, e);
  e += 2;
  const a = e + n - 2, i = i0(t, a, e);
  return i?.invalid ? i.offset : a;
}
class Ec {
  constructor({
    decodeTransform: e = null,
    colorTransform: n = -1
  } = {}) {
    this._decodeTransform = e, this._colorTransform = n;
  }
  static canUseImageDecoder(e, n = -1) {
    let a = null, i = 0, s = null, r = Ge(e, i);
    if (i += 2, r !== 65496)
      throw new En("SOI not found");
    r = Ge(e, i), i += 2;
    e: for (; r !== 65497; ) {
      switch (r) {
        case 65505:
          const {
            appData: o,
            oldOffset: c,
            newOffset: l
          } = Tc(e, i);
          if (i = l, o[0] === 69 && o[1] === 120 && o[2] === 105 && o[3] === 102 && o[4] === 0 && o[5] === 0) {
            if (a)
              throw new En("Duplicate EXIF-blocks found.");
            a = {
              exifStart: c + 6,
              exifEnd: l
            };
          }
          r = Ge(e, i), i += 2;
          continue;
        case 65472:
        case 65473:
        case 65474:
          s = e[i + 7];
          break e;
        case 65535:
          e[i] !== 255 && i--;
          break;
      }
      i = Qf(e, i), r = Ge(e, i), i += 2;
    }
    return s === 4 || s === 3 && n === 0 ? null : a || {};
  }
  parse(e, {
    dnlScanLines: n = null
  } = {}) {
    let a = 0, i = null, s = null, r, o, c = 0;
    const l = [], h = [], f = [];
    let d = Ge(e, a);
    if (a += 2, d !== 65496)
      throw new En("SOI not found");
    d = Ge(e, a), a += 2;
    e: for (; d !== 65497; ) {
      let u, x, g;
      switch (d) {
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          const {
            appData: p,
            newOffset: m
          } = Tc(e, a);
          a = m, d === 65504 && p[0] === 74 && p[1] === 70 && p[2] === 73 && p[3] === 70 && p[4] === 0 && (i = {
            version: {
              major: p[5],
              minor: p[6]
            },
            densityUnits: p[7],
            xDensity: p[8] << 8 | p[9],
            yDensity: p[10] << 8 | p[11],
            thumbWidth: p[12],
            thumbHeight: p[13],
            thumbData: p.subarray(14, 14 + 3 * p[12] * p[13])
          }), d === 65518 && p[0] === 65 && p[1] === 100 && p[2] === 111 && p[3] === 98 && p[4] === 101 && (s = {
            version: p[5] << 8 | p[6],
            flags0: p[7] << 8 | p[8],
            flags1: p[9] << 8 | p[10],
            transformCode: p[11]
          });
          break;
        case 65499:
          const b = Ge(e, a);
          a += 2;
          const y = b + a - 2;
          let w;
          for (; a < y; ) {
            const j = e[a++], P = new Uint16Array(64);
            if (j >> 4 === 0)
              for (x = 0; x < 64; x++)
                w = ms[x], P[w] = e[a++];
            else if (j >> 4 === 1)
              for (x = 0; x < 64; x++)
                w = ms[x], P[w] = Ge(e, a), a += 2;
            else
              throw new En("DQT - invalid table spec");
            l[j & 15] = P;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          if (r)
            throw new En("Only single frame JPEGs supported");
          a += 2, r = {}, r.extended = d === 65473, r.progressive = d === 65474, r.precision = e[a++];
          const S = Ge(e, a);
          a += 2, r.scanLines = n || S, r.samplesPerLine = Ge(e, a), a += 2, r.components = [], r.componentIds = {};
          const v = e[a++];
          let k = 0, A = 0;
          for (u = 0; u < v; u++) {
            const j = e[a], P = e[a + 1] >> 4, K = e[a + 1] & 15;
            k < P && (k = P), A < K && (A = K);
            const xe = e[a + 2];
            g = r.components.push({
              h: P,
              v: K,
              quantizationId: xe,
              quantizationTable: null
            }), r.componentIds[j] = g - 1, a += 3;
          }
          r.maxH = k, r.maxV = A, Zf(r);
          break;
        case 65476:
          const C = Ge(e, a);
          for (a += 2, u = 2; u < C; ) {
            const j = e[a++], P = new Uint8Array(16);
            let K = 0;
            for (x = 0; x < 16; x++, a++)
              K += P[x] = e[a];
            const xe = new Uint8Array(K);
            for (x = 0; x < K; x++, a++)
              xe[x] = e[a];
            u += 17 + K, (j >> 4 === 0 ? f : h)[j & 15] = qf(P, xe);
          }
          break;
        case 65501:
          a += 2, o = Ge(e, a), a += 2;
          break;
        case 65498:
          const T = ++c === 1 && !n;
          a += 2;
          const M = e[a++], O = [];
          for (u = 0; u < M; u++) {
            const j = e[a++], P = r.componentIds[j], K = r.components[P];
            K.index = j;
            const xe = e[a++];
            K.huffmanTableDC = f[xe >> 4], K.huffmanTableAC = h[xe & 15], O.push(K);
          }
          const N = e[a++], H = e[a++], J = e[a++];
          try {
            const j = Kf(e, a, r, O, o, N, H, J >> 4, J & 15, T);
            a += j;
          } catch (j) {
            if (j instanceof ro)
              return F(`${j.message} -- attempting to re-parse the JPEG image.`), this.parse(e, {
                dnlScanLines: j.scanLines
              });
            if (j instanceof b1) {
              F(`${j.message} -- ignoring the rest of the image data.`);
              break e;
            }
            throw j;
          }
          break;
        case 65500:
          a += 4;
          break;
        case 65535:
          e[a] !== 255 && a--;
          break;
        default:
          const U = i0(e, a - 2, a - 3);
          if (U?.invalid) {
            F("JpegImage.parse - unexpected data, current marker is: " + U.invalid), a = U.offset;
            break;
          }
          if (!U || a >= e.length - 1) {
            F("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
            break e;
          }
          throw new En("JpegImage.parse - unknown marker: " + d.toString(16));
      }
      d = Ge(e, a), a += 2;
    }
    if (!r)
      throw new En("JpegImage.parse - no frame data found.");
    this.width = r.samplesPerLine, this.height = r.scanLines, this.jfif = i, this.adobe = s, this.components = [];
    for (const u of r.components) {
      const x = l[u.quantizationId];
      x && (u.quantizationTable = x), this.components.push({
        index: u.index,
        output: Jf(r, u),
        scaleX: u.h / r.maxH,
        scaleY: u.v / r.maxV,
        blocksPerLine: u.blocksPerLine,
        blocksPerColumn: u.blocksPerColumn
      });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(e, n, a = !1) {
    const i = this.width / e, s = this.height / n;
    let r, o, c, l, h, f, d, u, x, g, p = 0, m;
    const b = this.components.length, y = e * n * b, w = new Uint8ClampedArray(y), S = new Uint32Array(e), v = 4294967288;
    let k;
    for (d = 0; d < b; d++) {
      if (r = this.components[d], o = r.scaleX * i, c = r.scaleY * s, p = d, m = r.output, l = r.blocksPerLine + 1 << 3, o !== k) {
        for (h = 0; h < e; h++)
          u = 0 | h * o, S[h] = (u & v) << 3 | u & 7;
        k = o;
      }
      for (f = 0; f < n; f++)
        for (u = 0 | f * c, g = l * (u & v) | (u & 7) << 3, h = 0; h < e; h++)
          w[p] = m[g + S[h]], p += b;
    }
    let A = this._decodeTransform;
    if (!a && b === 4 && !A && (A = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), A)
      for (d = 0; d < y; )
        for (u = 0, x = 0; u < b; u++, d++, x += 2)
          w[d] = (w[d] * A[x] >> 8) + A[x + 1];
    return w;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
  }
  _convertYccToRgb(e) {
    let n, a, i;
    for (let s = 0, r = e.length; s < r; s += 3)
      n = e[s], a = e[s + 1], i = e[s + 2], e[s] = n - 179.456 + 1.402 * i, e[s + 1] = n + 135.459 - 0.344 * a - 0.714 * i, e[s + 2] = n - 226.816 + 1.772 * a;
    return e;
  }
  _convertYccToRgba(e, n) {
    for (let a = 0, i = 0, s = e.length; a < s; a += 3, i += 4) {
      const r = e[a], o = e[a + 1], c = e[a + 2];
      n[i] = r - 179.456 + 1.402 * c, n[i + 1] = r + 135.459 - 0.344 * o - 0.714 * c, n[i + 2] = r - 226.816 + 1.772 * o, n[i + 3] = 255;
    }
    return n;
  }
  _convertYcckToRgb(e) {
    return this._convertYcckToCmyk(e), this._convertCmykToRgb(e);
  }
  _convertYcckToRgba(e) {
    return this._convertYcckToCmyk(e), this._convertCmykToRgba(e);
  }
  _convertYcckToCmyk(e) {
    let n, a, i;
    for (let s = 0, r = e.length; s < r; s += 4)
      n = e[s], a = e[s + 1], i = e[s + 2], e[s] = 434.456 - n - 1.402 * i, e[s + 1] = 119.541 - n + 0.344 * a + 0.714 * i, e[s + 2] = 481.816 - n - 1.772 * a;
    return e;
  }
  _convertCmykToRgb(e) {
    const n = e.length / 4;
    return Ye.cmyk.getRgbBuffer(e, 0, n, e, 0, 8, 0), e.subarray(0, n * 3);
  }
  _convertCmykToRgba(e) {
    if (Ye.cmyk.getRgbBuffer(e, 0, e.length / 4, e, 0, 8, 1), Ye.cmyk instanceof g1)
      for (let n = 3, a = e.length; n < a; n += 4)
        e[n] = 255;
    return e;
  }
  getData({
    width: e,
    height: n,
    forceRGBA: a = !1,
    forceRGB: i = !1,
    isSourcePDF: s = !1
  }) {
    if (this.numComponents > 4)
      throw new En("Unsupported color mode");
    const r = this._getLinearizedBlockData(e, n, s);
    if (this.numComponents === 1 && (a || i)) {
      const o = r.length * (a ? 4 : 3), c = new Uint8ClampedArray(o);
      let l = 0;
      if (a)
        _f(r, new Uint32Array(c.buffer));
      else
        for (const h of r)
          c[l++] = h, c[l++] = h, c[l++] = h;
      return c;
    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
      if (a) {
        const o = new Uint8ClampedArray(r.length / 3 * 4);
        return this._convertYccToRgba(r, o);
      }
      return this._convertYccToRgb(r);
    } else if (this.numComponents === 4) {
      if (this._isColorConversionNeeded)
        return a ? this._convertYcckToRgba(r) : i ? this._convertYcckToRgb(r) : this._convertYcckToCmyk(r);
      if (a)
        return this._convertCmykToRgba(r);
      if (i)
        return this._convertCmykToRgb(r);
    }
    return r;
  }
}
class Wi extends on {
  static #e = gn.isImageDecoderSupported;
  constructor(e, n, a) {
    super(n), this.stream = e, this.dict = e.dict, this.maybeLength = n, this.params = a;
  }
  static get canUseImageDecoder() {
    return ae(this, "canUseImageDecoder", this.#e ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(!1));
  }
  static setOptions({
    isImageDecoderSupported: e = !1
  }) {
    this.#e = e;
  }
  get bytes() {
    return ae(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e) {
  }
  readBlock() {
    this.decodeImage();
  }
  get jpegOptions() {
    const e = {
      decodeTransform: void 0,
      colorTransform: void 0
    }, n = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(n)) {
      const a = this.dict.get("BPC", "BitsPerComponent") || 8, i = n.length, s = new Int32Array(i);
      let r = !1;
      const o = (1 << a) - 1;
      for (let c = 0; c < i; c += 2)
        s[c] = (n[c + 1] - n[c]) * 256 | 0, s[c + 1] = n[c] * o | 0, (s[c] !== 256 || s[c + 1] !== 0) && (r = !0);
      r && (e.decodeTransform = s);
    }
    if (this.params instanceof B) {
      const a = this.params.get("ColorTransform");
      Number.isInteger(a) && (e.colorTransform = a);
    }
    return ae(this, "jpegOptions", e);
  }
  #t(e) {
    for (let n = 0, a = e.length - 1; n < a; n++)
      if (e[n] === 255 && e[n + 1] === 216) {
        n > 0 && (e = e.subarray(n));
        break;
      }
    return e;
  }
  decodeImage(e) {
    if (this.eof)
      return this.buffer;
    e = this.#t(e || this.bytes);
    const n = new Ec(this.jpegOptions);
    n.parse(e);
    const a = n.getData({
      width: this.drawWidth,
      height: this.drawHeight,
      forceRGBA: this.forceRGBA,
      forceRGB: this.forceRGB,
      isSourcePDF: !0
    });
    return this.buffer = a, this.bufferLength = a.length, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
  async getTransferableImage() {
    if (!await Wi.canUseImageDecoder)
      return null;
    const e = this.jpegOptions;
    if (e.decodeTransform)
      return null;
    let n;
    try {
      const a = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
      if (!a)
        return null;
      let i = this.#t(a);
      const s = Ec.canUseImageDecoder(i, e.colorTransform);
      return s ? (s.exifStart && (i = i.slice(), i.fill(0, s.exifStart, s.exifEnd)), n = new ImageDecoder({
        data: i,
        type: "image/jpeg",
        preferAnimation: !1
      }), (await n.decode()).image) : null;
    } catch (a) {
      return F(`getTransferableImage - failed: "${a}".`), null;
    } finally {
      n?.close();
    }
  }
}
async function eu(t = {}) {
  var e, n = t, a = "./this.program", i = (ee, re) => {
    throw re;
  }, s = import.meta.url, r = "";
  try {
    r = new URL(".", s).href;
  } catch {
  }
  var o = console.log.bind(console), c = console.error.bind(console), l = !1, h, f, d, u, x, g, p, m, b = !1;
  function y() {
    var ee = u.buffer;
    x = new Int8Array(ee), g = new Uint8Array(ee), p = new Int32Array(ee), m = new Uint32Array(ee), new BigInt64Array(ee), new BigUint64Array(ee);
  }
  function w() {
    if (n.preRun)
      for (typeof n.preRun == "function" && (n.preRun = [n.preRun]); n.preRun.length; )
        J(n.preRun.shift());
    M(H);
  }
  function S() {
    b = !0, xi.s();
  }
  function v() {
    if (n.postRun)
      for (typeof n.postRun == "function" && (n.postRun = [n.postRun]); n.postRun.length; )
        N(n.postRun.shift());
    M(O);
  }
  function k(ee) {
    n.onAbort?.(ee), ee = "Aborted(" + ee + ")", c(ee), l = !0, ee += ". Build with -sASSERTIONS for more info.";
    var re = new WebAssembly.RuntimeError(ee);
    throw d?.(re), re;
  }
  function A() {
    return {
      a: ar
    };
  }
  async function C() {
    function ee(be, Pe) {
      return xi = be.exports, u = xi.r, y(), nr(xi), xi;
    }
    var re = A();
    return new Promise((be, Pe) => {
      n.instantiateWasm(re, (He, rt) => {
        be(ee(He));
      });
    });
  }
  class T {
    name = "ExitStatus";
    constructor(re) {
      this.message = `Program terminated with exit(${re})`, this.status = re;
    }
  }
  var M = (ee) => {
    for (; ee.length > 0; )
      ee.shift()(n);
  }, O = [], N = (ee) => O.push(ee), H = [], J = (ee) => H.push(ee), U = !0, j = () => k(""), P = 0, K = () => {
    U = !1, P = 0;
  }, xe = {}, X = (ee) => {
    if (ee instanceof T || ee == "unwind")
      return h;
    i(1, ee);
  }, ye = () => U || P > 0, we = (ee) => {
    h = ee, ye() || (n.onExit?.(ee), l = !0), i(ee, new T(ee));
  }, D = (ee, re) => {
    h = ee, we(ee);
  }, G = D, R = () => {
    if (!ye())
      try {
        G(h);
      } catch (ee) {
        X(ee);
      }
  }, L = (ee) => {
    if (!l)
      try {
        ee(), R();
      } catch (re) {
        X(re);
      }
  }, V = () => performance.now(), he = (ee, re) => {
    if (xe[ee] && (clearTimeout(xe[ee].id), delete xe[ee]), !re) return 0;
    var be = setTimeout(() => {
      delete xe[ee], L(() => Ki(ee, V()));
    }, re);
    return xe[ee] = {
      id: be,
      timeout_ms: re
    }, 0;
  };
  function te(ee, re) {
    ee >>= 2;
    const be = n.imageData = new Uint8ClampedArray(re), Pe = p.subarray(ee, ee + re);
    be.set(Pe);
  }
  function _(ee, re, be, Pe) {
    ee >>= 2, re >>= 2, be >>= 2;
    const He = n.imageData = new Uint8ClampedArray(Pe * 3), rt = p.subarray(ee, ee + Pe), Ze = p.subarray(re, re + Pe), ft = p.subarray(be, be + Pe);
    for (let lt = 0; lt < Pe; lt++)
      He[3 * lt] = rt[lt], He[3 * lt + 1] = Ze[lt], He[3 * lt + 2] = ft[lt];
  }
  function de(ee, re, be, Pe, He) {
    ee >>= 2, re >>= 2, be >>= 2, Pe >>= 2;
    const rt = n.imageData = new Uint8ClampedArray(He * 4), Ze = p.subarray(ee, ee + He), ft = p.subarray(re, re + He), lt = p.subarray(be, be + He), ir = p.subarray(Pe, Pe + He);
    for (let Vn = 0; Vn < He; Vn++)
      rt[4 * Vn] = Ze[Vn], rt[4 * Vn + 1] = ft[Vn], rt[4 * Vn + 2] = lt[Vn], rt[4 * Vn + 3] = ir[Vn];
  }
  var fe = () => 2147483648, Ee = (ee, re) => Math.ceil(ee / re) * re, Ae = (ee) => {
    var re = u.buffer.byteLength, be = (ee - re + 65535) / 65536 | 0;
    try {
      return u.grow(be), y(), 1;
    } catch {
    }
  }, ie = (ee) => {
    var re = g.length;
    ee >>>= 0;
    var be = fe();
    if (ee > be)
      return !1;
    for (var Pe = 1; Pe <= 4; Pe *= 2) {
      var He = re * (1 + 0.2 / Pe);
      He = Math.min(He, ee + 100663296);
      var rt = Math.min(be, Ee(Math.max(ee, He), 65536)), Ze = Ae(rt);
      if (Ze)
        return !0;
    }
    return !1;
  }, ue = {}, ce = () => a || "./this.program", ke = () => {
    if (!ke.strings) {
      var ee = (typeof navigator == "object" && navigator.language || "C").replace("-", "_") + ".UTF-8", re = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: ee,
        _: ce()
      };
      for (var be in ue)
        ue[be] === void 0 ? delete re[be] : re[be] = ue[be];
      var Pe = [];
      for (var be in re)
        Pe.push(`${be}=${re[be]}`);
      ke.strings = Pe;
    }
    return ke.strings;
  }, me = (ee, re, be, Pe) => {
    if (!(Pe > 0)) return 0;
    for (var He = be, rt = be + Pe - 1, Ze = 0; Ze < ee.length; ++Ze) {
      var ft = ee.codePointAt(Ze);
      if (ft <= 127) {
        if (be >= rt) break;
        re[be++] = ft;
      } else if (ft <= 2047) {
        if (be + 1 >= rt) break;
        re[be++] = 192 | ft >> 6, re[be++] = 128 | ft & 63;
      } else if (ft <= 65535) {
        if (be + 2 >= rt) break;
        re[be++] = 224 | ft >> 12, re[be++] = 128 | ft >> 6 & 63, re[be++] = 128 | ft & 63;
      } else {
        if (be + 3 >= rt) break;
        re[be++] = 240 | ft >> 18, re[be++] = 128 | ft >> 12 & 63, re[be++] = 128 | ft >> 6 & 63, re[be++] = 128 | ft & 63, Ze++;
      }
    }
    return re[be] = 0, be - He;
  }, ge = (ee, re, be) => me(ee, g, re, be), ve = (ee, re) => {
    var be = 0, Pe = 0;
    for (var He of ke()) {
      var rt = re + be;
      m[ee + Pe >> 2] = rt, be += ge(He, rt, 1 / 0) + 1, Pe += 4;
    }
    return 0;
  }, Re = (ee) => {
    for (var re = 0, be = 0; be < ee.length; ++be) {
      var Pe = ee.charCodeAt(be);
      Pe <= 127 ? re++ : Pe <= 2047 ? re += 2 : Pe >= 55296 && Pe <= 57343 ? (re += 4, ++be) : re += 3;
    }
    return re;
  }, ne = (ee, re) => {
    var be = ke();
    m[ee >> 2] = be.length;
    var Pe = 0;
    for (var He of be)
      Pe += Re(He) + 1;
    return m[re >> 2] = Pe, 0;
  };
  function Fe(ee, re, be, Pe) {
    return 70;
  }
  var Te = [null, [], []], je = typeof TextDecoder < "u" ? new TextDecoder() : void 0, De = (ee, re, be, Pe) => {
    for (var He = re + be; ee[re] && !(re >= He); ) ++re;
    return re;
  }, yt = (ee, re = 0, be, Pe) => {
    var He = De(ee, re, be);
    if (He - re > 16 && ee.buffer && je)
      return je.decode(ee.subarray(re, He));
    for (var rt = ""; re < He; ) {
      var Ze = ee[re++];
      if (!(Ze & 128)) {
        rt += String.fromCharCode(Ze);
        continue;
      }
      var ft = ee[re++] & 63;
      if ((Ze & 224) == 192) {
        rt += String.fromCharCode((Ze & 31) << 6 | ft);
        continue;
      }
      var lt = ee[re++] & 63;
      if ((Ze & 240) == 224 ? Ze = (Ze & 15) << 12 | ft << 6 | lt : Ze = (Ze & 7) << 18 | ft << 12 | lt << 6 | ee[re++] & 63, Ze < 65536)
        rt += String.fromCharCode(Ze);
      else {
        var ir = Ze - 65536;
        rt += String.fromCharCode(55296 | ir >> 10, 56320 | ir & 1023);
      }
    }
    return rt;
  }, Ha = (ee, re) => {
    var be = Te[ee];
    re === 0 || re === 10 ? ((ee === 1 ? o : c)(yt(be)), be.length = 0) : be.push(re);
  }, ot = (ee, re, be) => ee ? yt(g, ee, re) : "", $a = (ee, re, be, Pe) => {
    for (var He = 0, rt = 0; rt < be; rt++) {
      var Ze = m[re >> 2], ft = m[re + 4 >> 2];
      re += 8;
      for (var lt = 0; lt < ft; lt++)
        Ha(ee, g[Ze + lt]);
      He += ft;
    }
    return m[Pe >> 2] = He, 0;
  };
  function Ot(ee, re) {
    ee >>= 2;
    const be = n.imageData = new Uint8ClampedArray(re * 4), Pe = p.subarray(ee, ee + re);
    for (let He = 0; He < re; He++)
      be[4 * He] = be[4 * He + 1] = be[4 * He + 2] = Pe[He], be[4 * He + 3] = 255;
  }
  function bn(ee, re, be) {
    ee >>= 2, re >>= 2;
    const Pe = n.imageData = new Uint8ClampedArray(be * 4), He = p.subarray(ee, ee + be), rt = p.subarray(re, re + be);
    for (let Ze = 0; Ze < be; Ze++)
      Pe[4 * Ze] = Pe[4 * Ze + 1] = Pe[4 * Ze + 2] = He[Ze], Pe[4 * Ze + 3] = rt[Ze];
  }
  function ya(ee) {
    const re = ot(ee);
    (n.warn || console.warn)(`OpenJPEG: ${re}`);
  }
  function y0(ee, re, be, Pe) {
    ee >>= 2, re >>= 2, be >>= 2;
    const He = n.imageData = new Uint8ClampedArray(Pe * 4), rt = p.subarray(ee, ee + Pe), Ze = p.subarray(re, re + Pe), ft = p.subarray(be, be + Pe);
    for (let lt = 0; lt < Pe; lt++)
      He[4 * lt] = rt[lt], He[4 * lt + 1] = Ze[lt], He[4 * lt + 2] = ft[lt], He[4 * lt + 3] = 255;
  }
  function er(ee) {
    const re = ot(ee);
    n.errorMessages ? n.errorMessages += `
` + re : n.errorMessages = re;
  }
  var tr = (ee, re) => {
    x.set(ee, re);
  };
  if (n.noExitRuntime && (U = n.noExitRuntime), n.print && (o = n.print), n.printErr && (c = n.printErr), n.wasmBinary && n.wasmBinary, n.arguments && n.arguments, n.thisProgram && (a = n.thisProgram), n.preInit)
    for (typeof n.preInit == "function" && (n.preInit = [n.preInit]); n.preInit.length > 0; )
      n.preInit.shift()();
  n.writeArrayToMemory = tr;
  var Ki;
  function nr(ee) {
    n._malloc = ee.t, n._free = ee.u, n._jp2_decode = ee.v, Ki = ee.w;
  }
  var ar = {
    k: j,
    j: K,
    l: he,
    f: te,
    e: _,
    d: de,
    m: ie,
    o: ve,
    p: ne,
    n: Fe,
    b: $a,
    q: Ot,
    h: bn,
    c: ya,
    i: we,
    g: y0,
    a: er
  };
  function w0() {
    w();
    function ee() {
      n.calledRun = !0, !l && (S(), f?.(n), n.onRuntimeInitialized?.(), v());
    }
    n.setStatus ? (n.setStatus("Running..."), setTimeout(() => {
      setTimeout(() => n.setStatus(""), 1), ee();
    }, 1)) : ee();
  }
  var xi;
  return xi = await C(), w0(), b ? e = n : e = new Promise((ee, re) => {
    f = ee, d = re;
  }), e;
}
const tu = eu;
class ur extends cn {
  constructor(e) {
    super(e, "JpxError");
  }
}
class s0 {
  static #e = null;
  static #t = null;
  static #n = null;
  static #a = !0;
  static #s = !0;
  static #r = null;
  static setOptions({
    handler: e,
    useWasm: n,
    useWorkerFetch: a,
    wasmUrl: i
  }) {
    this.#a = n, this.#s = a, this.#r = i, a || (this.#t = e);
  }
  static async #c(e) {
    const n = `${this.#r}openjpeg_nowasm_fallback.js`;
    let a = null;
    try {
      a = (await import(
        /*webpackIgnore: true*/
        /*@vite-ignore*/
        n
      )).default();
    } catch (i) {
      F(`JpxImage#getJsModule: ${i}`);
    }
    e(a);
  }
  static async #i(e, n, a) {
    const i = "openjpeg.wasm";
    try {
      this.#e || (this.#s ? this.#e = await to(`${this.#r}${i}`) : this.#e = await this.#t.sendWithPromise("FetchBinaryData", {
        type: "wasmFactory",
        filename: i
      }));
      const s = await WebAssembly.instantiate(this.#e, n);
      return a(s.instance);
    } catch (s) {
      return F(`JpxImage#instantiateWasm: ${s}`), this.#c(e), null;
    } finally {
      this.#t = null;
    }
  }
  static async decode(e, {
    numComponents: n = 4,
    isIndexedColormap: a = !1,
    smaskInData: i = !1,
    reducePower: s = 0
  } = {}) {
    if (!this.#n) {
      const {
        promise: c,
        resolve: l
      } = Promise.withResolvers(), h = [c];
      this.#a ? h.push(tu({
        warn: F,
        instantiateWasm: this.#i.bind(this, l)
      })) : this.#c(l), this.#n = Promise.race(h);
    }
    const r = await this.#n;
    if (!r)
      throw new ur("OpenJPEG failed to initialize");
    let o;
    try {
      const c = e.length;
      if (o = r._malloc(c), r.writeArrayToMemory(e, o), r._jp2_decode(o, c, n > 0 ? n : 0, !!a, !!i, s)) {
        const {
          errorMessages: f
        } = r;
        throw f ? (delete r.errorMessages, new ur(f)) : new ur("Unknown error");
      }
      const {
        imageData: h
      } = r;
      return r.imageData = null, h;
    } finally {
      o && r._free(o);
    }
  }
  static cleanup() {
    this.#n = null;
  }
  static parseImageProperties(e) {
    let n = e.getByte();
    for (; n >= 0; ) {
      const a = n;
      if (n = e.getByte(), (a << 8 | n) === 65361) {
        e.skip(4);
        const s = e.getInt32() >>> 0, r = e.getInt32() >>> 0, o = e.getInt32() >>> 0, c = e.getInt32() >>> 0;
        e.skip(16);
        const l = e.getUint16();
        return {
          width: s - o,
          height: r - c,
          bitsPerComponent: 8,
          componentsCount: l
        };
      }
    }
    throw new ur("No size marker found in JPX stream");
  }
}
function Ws(t, e, n, a, i) {
  let s = t;
  for (let r = 0, o = e.length - 1; r < o; r++) {
    const c = e[r];
    s = s[c] ||= [];
  }
  s[e.at(-1)] = {
    checkFn: n,
    iterateFn: a,
    processFn: i
  };
}
const li = [];
Ws(li, [I.save, I.transform, I.paintInlineImageXObject, I.restore], null, function(e, n) {
  const a = e.fnArray, i = e.iCurr - 3, s = (n - i) % 4;
  switch (s) {
    case 0:
      return a[n] === I.save;
    case 1:
      return a[n] === I.transform;
    case 2:
      return a[n] === I.paintInlineImageXObject;
    case 3:
      return a[n] === I.restore;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${s}`);
}, function(e, n) {
  const o = e.fnArray, c = e.argsArray, l = e.iCurr, h = l - 3, f = l - 2, d = l - 1, u = Math.min(Math.floor((n - h) / 4), 200);
  if (u < 10)
    return n - (n - h) % 4;
  let x = 0;
  const g = [];
  let p = 0, m = 1, b = 1;
  for (let A = 0; A < u; A++) {
    const C = c[f + (A << 2)], T = c[d + (A << 2)][0];
    m + T.width > 1e3 && (x = Math.max(x, m), b += p + 2, m = 0, p = 0), g.push({
      transform: C,
      x: m,
      y: b,
      w: T.width,
      h: T.height
    }), m += T.width + 2, p = Math.max(p, T.height);
  }
  const y = Math.max(x, m) + 1, w = b + p + 1, S = new Uint8Array(y * w * 4), v = y << 2;
  for (let A = 0; A < u; A++) {
    const C = c[d + (A << 2)][0].data, T = g[A].w << 2;
    let M = 0, O = g[A].x + g[A].y * y << 2;
    S.set(C.subarray(0, T), O - v);
    for (let N = 0, H = g[A].h; N < H; N++)
      S.set(C.subarray(M, M + T), O), M += T, O += v;
    for (S.set(C.subarray(M - T, M), O); O >= 0; )
      C[O - 4] = C[O], C[O - 3] = C[O + 1], C[O - 2] = C[O + 2], C[O - 1] = C[O + 3], C[O + T] = C[O + T - 4], C[O + T + 1] = C[O + T - 3], C[O + T + 2] = C[O + T - 2], C[O + T + 3] = C[O + T - 1], O -= v;
  }
  const k = {
    width: y,
    height: w
  };
  if (e.isOffscreenCanvasSupported) {
    const A = new OffscreenCanvas(y, w);
    A.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(S.buffer), y, w), 0, 0), k.bitmap = A.transferToImageBitmap(), k.data = null;
  } else
    k.kind = Nt.RGBA_32BPP, k.data = S;
  return o.splice(h, u * 4, I.paintInlineImageXObjectGroup), c.splice(h, u * 4, [k, g]), h + 1;
});
Ws(li, [I.save, I.transform, I.paintImageMaskXObject, I.restore], null, function(e, n) {
  const a = e.fnArray, i = e.iCurr - 3, s = (n - i) % 4;
  switch (s) {
    case 0:
      return a[n] === I.save;
    case 1:
      return a[n] === I.transform;
    case 2:
      return a[n] === I.paintImageMaskXObject;
    case 3:
      return a[n] === I.restore;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${s}`);
}, function(e, n) {
  const r = e.fnArray, o = e.argsArray, c = e.iCurr, l = c - 3, h = c - 2, f = c - 1;
  let d = Math.floor((n - l) / 4);
  if (d < 10)
    return n - (n - l) % 4;
  let u = !1, x, g;
  const p = o[f][0], m = o[h][0], b = o[h][1], y = o[h][2], w = o[h][3];
  if (b === y) {
    u = !0, x = h + 4;
    let S = f + 4;
    for (let v = 1; v < d; v++, x += 4, S += 4)
      if (g = o[x], o[S][0] !== p || g[0] !== m || g[1] !== b || g[2] !== y || g[3] !== w) {
        v < 10 ? u = !1 : d = v;
        break;
      }
  }
  if (u) {
    d = Math.min(d, 1e3);
    const S = new Float32Array(d * 2);
    x = h;
    for (let v = 0; v < d; v++, x += 4)
      g = o[x], S[v << 1] = g[4], S[(v << 1) + 1] = g[5];
    r.splice(l, d * 4, I.paintImageMaskXObjectRepeat), o.splice(l, d * 4, [p, m, b, y, w, S]);
  } else {
    d = Math.min(d, 100);
    const S = [];
    for (let v = 0; v < d; v++) {
      g = o[h + (v << 2)];
      const k = o[f + (v << 2)][0];
      S.push({
        data: k.data,
        width: k.width,
        height: k.height,
        interpolate: k.interpolate,
        count: k.count,
        transform: g
      });
    }
    r.splice(l, d * 4, I.paintImageMaskXObjectGroup), o.splice(l, d * 4, [S]);
  }
  return l + 1;
});
Ws(li, [I.save, I.transform, I.paintImageXObject, I.restore], function(t) {
  const e = t.argsArray, n = t.iCurr - 2;
  return e[n][1] === 0 && e[n][2] === 0;
}, function(e, n) {
  const a = e.fnArray, i = e.argsArray, s = e.iCurr - 3, r = (n - s) % 4;
  switch (r) {
    case 0:
      return a[n] === I.save;
    case 1:
      if (a[n] !== I.transform)
        return !1;
      const o = e.iCurr - 2, c = i[o][0], l = i[o][3];
      return !(i[n][0] !== c || i[n][1] !== 0 || i[n][2] !== 0 || i[n][3] !== l);
    case 2:
      if (a[n] !== I.paintImageXObject)
        return !1;
      const h = e.iCurr - 1, f = i[h][0];
      return i[n][0] === f;
    case 3:
      return a[n] === I.restore;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${r}`);
}, function(t, e) {
  const i = t.fnArray, s = t.argsArray, r = t.iCurr, o = r - 3, c = r - 2, l = r - 1, h = s[l][0], f = s[c][0], d = s[c][3], u = Math.min(Math.floor((e - o) / 4), 1e3);
  if (u < 3)
    return e - (e - o) % 4;
  const x = new Float32Array(u * 2);
  let g = c;
  for (let m = 0; m < u; m++, g += 4) {
    const b = s[g];
    x[m << 1] = b[4], x[(m << 1) + 1] = b[5];
  }
  const p = [h, f, d, x];
  return i.splice(o, u * 4, I.paintImageXObjectRepeat), s.splice(o, u * 4, p), o + 1;
});
Ws(li, [I.beginText, I.setFont, I.setTextMatrix, I.showText, I.endText], null, function(e, n) {
  const a = e.fnArray, i = e.argsArray, s = e.iCurr - 4, r = (n - s) % 5;
  switch (r) {
    case 0:
      return a[n] === I.beginText;
    case 1:
      return a[n] === I.setFont;
    case 2:
      return a[n] === I.setTextMatrix;
    case 3:
      if (a[n] !== I.showText)
        return !1;
      const o = e.iCurr - 3, c = i[o][0], l = i[o][1];
      return !(i[n][0] !== c || i[n][1] !== l);
    case 4:
      return a[n] === I.endText;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${r}`);
}, function(t, e) {
  const i = t.fnArray, s = t.argsArray, r = t.iCurr, o = r - 4, c = r - 3, l = r - 2, h = r - 1, f = r, d = s[c][0], u = s[c][1];
  let x = Math.min(Math.floor((e - o) / 5), 1e3);
  if (x < 3)
    return e - (e - o) % 5;
  let g = o;
  o >= 4 && i[o - 4] === i[c] && i[o - 3] === i[l] && i[o - 2] === i[h] && i[o - 1] === i[f] && s[o - 4][0] === d && s[o - 4][1] === u && (x++, g -= 5);
  let p = g + 4;
  for (let m = 1; m < x; m++)
    i.splice(p, 3), s.splice(p, 3), p += 2;
  return p + 1;
});
Ws(li, [I.save, I.transform, I.constructPath, I.restore], (t) => {
  const e = t.argsArray, n = t.iCurr - 1, a = e[n][0];
  if (a !== I.stroke && a !== I.closeStroke && a !== I.fillStroke && a !== I.eoFillStroke && a !== I.closeFillStroke && a !== I.closeEOFillStroke)
    return !0;
  const i = t.iCurr - 2, s = e[i];
  return s[0] === 1 && s[1] === 0 && s[2] === 0 && s[3] === 1;
}, () => !1, (t, e) => {
  const {
    fnArray: n,
    argsArray: a
  } = t, i = t.iCurr, s = i - 3, r = i - 2, o = i - 1, c = a[o], l = a[r], [, [h], f] = c;
  if (f) {
    Je.scaleMinMax(l, f);
    for (let d = 0, u = h.length; d < u; )
      switch (h[d++]) {
        case Et.moveTo:
        case Et.lineTo:
          Je.applyTransform(h, l, d), d += 2;
          break;
        case Et.curveTo:
          Je.applyTransformToBezier(h, l, d), d += 6;
          break;
      }
  }
  return n.splice(s, 4, I.constructPath), a.splice(s, 4, c), s + 1;
});
class y1 {
  constructor(e) {
    this.queue = e;
  }
  _optimize() {
  }
  push(e, n) {
    this.queue.fnArray.push(e), this.queue.argsArray.push(n), this._optimize();
  }
  flush() {
  }
  reset() {
  }
}
class nu extends y1 {
  constructor(e) {
    super(e), this.state = null, this.context = {
      iCurr: 0,
      fnArray: e.fnArray,
      argsArray: e.argsArray,
      isOffscreenCanvasSupported: Ht.isOffscreenCanvasSupported
    }, this.match = null, this.lastProcessed = 0;
  }
  _optimize() {
    const e = this.queue.fnArray;
    let n = this.lastProcessed, a = e.length, i = this.state, s = this.match;
    if (!i && !s && n + 1 === a && !li[e[n]]) {
      this.lastProcessed = a;
      return;
    }
    const r = this.context;
    for (; n < a; ) {
      if (s) {
        if ((0, s.iterateFn)(r, n)) {
          n++;
          continue;
        }
        if (n = (0, s.processFn)(r, n + 1), a = e.length, s = null, i = null, n >= a)
          break;
      }
      if (i = (i || li)[e[n]], !i || Array.isArray(i)) {
        n++;
        continue;
      }
      if (r.iCurr = n, n++, i.checkFn && !(0, i.checkFn)(r)) {
        i = null;
        continue;
      }
      s = i, i = null;
    }
    this.state = i, this.match = s, this.lastProcessed = n;
  }
  flush() {
    for (; this.match; ) {
      const e = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, e), this.match = null, this.state = null, this._optimize();
    }
  }
  reset() {
    this.state = null, this.match = null, this.lastProcessed = 0;
  }
}
class Ht {
  static CHUNK_SIZE = 1e3;
  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
  static isOffscreenCanvasSupported = !1;
  constructor(e = 0, n) {
    this._streamSink = n, this.fnArray = [], this.argsArray = [], this.optimizer = n && !(e & tn.OPLIST) ? new nu(this) : new y1(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = n ? null : Promise.resolve();
  }
  static setOptions({
    isOffscreenCanvasSupported: e
  }) {
    this.isOffscreenCanvasSupported = e;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(e, n) {
    this.optimizer.push(e, n), this.weight++, this._streamSink && (this.weight >= Ht.CHUNK_SIZE ? this.flush() : this.weight >= Ht.CHUNK_SIZE_ABOUT && (e === I.restore || e === I.endText) && this.flush());
  }
  addImageOps(e, n, a, i = !1) {
    i && (this.addOp(I.save), this.addOp(I.setGState, [[["SMask", !1]]])), a !== void 0 && this.addOp(I.beginMarkedContentProps, ["OC", a]), this.addOp(e, n), a !== void 0 && this.addOp(I.endMarkedContent, []), i && this.addOp(I.restore);
  }
  addDependency(e) {
    this.dependencies.has(e) || (this.dependencies.add(e), this.addOp(I.dependency, [e]));
  }
  addDependencies(e) {
    for (const n of e)
      this.addDependency(n);
  }
  addOpList(e) {
    if (!(e instanceof Ht)) {
      F('addOpList - ignoring invalid "opList" parameter.');
      return;
    }
    for (const n of e.dependencies)
      this.dependencies.add(n);
    for (let n = 0, a = e.length; n < a; n++)
      this.addOp(e.fnArray[n], e.argsArray[n]);
  }
  getIR() {
    return {
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      length: this.length
    };
  }
  get _transfers() {
    const e = [], {
      fnArray: n,
      argsArray: a,
      length: i
    } = this;
    for (let s = 0; s < i; s++)
      switch (n[s]) {
        case I.paintInlineImageXObject:
        case I.paintInlineImageXObjectGroup:
        case I.paintImageMaskXObject: {
          const {
            bitmap: c,
            data: l
          } = a[s][0];
          (c || l?.buffer) && e.push(c || l.buffer);
          break;
        }
        case I.constructPath: {
          const [, [c], l] = a[s];
          c && e.push(c.buffer, l.buffer);
          break;
        }
        case I.paintFormXObjectBegin:
          const [r, o] = a[s];
          r && e.push(r.buffer), o && e.push(o.buffer);
          break;
        case I.setTextMatrix:
          e.push(a[s][0].buffer);
          break;
      }
    return e;
  }
  flush(e = !1, n = null) {
    this.optimizer.flush();
    const a = this.length;
    this._totalLength += a, this._streamSink.enqueue({
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      lastChunk: e,
      separateAnnots: n,
      length: a
    }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
  }
}
We(116);
We(9479);
We(7588);
function Kt(t, e) {
  let n = 0;
  for (let a = 0; a <= e; a++)
    n = n << 8 | t[a];
  return n >>> 0;
}
function dr(t, e) {
  return e === 1 ? String.fromCharCode(t[0], t[1]) : e === 3 ? String.fromCharCode(t[0], t[1], t[2], t[3]) : String.fromCharCode(...t.subarray(0, e + 1));
}
function Qt(t, e, n) {
  let a = 0;
  for (let i = n; i >= 0; i--)
    a += t[i] + e[i], t[i] = a & 255, a >>= 8;
}
function Ga(t, e) {
  let n = 1;
  for (let a = e; a >= 0 && n > 0; a--)
    n += t[a], t[a] = n & 255, n >>= 8;
}
const mi = 16, au = 19;
class iu {
  constructor(e) {
    this.buffer = e, this.pos = 0, this.end = e.length, this.tmpBuf = new Uint8Array(au);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let e = 0, n;
    do {
      const a = this.readByte();
      if (a < 0)
        throw new W("unexpected EOF in bcmap");
      n = !(a & 128), e = e << 7 | a & 127;
    } while (!n);
    return e;
  }
  readSigned() {
    const e = this.readNumber();
    return e & 1 ? ~(e >>> 1) : e >>> 1;
  }
  readHex(e, n) {
    e.set(this.buffer.subarray(this.pos, this.pos + n + 1)), this.pos += n + 1;
  }
  readHexNumber(e, n) {
    let a;
    const i = this.tmpBuf;
    let s = 0;
    do {
      const l = this.readByte();
      if (l < 0)
        throw new W("unexpected EOF in bcmap");
      a = !(l & 128), i[s++] = l & 127;
    } while (!a);
    let r = n, o = 0, c = 0;
    for (; r >= 0; ) {
      for (; c < 8 && i.length > 0; )
        o |= i[--s] << c, c += 7;
      e[r] = o & 255, r--, o >>= 8, c -= 8;
    }
  }
  readHexSigned(e, n) {
    this.readHexNumber(e, n);
    const a = e[n] & 1 ? 255 : 0;
    let i = 0;
    for (let s = 0; s <= n; s++)
      i = (i & 1) << 8 | e[s], e[s] = i >> 1 ^ a;
  }
  readString() {
    const e = this.readNumber(), n = new Array(e);
    for (let a = 0; a < e; a++)
      n[a] = this.readNumber();
    return String.fromCharCode(...n);
  }
}
class su {
  async process(e, n, a) {
    const i = new iu(e), s = i.readByte();
    n.vertical = !!(s & 1);
    let r = null;
    const o = new Uint8Array(mi), c = new Uint8Array(mi), l = new Uint8Array(mi), h = new Uint8Array(mi), f = new Uint8Array(mi);
    let d, u;
    for (; (u = i.readByte()) >= 0; ) {
      const x = u >> 5;
      if (x === 7) {
        switch (u & 31) {
          case 0:
            i.readString();
            break;
          case 1:
            r = i.readString();
            break;
        }
        continue;
      }
      const g = !!(u & 16), p = u & 15;
      if (p + 1 > mi)
        throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const m = 1, b = i.readNumber();
      switch (x) {
        case 0:
          i.readHex(o, p), i.readHexNumber(c, p), Qt(c, o, p), n.addCodespaceRange(p + 1, Kt(o, p), Kt(c, p));
          for (let y = 1; y < b; y++)
            Ga(c, p), i.readHexNumber(o, p), Qt(o, c, p), i.readHexNumber(c, p), Qt(c, o, p), n.addCodespaceRange(p + 1, Kt(o, p), Kt(c, p));
          break;
        case 1:
          i.readHex(o, p), i.readHexNumber(c, p), Qt(c, o, p), i.readNumber();
          for (let y = 1; y < b; y++)
            Ga(c, p), i.readHexNumber(o, p), Qt(o, c, p), i.readHexNumber(c, p), Qt(c, o, p), i.readNumber();
          break;
        case 2:
          i.readHex(l, p), d = i.readNumber(), n.mapOne(Kt(l, p), d);
          for (let y = 1; y < b; y++)
            Ga(l, p), g || (i.readHexNumber(f, p), Qt(l, f, p)), d = i.readSigned() + (d + 1), n.mapOne(Kt(l, p), d);
          break;
        case 3:
          i.readHex(o, p), i.readHexNumber(c, p), Qt(c, o, p), d = i.readNumber(), n.mapCidRange(Kt(o, p), Kt(c, p), d);
          for (let y = 1; y < b; y++)
            Ga(c, p), g ? o.set(c) : (i.readHexNumber(o, p), Qt(o, c, p)), i.readHexNumber(c, p), Qt(c, o, p), d = i.readNumber(), n.mapCidRange(Kt(o, p), Kt(c, p), d);
          break;
        case 4:
          i.readHex(l, m), i.readHex(h, p), n.mapOne(Kt(l, m), dr(h, p));
          for (let y = 1; y < b; y++)
            Ga(l, m), g || (i.readHexNumber(f, m), Qt(l, f, m)), Ga(h, p), i.readHexSigned(f, p), Qt(h, f, p), n.mapOne(Kt(l, m), dr(h, p));
          break;
        case 5:
          i.readHex(o, m), i.readHexNumber(c, m), Qt(c, o, m), i.readHex(h, p), n.mapBfRange(Kt(o, m), Kt(c, m), dr(h, p));
          for (let y = 1; y < b; y++)
            Ga(c, m), g ? o.set(c) : (i.readHexNumber(o, m), Qt(o, c, m)), i.readHexNumber(c, m), Qt(c, o, m), i.readHex(h, p), n.mapBfRange(Kt(o, m), Kt(c, m), dr(h, p));
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${x}`);
      }
    }
    return r ? a(r) : n;
  }
}
class ru extends on {
  constructor(e, n) {
    n && (n *= 0.8), super(n), this.str = e, this.dict = e.dict, this.input = new Uint8Array(5);
  }
  readBlock() {
    const i = this.str;
    let s = i.getByte();
    for (; An(s); )
      s = i.getByte();
    if (s === -1 || s === 126) {
      this.eof = !0;
      return;
    }
    const r = this.bufferLength;
    let o, c;
    if (s === 122) {
      for (o = this.ensureBuffer(r + 4), c = 0; c < 4; ++c)
        o[r + c] = 0;
      this.bufferLength += 4;
    } else {
      const l = this.input;
      for (l[0] = s, c = 1; c < 5; ++c) {
        for (s = i.getByte(); An(s); )
          s = i.getByte();
        if (l[c] = s, s === -1 || s === 126)
          break;
      }
      if (o = this.ensureBuffer(r + c - 1), this.bufferLength += c - 1, c < 5) {
        for (; c < 5; ++c)
          l[c] = 117;
        this.eof = !0;
      }
      let h = 0;
      for (c = 0; c < 5; ++c)
        h = h * 85 + (l[c] - 33);
      for (c = 3; c >= 0; --c)
        o[r + c] = h & 255, h >>= 8;
    }
  }
}
class ou extends on {
  constructor(e, n) {
    n && (n *= 0.5), super(n), this.str = e, this.dict = e.dict, this.firstDigit = -1;
  }
  readBlock() {
    const n = this.str.getBytes(8e3);
    if (!n.length) {
      this.eof = !0;
      return;
    }
    const a = n.length + 1 >> 1, i = this.ensureBuffer(this.bufferLength + a);
    let s = this.bufferLength, r = this.firstDigit;
    for (const o of n) {
      let c;
      if (o >= 48 && o <= 57)
        c = o & 15;
      else if (o >= 65 && o <= 70 || o >= 97 && o <= 102)
        c = (o & 15) + 9;
      else if (o === 62) {
        this.eof = !0;
        break;
      } else
        continue;
      r < 0 ? r = c : (i[s++] = r << 4 | c, r = -1);
    }
    r >= 0 && this.eof && (i[s++] = r << 4, r = -1), this.firstDigit = r, this.bufferLength = s;
  }
}
const co = -2, sa = -1, oa = 0, $t = 1, Ce = 2, Gt = 3, zt = 4, lo = 5, ho = 6, w1 = 7, v1 = 8, Fc = [[-1, -1], [-1, -1], [7, v1], [7, w1], [6, ho], [6, ho], [6, lo], [6, lo], [4, oa], [4, oa], [4, oa], [4, oa], [4, oa], [4, oa], [4, oa], [4, oa], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, $t], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, zt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [3, Gt], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce], [1, Ce]], Rc = [[-1, -1], [12, co], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], Oc = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], Bc = [[-1, -1], [-1, -1], [12, co], [12, co], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], Mc = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], Pc = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
class S1 {
  constructor(e, n = {}) {
    if (typeof e?.next != "function")
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    this.source = e, this.eof = !1, this.encoding = n.K || 0, this.eoline = n.EndOfLine || !1, this.byteAlign = n.EncodedByteAlign || !1, this.columns = n.Columns || 1728, this.rows = n.Rows || 0, this.eoblock = n.EndOfBlock ?? !0, this.black = n.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
    let a;
    for (; (a = this._lookBits(12)) === 0; )
      this._eatBits(1);
    a === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
  }
  readNextChar() {
    if (this.eof)
      return -1;
    const e = this.refLine, n = this.codingLine, a = this.columns;
    let i, s, r, o;
    if (this.outputBits === 0) {
      if (this.rowsDone && (this.eof = !0), this.eof)
        return -1;
      this.err = !1;
      let l, h, f;
      if (this.nextLine2D) {
        for (o = 0; n[o] < a; ++o)
          e[o] = n[o];
        for (e[o++] = a, e[o] = a, n[0] = 0, this.codingPos = 0, i = 0, s = 0; n[this.codingPos] < a; )
          switch (l = this._getTwoDimCode(), l) {
            case oa:
              this._addPixels(e[i + 1], s), e[i + 1] < a && (i += 2);
              break;
            case $t:
              if (l = h = 0, s) {
                do
                  l += f = this._getBlackCode();
                while (f >= 64);
                do
                  h += f = this._getWhiteCode();
                while (f >= 64);
              } else {
                do
                  l += f = this._getWhiteCode();
                while (f >= 64);
                do
                  h += f = this._getBlackCode();
                while (f >= 64);
              }
              for (this._addPixels(n[this.codingPos] + l, s), n[this.codingPos] < a && this._addPixels(n[this.codingPos] + h, s ^ 1); e[i] <= n[this.codingPos] && e[i] < a; )
                i += 2;
              break;
            case w1:
              if (this._addPixels(e[i] + 3, s), s ^= 1, n[this.codingPos] < a)
                for (++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case lo:
              if (this._addPixels(e[i] + 2, s), s ^= 1, n[this.codingPos] < a)
                for (++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case Gt:
              if (this._addPixels(e[i] + 1, s), s ^= 1, n[this.codingPos] < a)
                for (++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case Ce:
              if (this._addPixels(e[i], s), s ^= 1, n[this.codingPos] < a)
                for (++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case v1:
              if (this._addPixelsNeg(e[i] - 3, s), s ^= 1, n[this.codingPos] < a)
                for (i > 0 ? --i : ++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case ho:
              if (this._addPixelsNeg(e[i] - 2, s), s ^= 1, n[this.codingPos] < a)
                for (i > 0 ? --i : ++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case zt:
              if (this._addPixelsNeg(e[i] - 1, s), s ^= 1, n[this.codingPos] < a)
                for (i > 0 ? --i : ++i; e[i] <= n[this.codingPos] && e[i] < a; )
                  i += 2;
              break;
            case sa:
              this._addPixels(a, 0), this.eof = !0;
              break;
            default:
              Ue("bad 2d code"), this._addPixels(a, 0), this.err = !0;
          }
      } else
        for (n[0] = 0, this.codingPos = 0, s = 0; n[this.codingPos] < a; ) {
          if (l = 0, s)
            do
              l += f = this._getBlackCode();
            while (f >= 64);
          else
            do
              l += f = this._getWhiteCode();
            while (f >= 64);
          this._addPixels(n[this.codingPos] + l, s), s ^= 1;
        }
      let d = !1;
      if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
        this.rowsDone = !0;
      else {
        if (l = this._lookBits(12), this.eoline)
          for (; l !== sa && l !== 1; )
            this._eatBits(1), l = this._lookBits(12);
        else
          for (; l === 0; )
            this._eatBits(1), l = this._lookBits(12);
        l === 1 ? (this._eatBits(12), d = !0) : l === sa && (this.eof = !0);
      }
      if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && d && this.byteAlign) {
        if (l = this._lookBits(12), l === 1) {
          if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
            for (o = 0; o < 4; ++o)
              l = this._lookBits(12), l !== 1 && Ue("bad rtc code: " + l), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
          this.eof = !0;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          if (l = this._lookBits(13), l === sa)
            return this.eof = !0, -1;
          if (l >> 1 === 1)
            break;
          this._eatBits(1);
        }
        this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(l & 1));
      }
      this.outputBits = n[0] > 0 ? n[this.codingPos = 0] : n[this.codingPos = 1], this.row++;
    }
    let c;
    if (this.outputBits >= 8)
      c = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && n[this.codingPos] < a && (this.codingPos++, this.outputBits = n[this.codingPos] - n[this.codingPos - 1]);
    else {
      r = 8, c = 0;
      do {
        if (typeof this.outputBits != "number")
          throw new W('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        this.outputBits > r ? (c <<= r, this.codingPos & 1 || (c |= 255 >> 8 - r), this.outputBits -= r, r = 0) : (c <<= this.outputBits, this.codingPos & 1 || (c |= 255 >> 8 - this.outputBits), r -= this.outputBits, this.outputBits = 0, n[this.codingPos] < a ? (this.codingPos++, this.outputBits = n[this.codingPos] - n[this.codingPos - 1]) : r > 0 && (c <<= r, r = 0));
      } while (r);
    }
    return this.black && (c ^= 255), c;
  }
  _addPixels(e, n) {
    const a = this.codingLine;
    let i = this.codingPos;
    e > a[i] && (e > this.columns && (Ue("row is wrong length"), this.err = !0, e = this.columns), i & 1 ^ n && ++i, a[i] = e), this.codingPos = i;
  }
  _addPixelsNeg(e, n) {
    const a = this.codingLine;
    let i = this.codingPos;
    if (e > a[i])
      e > this.columns && (Ue("row is wrong length"), this.err = !0, e = this.columns), i & 1 ^ n && ++i, a[i] = e;
    else if (e < a[i]) {
      for (e < 0 && (Ue("invalid code"), this.err = !0, e = 0); i > 0 && e < a[i - 1]; )
        --i;
      a[i] = e;
    }
    this.codingPos = i;
  }
  _findTableCode(e, n, a, i) {
    const s = i || 0;
    for (let r = e; r <= n; ++r) {
      let o = this._lookBits(r);
      if (o === sa)
        return [!0, 1, !1];
      if (r < n && (o <<= n - r), !s || o >= s) {
        const c = a[o - s];
        if (c[0] === r)
          return this._eatBits(r), [!0, c[1], !0];
      }
    }
    return [!1, 0, !1];
  }
  _getTwoDimCode() {
    let e = 0, n;
    if (this.eoblock) {
      if (e = this._lookBits(7), n = Fc[e], n?.[0] > 0)
        return this._eatBits(n[0]), n[1];
    } else {
      const a = this._findTableCode(1, 7, Fc);
      if (a[0] && a[2])
        return a[1];
    }
    return Ue("Bad two dim code"), sa;
  }
  _getWhiteCode() {
    let e = 0, n;
    if (this.eoblock) {
      if (e = this._lookBits(12), e === sa)
        return 1;
      if (n = e >> 5 === 0 ? Rc[e] : Oc[e >> 3], n[0] > 0)
        return this._eatBits(n[0]), n[1];
    } else {
      let a = this._findTableCode(1, 9, Oc);
      if (a[0] || (a = this._findTableCode(11, 12, Rc), a[0]))
        return a[1];
    }
    return Ue("bad white code"), this._eatBits(1), 1;
  }
  _getBlackCode() {
    let e, n;
    if (this.eoblock) {
      if (e = this._lookBits(13), e === sa)
        return 1;
      if (e >> 7 === 0 ? n = Bc[e] : e >> 9 === 0 && e >> 7 !== 0 ? n = Mc[(e >> 1) - 64] : n = Pc[e >> 7], n[0] > 0)
        return this._eatBits(n[0]), n[1];
    } else {
      let a = this._findTableCode(2, 6, Pc);
      if (a[0] || (a = this._findTableCode(7, 12, Mc, 64), a[0]) || (a = this._findTableCode(10, 13, Bc), a[0]))
        return a[1];
    }
    return Ue("bad black code"), this._eatBits(1), 1;
  }
  _lookBits(e) {
    let n;
    for (; this.inputBits < e; ) {
      if ((n = this.source.next()) === -1)
        return this.inputBits === 0 ? sa : this.inputBuf << e - this.inputBits & 65535 >> 16 - e;
      this.inputBuf = this.inputBuf << 8 | n, this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - e & 65535 >> 16 - e;
  }
  _eatBits(e) {
    (this.inputBits -= e) < 0 && (this.inputBits = 0);
  }
}
class cu extends on {
  constructor(e, n, a) {
    super(n), this.str = e, this.dict = e.dict, a instanceof B || (a = B.empty);
    const i = {
      next() {
        return e.getByte();
      }
    };
    this.ccittFaxDecoder = new S1(i, {
      K: a.get("K"),
      EndOfLine: a.get("EndOfLine"),
      EncodedByteAlign: a.get("EncodedByteAlign"),
      Columns: a.get("Columns"),
      Rows: a.get("Rows"),
      EndOfBlock: a.get("EndOfBlock"),
      BlackIs1: a.get("BlackIs1")
    });
  }
  readBlock() {
    for (; !this.eof; ) {
      const e = this.ccittFaxDecoder.readNextChar();
      if (e === -1) {
        this.eof = !0;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = e;
    }
  }
}
const Nc = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), lu = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), hu = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), fu = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], uu = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
class Dc extends on {
  constructor(e, n) {
    super(n), this.str = e, this.dict = e.dict;
    const a = e.getByte(), i = e.getByte();
    if (a === -1 || i === -1)
      throw new W(`Invalid header in flate stream: ${a}, ${i}`);
    if ((a & 15) !== 8)
      throw new W(`Unknown compression method in flate stream: ${a}, ${i}`);
    if (((a << 8) + i) % 31 !== 0)
      throw new W(`Bad FCHECK in flate stream: ${a}, ${i}`);
    if (i & 32)
      throw new W(`FDICT bit set in flate stream: ${a}, ${i}`);
    this.codeSize = 0, this.codeBuf = 0;
  }
  async getImageData(e, n) {
    const a = await this.asyncGetBytes();
    return a ? a.length <= e ? a : a.subarray(0, e) : this.getBytes(e);
  }
  async asyncGetBytes() {
    this.str.reset();
    const e = this.str.getBytes();
    try {
      const {
        readable: n,
        writable: a
      } = new DecompressionStream("deflate"), i = a.getWriter();
      await i.ready, i.write(e).then(async () => {
        await i.ready, await i.close();
      }).catch(() => {
      });
      const s = [];
      let r = 0;
      for await (const l of n)
        s.push(l), r += l.byteLength;
      const o = new Uint8Array(r);
      let c = 0;
      for (const l of s)
        o.set(l, c), c += l.byteLength;
      return o;
    } catch {
      return this.str = new pt(e, 2, e.length, this.str.dict), this.reset(), null;
    }
  }
  get isAsync() {
    return !0;
  }
  getBits(e) {
    const n = this.str;
    let a = this.codeSize, i = this.codeBuf, s;
    for (; a < e; ) {
      if ((s = n.getByte()) === -1)
        throw new W("Bad encoding in flate stream");
      i |= s << a, a += 8;
    }
    return s = i & (1 << e) - 1, this.codeBuf = i >> e, this.codeSize = a -= e, s;
  }
  getCode(e) {
    const n = this.str, a = e[0], i = e[1];
    let s = this.codeSize, r = this.codeBuf, o;
    for (; s < i && (o = n.getByte()) !== -1; )
      r |= o << s, s += 8;
    const c = a[r & (1 << i) - 1], l = c >> 16, h = c & 65535;
    if (l < 1 || s < l)
      throw new W("Bad encoding in flate stream");
    return this.codeBuf = r >> l, this.codeSize = s - l, h;
  }
  generateHuffmanTable(e) {
    const n = e.length;
    let a = 0, i;
    for (i = 0; i < n; ++i)
      e[i] > a && (a = e[i]);
    const s = 1 << a, r = new Int32Array(s);
    for (let o = 1, c = 0, l = 2; o <= a; ++o, c <<= 1, l <<= 1)
      for (let h = 0; h < n; ++h)
        if (e[h] === o) {
          let f = 0, d = c;
          for (i = 0; i < o; ++i)
            f = f << 1 | d & 1, d >>= 1;
          for (i = f; i < s; i += l)
            r[i] = o << 16 | h;
          ++c;
        }
    return [r, a];
  }
  #e(e) {
    Ue(e), this.eof = !0;
  }
  readBlock() {
    let e, n, a;
    const i = this.str;
    try {
      n = this.getBits(3);
    } catch (l) {
      this.#e(l.message);
      return;
    }
    if (n & 1 && (this.eof = !0), n >>= 1, n === 0) {
      let l;
      if ((l = i.getByte()) === -1) {
        this.#e("Bad block header in flate stream");
        return;
      }
      let h = l;
      if ((l = i.getByte()) === -1) {
        this.#e("Bad block header in flate stream");
        return;
      }
      if (h |= l << 8, (l = i.getByte()) === -1) {
        this.#e("Bad block header in flate stream");
        return;
      }
      let f = l;
      if ((l = i.getByte()) === -1) {
        this.#e("Bad block header in flate stream");
        return;
      }
      if (f |= l << 8, f !== (~h & 65535) && (h !== 0 || f !== 0))
        throw new W("Bad uncompressed block length in flate stream");
      this.codeBuf = 0, this.codeSize = 0;
      const d = this.bufferLength, u = d + h;
      if (e = this.ensureBuffer(u), this.bufferLength = u, h === 0)
        i.peekByte() === -1 && (this.eof = !0);
      else {
        const x = i.getBytes(h);
        e.set(x, d), x.length < h && (this.eof = !0);
      }
      return;
    }
    let s, r;
    if (n === 1)
      s = fu, r = uu;
    else if (n === 2) {
      const l = this.getBits(5) + 257, h = this.getBits(5) + 1, f = this.getBits(4) + 4, d = new Uint8Array(Nc.length);
      let u;
      for (u = 0; u < f; ++u)
        d[Nc[u]] = this.getBits(3);
      const x = this.generateHuffmanTable(d);
      a = 0, u = 0;
      const g = l + h, p = new Uint8Array(g);
      let m, b, y;
      for (; u < g; ) {
        const w = this.getCode(x);
        if (w === 16)
          m = 2, b = 3, y = a;
        else if (w === 17)
          m = 3, b = 3, y = a = 0;
        else if (w === 18)
          m = 7, b = 11, y = a = 0;
        else {
          p[u++] = a = w;
          continue;
        }
        let S = this.getBits(m) + b;
        for (; S-- > 0; )
          p[u++] = y;
      }
      s = this.generateHuffmanTable(p.subarray(0, l)), r = this.generateHuffmanTable(p.subarray(l, g));
    } else
      throw new W("Unknown block type in flate stream");
    e = this.buffer;
    let o = e ? e.length : 0, c = this.bufferLength;
    for (; ; ) {
      let l = this.getCode(s);
      if (l < 256) {
        c + 1 >= o && (e = this.ensureBuffer(c + 1), o = e.length), e[c++] = l;
        continue;
      }
      if (l === 256) {
        this.bufferLength = c;
        return;
      }
      l -= 257, l = lu[l];
      let h = l >> 16;
      h > 0 && (h = this.getBits(h)), a = (l & 65535) + h, l = this.getCode(r), l = hu[l], h = l >> 16, h > 0 && (h = this.getBits(h));
      const f = (l & 65535) + h;
      c + a >= o && (e = this.ensureBuffer(c + a), o = e.length);
      for (let d = 0; d < a; ++d, ++c)
        e[c] = e[c - f];
    }
  }
}
const du = [{
  qe: 22017,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 13313,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 6145,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 2753,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 1313,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 545,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 21505,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 18433,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 14337,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 12289,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 9217,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 7169,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 5633,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 21505,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 20737,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 18433,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 14337,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 13313,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 12289,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 10241,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 9217,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 8705,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 7169,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 6145,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 5633,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 5121,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 4609,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 4353,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 2753,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 2497,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 2209,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 1313,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 1089,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 673,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 545,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 321,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 273,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 133,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 73,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 37,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 21,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 9,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 5,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 1,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];
class xu {
  constructor(e, n, a) {
    this.data = e, this.bp = n, this.dataEnd = a, this.chigh = e[n], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
  }
  byteIn() {
    const e = this.data;
    let n = this.bp;
    e[n] === 255 ? e[n + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (n++, this.clow += e[n] << 9, this.ct = 7, this.bp = n) : (n++, this.clow += n < this.dataEnd ? e[n] << 8 : 65280, this.ct = 8, this.bp = n), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
  }
  readBit(e, n) {
    let a = e[n] >> 1, i = e[n] & 1;
    const s = du[a], r = s.qe;
    let o, c = this.a - r;
    if (this.chigh < r)
      c < r ? (c = r, o = i, a = s.nmps) : (c = r, o = 1 ^ i, s.switchFlag === 1 && (i = o), a = s.nlps);
    else {
      if (this.chigh -= r, (c & 32768) !== 0)
        return this.a = c, i;
      c < r ? (o = 1 ^ i, s.switchFlag === 1 && (i = o), a = s.nlps) : (o = i, a = s.nmps);
    }
    do
      this.ct === 0 && this.byteIn(), c <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
    while ((c & 32768) === 0);
    return this.a = c, e[n] = a << 1 | i, o;
  }
}
class xt extends cn {
  constructor(e) {
    super(e, "Jbig2Error");
  }
}
class gu {
  getContexts(e) {
    return e in this ? this[e] : this[e] = new Int8Array(65536);
  }
}
class Yi {
  constructor(e, n, a) {
    this.data = e, this.start = n, this.end = a;
  }
  get decoder() {
    const e = new xu(this.data, this.start, this.end);
    return ae(this, "decoder", e);
  }
  get contextCache() {
    const e = new gu();
    return ae(this, "contextCache", e);
  }
}
function Jt(t, e, n) {
  const a = t.getContexts(e);
  let i = 1;
  function s(l) {
    let h = 0;
    for (let f = 0; f < l; f++) {
      const d = n.readBit(a, i);
      i = i < 256 ? i << 1 | d : (i << 1 | d) & 511 | 256, h = h << 1 | d;
    }
    return h >>> 0;
  }
  const r = s(1), o = s(1) ? s(1) ? s(1) ? s(1) ? s(1) ? s(32) + 4436 : s(12) + 340 : s(8) + 84 : s(6) + 20 : s(4) + 4 : s(2);
  let c;
  return r === 0 ? c = o : o > 0 && (c = -o), c >= cf && c <= J0 ? c : null;
}
function k1(t, e, n) {
  const a = t.getContexts("IAID");
  let i = 1;
  for (let s = 0; s < n; s++) {
    const r = e.readBit(a, i);
    i = i << 1 | r;
  }
  return n < 31 ? i & (1 << n) - 1 : i & 2147483647;
}
const Lc = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], pu = [[{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: 2,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -3,
  y: -1
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}]], Uc = [{
  coding: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: -1,
    y: 1
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}, {
  coding: [{
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}], mu = [39717, 1941, 229, 405];
function bu(t, e, n) {
  const a = n.decoder, i = n.contextCache.getContexts("GB"), s = [];
  let r, o, c, l, h, f, d;
  const u = 31735;
  for (o = 0; o < e; o++)
    for (h = s[o] = new Uint8Array(t), f = o < 1 ? h : s[o - 1], d = o < 2 ? h : s[o - 2], r = d[0] << 13 | d[1] << 12 | d[2] << 11 | f[0] << 7 | f[1] << 6 | f[2] << 5 | f[3] << 4, c = 0; c < t; c++)
      h[c] = l = a.readBit(i, r), r = (r & u) << 1 | (c + 3 < t ? d[c + 3] << 11 : 0) | (c + 4 < t ? f[c + 4] << 4 : 0) | l;
  return s;
}
function r0(t, e, n, a, i, s, r, o) {
  if (t) {
    const ye = new Os(o.data, o.start, o.end);
    return Lo(ye, e, n, !1);
  }
  if (a === 0 && !i && r.length === 4 && r[0].x === 3 && r[0].y === -1 && r[1].x === -3 && r[1].y === -1 && r[2].x === 2 && r[2].y === -2 && r[3].x === -2 && r[3].y === -2)
    return bu(e, n, o);
  const c = pu[a].concat(r);
  c.sort((ye, we) => ye.y - we.y || ye.x - we.x);
  const l = c.length, h = new Int8Array(l), f = new Int8Array(l), d = [];
  let u = 0, x = 0, g = 0, p = 0, m, b;
  for (b = 0; b < l; b++)
    h[b] = c[b].x, f[b] = c[b].y, x = Math.min(x, c[b].x), g = Math.max(g, c[b].x), p = Math.min(p, c[b].y), b < l - 1 && c[b].y === c[b + 1].y && c[b].x === c[b + 1].x - 1 ? u |= 1 << l - 1 - b : d.push(b);
  const y = d.length, w = new Int8Array(y), S = new Int8Array(y), v = new Uint16Array(y);
  for (m = 0; m < y; m++)
    b = d[m], w[m] = c[b].x, S[m] = c[b].y, v[m] = 1 << l - 1 - b;
  const k = -x, A = -p, C = e - g, T = mu[a];
  let M = new Uint8Array(e);
  const O = [], N = o.decoder, H = o.contextCache.getContexts("GB");
  let J = 0, U, j, P, K = 0, xe, X;
  for (let ye = 0; ye < n; ye++) {
    if (i) {
      const we = N.readBit(H, T);
      if (J ^= we, J) {
        O.push(M);
        continue;
      }
    }
    for (M = new Uint8Array(M), O.push(M), U = 0; U < e; U++) {
      if (U >= k && U < C && ye >= A)
        for (K = K << 1 & u, b = 0; b < y; b++)
          j = ye + S[b], P = U + w[b], xe = O[j][P], xe && (xe = v[b], K |= xe);
      else
        for (K = 0, X = l - 1, b = 0; b < l; b++, X--)
          P = U + h[b], P >= 0 && P < e && (j = ye + f[b], j >= 0 && (xe = O[j][P], xe && (K |= xe << X)));
      const we = N.readBit(H, K);
      M[U] = we;
    }
  }
  return O;
}
function A1(t, e, n, a, i, s, r, o, c) {
  let l = Uc[n].coding;
  n === 0 && (l = l.concat([o[0]]));
  const h = l.length, f = new Int32Array(h), d = new Int32Array(h);
  let u;
  for (u = 0; u < h; u++)
    f[u] = l[u].x, d[u] = l[u].y;
  let x = Uc[n].reference;
  n === 0 && (x = x.concat([o[1]]));
  const g = x.length, p = new Int32Array(g), m = new Int32Array(g);
  for (u = 0; u < g; u++)
    p[u] = x[u].x, m[u] = x[u].y;
  const b = a[0].length, y = a.length, w = [], S = c.decoder, v = c.contextCache.getContexts("GR");
  for (let k = 0; k < e; k++) {
    const A = new Uint8Array(t);
    w.push(A);
    for (let C = 0; C < t; C++) {
      let T, M, O = 0;
      for (u = 0; u < h; u++)
        T = k + d[u], M = C + f[u], T < 0 || M < 0 || M >= t ? O <<= 1 : O = O << 1 | w[T][M];
      for (u = 0; u < g; u++)
        T = k + m[u] - s, M = C + p[u] - i, T < 0 || T >= y || M < 0 || M >= b ? O <<= 1 : O = O << 1 | a[T][M];
      const N = S.readBit(v, O);
      A[C] = N;
    }
  }
  return w;
}
function yu(t, e, n, a, i, s, r, o, c, l, h, f) {
  if (t && e)
    throw new xt("symbol refinement with Huffman is not supported");
  const d = [];
  let u = 0, x = Po(n.length + a);
  const g = h.decoder, p = h.contextCache;
  let m, b;
  for (t && (m = Oa(1), b = [], x = Math.max(x, 1)); d.length < a; ) {
    const C = t ? s.tableDeltaHeight.decode(f) : Jt(p, "IADH", g);
    u += C;
    let T = 0, M = 0;
    const O = t ? b.length : 0;
    for (; ; ) {
      const N = t ? s.tableDeltaWidth.decode(f) : Jt(p, "IADW", g);
      if (N === null)
        break;
      T += N, M += T;
      let H;
      if (e) {
        const J = Jt(p, "IAAI", g);
        if (J > 1)
          H = C1(t, e, T, u, 0, J, 1, n.concat(d), x, 0, 0, 1, 0, s, c, l, h, 0, f);
        else {
          const U = k1(p, g, x), j = Jt(p, "IARDX", g), P = Jt(p, "IARDY", g), K = U < n.length ? n[U] : d[U - n.length];
          H = A1(T, u, c, K, j, P, !1, l, h);
        }
        d.push(H);
      } else t ? b.push(T) : (H = r0(!1, T, u, r, !1, null, o, h), d.push(H));
    }
    if (t && !e) {
      const N = s.tableBitmapSize.decode(f);
      f.byteAlign();
      let H;
      if (N === 0)
        H = Ou(f, M, u);
      else {
        const U = f.end, j = f.position + N;
        f.end = j, H = Lo(f, M, u, !1), f.end = U, f.position = j;
      }
      const J = b.length;
      if (O === J - 1)
        d.push(H);
      else {
        let U, j, P = 0, K, xe, X;
        for (U = O; U < J; U++) {
          for (xe = b[U], K = P + xe, X = [], j = 0; j < u; j++)
            X.push(H[j].subarray(P, K));
          d.push(X), P = K;
        }
      }
    }
  }
  const y = [], w = [];
  let S = !1, v, k;
  const A = n.length + a;
  for (; w.length < A; ) {
    let C = t ? m.decode(f) : Jt(p, "IAEX", g);
    for (; C--; )
      w.push(S);
    S = !S;
  }
  for (v = 0, k = n.length; v < k; v++)
    w[v] && y.push(n[v]);
  for (let C = 0; C < a; v++, C++)
    w[v] && y.push(d[C]);
  return y;
}
function C1(t, e, n, a, i, s, r, o, c, l, h, f, d, u, x, g, p, m, b) {
  if (t && e)
    throw new xt("refinement with Huffman is not supported");
  const y = [];
  let w, S;
  for (w = 0; w < a; w++)
    S = new Uint8Array(n), i && S.fill(i), y.push(S);
  const v = p.decoder, k = p.contextCache;
  let A = t ? -u.tableDeltaT.decode(b) : -Jt(k, "IADT", v), C = 0;
  for (w = 0; w < s; ) {
    const T = t ? u.tableDeltaT.decode(b) : Jt(k, "IADT", v);
    A += T;
    const M = t ? u.tableFirstS.decode(b) : Jt(k, "IAFS", v);
    C += M;
    let O = C;
    do {
      let N = 0;
      r > 1 && (N = t ? b.readBits(m) : Jt(k, "IAIT", v));
      const H = r * A + N, J = t ? u.symbolIDTable.decode(b) : k1(k, v, c), U = e && (t ? b.readBit() : Jt(k, "IARI", v));
      let j = o[J], P = j[0].length, K = j.length;
      if (U) {
        const L = Jt(k, "IARDW", v), V = Jt(k, "IARDH", v), he = Jt(k, "IARDX", v), te = Jt(k, "IARDY", v);
        P += L, K += V, j = A1(P, K, x, j, (L >> 1) + he, (V >> 1) + te, !1, g, p);
      }
      let xe = 0;
      l ? f & 1 ? xe = K - 1 : O += K - 1 : f > 1 ? O += P - 1 : xe = P - 1;
      const X = H - (f & 1 ? 0 : K - 1), ye = O - (f & 2 ? P - 1 : 0);
      let we, D, G;
      if (l)
        for (we = 0; we < K; we++) {
          if (S = y[ye + we], !S)
            continue;
          G = j[we];
          const L = Math.min(n - X, P);
          switch (d) {
            case 0:
              for (D = 0; D < L; D++)
                S[X + D] |= G[D];
              break;
            case 2:
              for (D = 0; D < L; D++)
                S[X + D] ^= G[D];
              break;
            default:
              throw new xt(`operator ${d} is not supported`);
          }
        }
      else
        for (D = 0; D < K; D++)
          if (S = y[X + D], !!S)
            switch (G = j[D], d) {
              case 0:
                for (we = 0; we < P; we++)
                  S[ye + we] |= G[we];
                break;
              case 2:
                for (we = 0; we < P; we++)
                  S[ye + we] ^= G[we];
                break;
              default:
                throw new xt(`operator ${d} is not supported`);
            }
      w++;
      const R = t ? u.tableDeltaS.decode(b) : Jt(k, "IADS", v);
      if (R === null)
        break;
      O += xe + R + h;
    } while (!0);
  }
  return y;
}
function wu(t, e, n, a, i, s) {
  const r = [];
  t || (r.push({
    x: -e,
    y: 0
  }), i === 0 && r.push({
    x: -3,
    y: -1
  }, {
    x: 2,
    y: -2
  }, {
    x: -2,
    y: -2
  }));
  const o = (a + 1) * e, c = r0(t, o, n, i, !1, null, r, s), l = [];
  for (let h = 0; h <= a; h++) {
    const f = [], d = e * h, u = d + e;
    for (let x = 0; x < n; x++)
      f.push(c[x].subarray(d, u));
    l.push(f);
  }
  return l;
}
function vu(t, e, n, a, i, s, r, o, c, l, h, f, d, u, x) {
  if (r)
    throw new xt("skip is not supported");
  if (o !== 0)
    throw new xt(`operator "${o}" is not supported in halftone region`);
  const p = [];
  let m, b, y;
  for (m = 0; m < i; m++)
    y = new Uint8Array(a), s && y.fill(s), p.push(y);
  const w = e.length, S = e[0], v = S[0].length, k = S.length, A = Po(w), C = [];
  t || (C.push({
    x: n <= 1 ? 3 : 2,
    y: -1
  }), n === 0 && C.push({
    x: -3,
    y: -1
  }, {
    x: 2,
    y: -2
  }, {
    x: -2,
    y: -2
  }));
  const T = [];
  let M, O;
  for (t && (M = new Os(x.data, x.start, x.end)), m = A - 1; m >= 0; m--)
    t ? O = Lo(M, c, l, !0) : O = r0(!1, c, l, n, !1, null, C, x), T[m] = O;
  let N, H, J, U, j, P, K, xe, X;
  for (N = 0; N < l; N++)
    for (H = 0; H < c; H++) {
      for (J = 0, U = 0, b = A - 1; b >= 0; b--)
        J ^= T[b][N][H], U |= J << b;
      if (j = e[U], P = h + N * u + H * d >> 8, K = f + N * d - H * u >> 8, P >= 0 && P + v <= a && K >= 0 && K + k <= i)
        for (m = 0; m < k; m++)
          for (X = p[K + m], xe = j[m], b = 0; b < v; b++)
            X[P + b] |= xe[b];
      else {
        let ye, we;
        for (m = 0; m < k; m++)
          if (we = K + m, !(we < 0 || we >= i))
            for (X = p[we], xe = j[m], b = 0; b < v; b++)
              ye = P + b, ye >= 0 && ye < a && (X[ye] |= xe[b]);
      }
    }
  return p;
}
function Su(t, e) {
  const n = {};
  n.number = nt(t, e);
  const a = t[e + 4], i = a & 63;
  if (!Lc[i])
    throw new xt("invalid segment type: " + i);
  n.type = i, n.typeName = Lc[i], n.deferredNonRetain = !!(a & 128);
  const s = !!(a & 64), r = t[e + 5];
  let o = r >> 5 & 7;
  const c = [r & 31];
  let l = e + 6;
  if (r === 7) {
    o = nt(t, l - 1) & 536870911, l += 3;
    let x = o + 7 >> 3;
    for (c[0] = t[l++]; --x > 0; )
      c.push(t[l++]);
  } else if (r === 5 || r === 6)
    throw new xt("invalid referred-to flags");
  n.retainBits = c;
  let h = 4;
  n.number <= 256 ? h = 1 : n.number <= 65536 && (h = 2);
  const f = [];
  let d, u;
  for (d = 0; d < o; d++) {
    let x;
    h === 1 ? x = t[l] : h === 2 ? x = Ge(t, l) : x = nt(t, l), f.push(x), l += h;
  }
  if (n.referredTo = f, s ? (n.pageAssociation = nt(t, l), l += 4) : n.pageAssociation = t[l++], n.length = nt(t, l), l += 4, n.length === 4294967295)
    if (i === 38) {
      const x = Er(t, l), p = !!(t[l + Fr] & 1), m = 6, b = new Uint8Array(m);
      for (p || (b[0] = 255, b[1] = 172), b[2] = x.height >>> 24 & 255, b[3] = x.height >> 16 & 255, b[4] = x.height >> 8 & 255, b[5] = x.height & 255, d = l, u = t.length; d < u; d++) {
        let y = 0;
        for (; y < m && b[y] === t[d + y]; )
          y++;
        if (y === m) {
          n.length = d + m;
          break;
        }
      }
      if (n.length === 4294967295)
        throw new xt("segment end was not found");
    } else
      throw new xt("invalid unknown segment length");
  return n.headerEnd = l, n;
}
function ku(t, e, n, a) {
  const i = [];
  let s = n;
  for (; s < a; ) {
    const r = Su(e, s);
    s = r.headerEnd;
    const o = {
      header: r,
      data: e
    };
    if (t.randomAccess || (o.start = s, s += r.length, o.end = s), i.push(o), r.type === 51)
      break;
  }
  if (t.randomAccess)
    for (let r = 0, o = i.length; r < o; r++)
      i[r].start = s, s += i[r].header.length, i[r].end = s;
  return i;
}
function Er(t, e) {
  return {
    width: nt(t, e),
    height: nt(t, e + 4),
    x: nt(t, e + 8),
    y: nt(t, e + 12),
    combinationOperator: t[e + 16] & 7
  };
}
const Fr = 17;
function Au(t, e) {
  const n = t.header, a = t.data, i = t.end;
  let s = t.start, r, o, c, l;
  switch (n.type) {
    case 0:
      const f = {}, d = Ge(a, s);
      if (f.huffman = !!(d & 1), f.refinement = !!(d & 2), f.huffmanDHSelector = d >> 2 & 3, f.huffmanDWSelector = d >> 4 & 3, f.bitmapSizeSelector = d >> 6 & 1, f.aggregationInstancesSelector = d >> 7 & 1, f.bitmapCodingContextUsed = !!(d & 256), f.bitmapCodingContextRetained = !!(d & 512), f.template = d >> 10 & 3, f.refinementTemplate = d >> 12 & 1, s += 2, !f.huffman) {
        for (l = f.template === 0 ? 4 : 1, o = [], c = 0; c < l; c++)
          o.push({
            x: Kn(a, s),
            y: Kn(a, s + 1)
          }), s += 2;
        f.at = o;
      }
      if (f.refinement && !f.refinementTemplate) {
        for (o = [], c = 0; c < 2; c++)
          o.push({
            x: Kn(a, s),
            y: Kn(a, s + 1)
          }), s += 2;
        f.refinementAt = o;
      }
      f.numberOfExportedSymbols = nt(a, s), s += 4, f.numberOfNewSymbols = nt(a, s), s += 4, r = [f, n.number, n.referredTo, a, s, i];
      break;
    case 6:
    case 7:
      const u = {};
      u.info = Er(a, s), s += Fr;
      const x = Ge(a, s);
      if (s += 2, u.huffman = !!(x & 1), u.refinement = !!(x & 2), u.logStripSize = x >> 2 & 3, u.stripSize = 1 << u.logStripSize, u.referenceCorner = x >> 4 & 3, u.transposed = !!(x & 64), u.combinationOperator = x >> 7 & 3, u.defaultPixelValue = x >> 9 & 1, u.dsOffset = x << 17 >> 27, u.refinementTemplate = x >> 15 & 1, u.huffman) {
        const k = Ge(a, s);
        s += 2, u.huffmanFS = k & 3, u.huffmanDS = k >> 2 & 3, u.huffmanDT = k >> 4 & 3, u.huffmanRefinementDW = k >> 6 & 3, u.huffmanRefinementDH = k >> 8 & 3, u.huffmanRefinementDX = k >> 10 & 3, u.huffmanRefinementDY = k >> 12 & 3, u.huffmanRefinementSizeSelector = !!(k & 16384);
      }
      if (u.refinement && !u.refinementTemplate) {
        for (o = [], c = 0; c < 2; c++)
          o.push({
            x: Kn(a, s),
            y: Kn(a, s + 1)
          }), s += 2;
        u.refinementAt = o;
      }
      u.numberOfSymbolInstances = nt(a, s), s += 4, r = [u, n.referredTo, a, s, i];
      break;
    case 16:
      const g = {}, p = a[s++];
      g.mmr = !!(p & 1), g.template = p >> 1 & 3, g.patternWidth = a[s++], g.patternHeight = a[s++], g.maxPatternIndex = nt(a, s), s += 4, r = [g, n.number, a, s, i];
      break;
    case 22:
    case 23:
      const m = {};
      m.info = Er(a, s), s += Fr;
      const b = a[s++];
      m.mmr = !!(b & 1), m.template = b >> 1 & 3, m.enableSkip = !!(b & 8), m.combinationOperator = b >> 4 & 7, m.defaultPixelValue = b >> 7 & 1, m.gridWidth = nt(a, s), s += 4, m.gridHeight = nt(a, s), s += 4, m.gridOffsetX = nt(a, s) & 4294967295, s += 4, m.gridOffsetY = nt(a, s) & 4294967295, s += 4, m.gridVectorX = Ge(a, s), s += 2, m.gridVectorY = Ge(a, s), s += 2, r = [m, n.referredTo, a, s, i];
      break;
    case 38:
    case 39:
      const y = {};
      y.info = Er(a, s), s += Fr;
      const w = a[s++];
      if (y.mmr = !!(w & 1), y.template = w >> 1 & 3, y.prediction = !!(w & 8), !y.mmr) {
        for (l = y.template === 0 ? 4 : 1, o = [], c = 0; c < l; c++)
          o.push({
            x: Kn(a, s),
            y: Kn(a, s + 1)
          }), s += 2;
        y.at = o;
      }
      r = [y, a, s, i];
      break;
    case 48:
      const S = {
        width: nt(a, s),
        height: nt(a, s + 4),
        resolutionX: nt(a, s + 8),
        resolutionY: nt(a, s + 12)
      };
      S.height === 4294967295 && delete S.height;
      const v = a[s + 16];
      Ge(a, s + 17), S.lossless = !!(v & 1), S.refinement = !!(v & 2), S.defaultPixelValue = v >> 2 & 1, S.combinationOperator = v >> 3 & 3, S.requiresBuffer = !!(v & 32), S.combinationOperatorOverride = !!(v & 64), r = [S];
      break;
    case 49:
      break;
    case 50:
      break;
    case 51:
      break;
    case 53:
      r = [n.number, a, s, i];
      break;
    case 62:
      break;
    default:
      throw new xt(`segment type ${n.typeName}(${n.type}) is not implemented`);
  }
  const h = "on" + n.typeName;
  h in e && e[h].apply(e, r);
}
function Cu(t, e) {
  for (let n = 0, a = t.length; n < a; n++)
    Au(t[n], e);
}
function Iu(t) {
  const e = new Tu();
  for (let n = 0, a = t.length; n < a; n++) {
    const i = t[n], s = ku({}, i.data, i.start, i.end);
    Cu(s, e);
  }
  return e.buffer;
}
class Tu {
  onPageInformation(e) {
    this.currentPageInfo = e;
    const n = e.width + 7 >> 3, a = new Uint8ClampedArray(n * e.height);
    e.defaultPixelValue && a.fill(255), this.buffer = a;
  }
  drawBitmap(e, n) {
    const a = this.currentPageInfo, i = e.width, s = e.height, r = a.width + 7 >> 3, o = a.combinationOperatorOverride ? e.combinationOperator : a.combinationOperator, c = this.buffer, l = 128 >> (e.x & 7);
    let h = e.y * r + (e.x >> 3), f, d, u, x;
    switch (o) {
      case 0:
        for (f = 0; f < s; f++) {
          for (u = l, x = h, d = 0; d < i; d++)
            n[f][d] && (c[x] |= u), u >>= 1, u || (u = 128, x++);
          h += r;
        }
        break;
      case 2:
        for (f = 0; f < s; f++) {
          for (u = l, x = h, d = 0; d < i; d++)
            n[f][d] && (c[x] ^= u), u >>= 1, u || (u = 128, x++);
          h += r;
        }
        break;
      default:
        throw new xt(`operator ${o} is not supported`);
    }
  }
  onImmediateGenericRegion(e, n, a, i) {
    const s = e.info, r = new Yi(n, a, i), o = r0(e.mmr, s.width, s.height, e.template, e.prediction, null, e.at, r);
    this.drawBitmap(s, o);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(e, n, a, i, s, r) {
    let o, c;
    e.huffman && (o = Ru(e, a, this.customTables), c = new Os(i, s, r));
    let l = this.symbols;
    l || (this.symbols = l = {});
    const h = [];
    for (const d of a) {
      const u = l[d];
      u && h.push(...u);
    }
    const f = new Yi(i, s, r);
    l[n] = yu(e.huffman, e.refinement, h, e.numberOfNewSymbols, e.numberOfExportedSymbols, o, e.template, e.at, e.refinementTemplate, e.refinementAt, f, c);
  }
  onImmediateTextRegion(e, n, a, i, s) {
    const r = e.info;
    let o, c;
    const l = this.symbols, h = [];
    for (const x of n) {
      const g = l[x];
      g && h.push(...g);
    }
    const f = Po(h.length);
    e.huffman && (c = new Os(a, i, s), o = Fu(e, n, this.customTables, h.length, c));
    const d = new Yi(a, i, s), u = C1(e.huffman, e.refinement, r.width, r.height, e.defaultPixelValue, e.numberOfSymbolInstances, e.stripSize, h, f, e.transposed, e.dsOffset, e.referenceCorner, e.combinationOperator, o, e.refinementTemplate, e.refinementAt, d, e.logStripSize, c);
    this.drawBitmap(r, u);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(e, n, a, i, s) {
    let r = this.patterns;
    r || (this.patterns = r = {});
    const o = new Yi(a, i, s);
    r[n] = wu(e.mmr, e.patternWidth, e.patternHeight, e.maxPatternIndex, e.template, o);
  }
  onImmediateHalftoneRegion(e, n, a, i, s) {
    const r = this.patterns[n[0]], o = e.info, c = new Yi(a, i, s), l = vu(e.mmr, r, e.template, o.width, o.height, e.defaultPixelValue, e.enableSkip, e.combinationOperator, e.gridWidth, e.gridHeight, e.gridOffsetX, e.gridOffsetY, e.gridVectorX, e.gridVectorY, c);
    this.drawBitmap(o, l);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(e, n, a, i) {
    let s = this.customTables;
    s || (this.customTables = s = {}), s[e] = Eu(n, a, i);
  }
}
class Ra {
  constructor(e) {
    e.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = e[0], this.rangeLength = 0, this.prefixCode = e[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = e[0], this.prefixLength = e[1], this.rangeLength = e[2], this.prefixCode = e[3], this.isLowerRange = e[4] === "lower");
  }
}
class jr {
  constructor(e) {
    this.children = [], e ? (this.isLeaf = !0, this.rangeLength = e.rangeLength, this.rangeLow = e.rangeLow, this.isLowerRange = e.isLowerRange, this.isOOB = e.isOOB) : this.isLeaf = !1;
  }
  buildTree(e, n) {
    const a = e.prefixCode >> n & 1;
    if (n <= 0)
      this.children[a] = new jr(e);
    else {
      let i = this.children[a];
      i || (this.children[a] = i = new jr(null)), i.buildTree(e, n - 1);
    }
  }
  decodeNode(e) {
    if (this.isLeaf) {
      if (this.isOOB)
        return null;
      const a = e.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -a : a);
    }
    const n = this.children[e.readBit()];
    if (!n)
      throw new xt("invalid Huffman data");
    return n.decodeNode(e);
  }
}
class Hr {
  constructor(e, n) {
    n || this.assignPrefixCodes(e), this.rootNode = new jr(null);
    for (let a = 0, i = e.length; a < i; a++) {
      const s = e[a];
      s.prefixLength > 0 && this.rootNode.buildTree(s, s.prefixLength - 1);
    }
  }
  decode(e) {
    return this.rootNode.decodeNode(e);
  }
  assignPrefixCodes(e) {
    const n = e.length;
    let a = 0;
    for (let h = 0; h < n; h++)
      a = Math.max(a, e[h].prefixLength);
    const i = new Uint32Array(a + 1);
    for (let h = 0; h < n; h++)
      i[e[h].prefixLength]++;
    let s = 1, r = 0, o, c, l;
    for (i[0] = 0; s <= a; ) {
      for (r = r + i[s - 1] << 1, o = r, c = 0; c < n; )
        l = e[c], l.prefixLength === s && (l.prefixCode = o, o++), c++;
      s++;
    }
  }
}
function Eu(t, e, n) {
  const a = t[e], i = nt(t, e + 1) & 4294967295, s = nt(t, e + 5) & 4294967295, r = new Os(t, e + 9, n), o = (a >> 1 & 7) + 1, c = (a >> 4 & 7) + 1, l = [];
  let h, f, d = i;
  do
    h = r.readBits(o), f = r.readBits(c), l.push(new Ra([d, h, f, 0])), d += 1 << f;
  while (d < s);
  return h = r.readBits(o), l.push(new Ra([i - 1, h, 32, 0, "lower"])), h = r.readBits(o), l.push(new Ra([s, h, 32, 0])), a & 1 && (h = r.readBits(o), l.push(new Ra([h, 0]))), new Hr(l, !1);
}
const jc = {};
function Oa(t) {
  let e = jc[t];
  if (e)
    return e;
  let n;
  switch (t) {
    case 1:
      n = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      n = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      n = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      n = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      n = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      n = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      n = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      n = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      n = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      n = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      n = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      n = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      n = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      n = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      n = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new xt(`standard table B.${t} does not exist`);
  }
  for (let a = 0, i = n.length; a < i; a++)
    n[a] = new Ra(n[a]);
  return e = new Hr(n, !0), jc[t] = e, e;
}
class Os {
  constructor(e, n, a) {
    this.data = e, this.start = n, this.end = a, this.position = n, this.shift = -1, this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end)
        throw new xt("end of data while reading bit");
      this.currentByte = this.data[this.position++], this.shift = 7;
    }
    const e = this.currentByte >> this.shift & 1;
    return this.shift--, e;
  }
  readBits(e) {
    let n = 0, a;
    for (a = e - 1; a >= 0; a--)
      n |= this.readBit() << a;
    return n;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
}
function Qa(t, e, n) {
  let a = 0;
  for (let i = 0, s = e.length; i < s; i++) {
    const r = n[e[i]];
    if (r) {
      if (t === a)
        return r;
      a++;
    }
  }
  throw new xt("can't find custom Huffman table");
}
function Fu(t, e, n, a, i) {
  const s = [];
  for (let d = 0; d <= 34; d++) {
    const u = i.readBits(4);
    s.push(new Ra([d, u, 0, 0]));
  }
  const r = new Hr(s, !1);
  s.length = 0;
  for (let d = 0; d < a; ) {
    const u = r.decode(i);
    if (u >= 32) {
      let x, g, p;
      switch (u) {
        case 32:
          if (d === 0)
            throw new xt("no previous value in symbol ID table");
          g = i.readBits(2) + 3, x = s[d - 1].prefixLength;
          break;
        case 33:
          g = i.readBits(3) + 3, x = 0;
          break;
        case 34:
          g = i.readBits(7) + 11, x = 0;
          break;
        default:
          throw new xt("invalid code length in symbol ID table");
      }
      for (p = 0; p < g; p++)
        s.push(new Ra([d, x, 0, 0])), d++;
    } else
      s.push(new Ra([d, u, 0, 0])), d++;
  }
  i.byteAlign();
  const o = new Hr(s, !1);
  let c = 0, l, h, f;
  switch (t.huffmanFS) {
    case 0:
    case 1:
      l = Oa(t.huffmanFS + 6);
      break;
    case 3:
      l = Qa(c, e, n), c++;
      break;
    default:
      throw new xt("invalid Huffman FS selector");
  }
  switch (t.huffmanDS) {
    case 0:
    case 1:
    case 2:
      h = Oa(t.huffmanDS + 8);
      break;
    case 3:
      h = Qa(c, e, n), c++;
      break;
    default:
      throw new xt("invalid Huffman DS selector");
  }
  switch (t.huffmanDT) {
    case 0:
    case 1:
    case 2:
      f = Oa(t.huffmanDT + 11);
      break;
    case 3:
      f = Qa(c, e, n), c++;
      break;
    default:
      throw new xt("invalid Huffman DT selector");
  }
  if (t.refinement)
    throw new xt("refinement with Huffman is not supported");
  return {
    symbolIDTable: o,
    tableFirstS: l,
    tableDeltaS: h,
    tableDeltaT: f
  };
}
function Ru(t, e, n) {
  let a = 0, i, s;
  switch (t.huffmanDHSelector) {
    case 0:
    case 1:
      i = Oa(t.huffmanDHSelector + 4);
      break;
    case 3:
      i = Qa(a, e, n), a++;
      break;
    default:
      throw new xt("invalid Huffman DH selector");
  }
  switch (t.huffmanDWSelector) {
    case 0:
    case 1:
      s = Oa(t.huffmanDWSelector + 2);
      break;
    case 3:
      s = Qa(a, e, n), a++;
      break;
    default:
      throw new xt("invalid Huffman DW selector");
  }
  let r, o;
  return t.bitmapSizeSelector ? (r = Qa(a, e, n), a++) : r = Oa(1), t.aggregationInstancesSelector ? o = Qa(a, e, n) : o = Oa(1), {
    tableDeltaHeight: i,
    tableDeltaWidth: s,
    tableBitmapSize: r,
    tableAggregateInstances: o
  };
}
function Ou(t, e, n) {
  const a = [];
  for (let i = 0; i < n; i++) {
    const s = new Uint8Array(e);
    a.push(s);
    for (let r = 0; r < e; r++)
      s[r] = t.readBit();
    t.byteAlign();
  }
  return a;
}
function Lo(t, e, n, a) {
  const i = {
    K: -1,
    Columns: e,
    Rows: n,
    BlackIs1: !0,
    EndOfBlock: a
  }, s = new S1(t, i), r = [];
  let o, c = !1;
  for (let l = 0; l < n; l++) {
    const h = new Uint8Array(e);
    r.push(h);
    let f = -1;
    for (let d = 0; d < e; d++)
      f < 0 && (o = s.readNextChar(), o === -1 && (o = 0, c = !0), f = 7), h[d] = o >> f & 1, f--;
  }
  if (a && !c)
    for (let h = 0; h < 5 && s.readNextChar() !== -1; h++)
      ;
  return r;
}
class Bu {
  parseChunks(e) {
    return Iu(e);
  }
  parse(e) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
}
class Mu extends on {
  constructor(e, n, a) {
    super(n), this.stream = e, this.dict = e.dict, this.maybeLength = n, this.params = a;
  }
  get bytes() {
    return ae(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(e) {
    if (this.eof)
      return this.buffer;
    e ||= this.bytes;
    const n = new Bu(), a = [];
    if (this.params instanceof B) {
      const r = this.params.get("JBIG2Globals");
      if (r instanceof Ne) {
        const o = r.getBytes();
        a.push({
          data: o,
          start: 0,
          end: o.length
        });
      }
    }
    a.push({
      data: e,
      start: 0,
      end: e.length
    });
    const i = n.parseChunks(a), s = i.length;
    for (let r = 0; r < s; r++)
      i[r] ^= 255;
    return this.buffer = i, this.bufferLength = s, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class Pu extends on {
  constructor(e, n, a) {
    super(n), this.stream = e, this.dict = e.dict, this.maybeLength = n, this.params = a;
  }
  get bytes() {
    return ae(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e) {
  }
  readBlock(e) {
    _e("JpxStream.readBlock");
  }
  get isAsyncDecoder() {
    return !0;
  }
  async decodeImage(e, n) {
    return this.eof ? this.buffer : (e ||= this.bytes, this.buffer = await s0.decode(e, n), this.bufferLength = this.buffer.length, this.eof = !0, this.buffer);
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class Hc extends on {
  constructor(e, n, a) {
    super(n), this.str = e, this.dict = e.dict, this.cachedData = 0, this.bitsCached = 0;
    const i = 4096, s = {
      earlyChange: a,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(i),
      dictionaryLengths: new Uint16Array(i),
      dictionaryPrevCodes: new Uint16Array(i),
      currentSequence: new Uint8Array(i),
      currentSequenceLength: 0
    };
    for (let r = 0; r < 256; ++r)
      s.dictionaryValues[r] = r, s.dictionaryLengths[r] = 1;
    this.lzwState = s;
  }
  readBits(e) {
    let n = this.bitsCached, a = this.cachedData;
    for (; n < e; ) {
      const i = this.str.getByte();
      if (i === -1)
        return this.eof = !0, null;
      a = a << 8 | i, n += 8;
    }
    return this.bitsCached = n -= e, this.cachedData = a, this.lastCode = null, a >>> n & (1 << e) - 1;
  }
  readBlock() {
    let a = 1024, i, s, r;
    const o = this.lzwState;
    if (!o)
      return;
    const c = o.earlyChange;
    let l = o.nextCode;
    const h = o.dictionaryValues, f = o.dictionaryLengths, d = o.dictionaryPrevCodes;
    let u = o.codeLength, x = o.prevCode;
    const g = o.currentSequence;
    let p = o.currentSequenceLength, m = 0, b = this.bufferLength, y = this.ensureBuffer(this.bufferLength + a);
    for (i = 0; i < 512; i++) {
      const w = this.readBits(u), S = p > 0;
      if (w < 256)
        g[0] = w, p = 1;
      else if (w >= 258)
        if (w < l)
          for (p = f[w], s = p - 1, r = w; s >= 0; s--)
            g[s] = h[r], r = d[r];
        else
          g[p++] = g[0];
      else if (w === 256) {
        u = 9, l = 258, p = 0;
        continue;
      } else {
        this.eof = !0, delete this.lzwState;
        break;
      }
      if (S && (d[l] = x, f[l] = f[x] + 1, h[l] = g[0], l++, u = l + c & l + c - 1 ? u : Math.min(Math.log(l + c) / 0.6931471805599453 + 1, 12) | 0), x = w, m += p, a < m) {
        do
          a += 512;
        while (a < m);
        y = this.ensureBuffer(this.bufferLength + a);
      }
      for (s = 0; s < p; s++)
        y[b++] = g[s];
    }
    o.nextCode = l, o.codeLength = u, o.prevCode = x, o.currentSequenceLength = p, this.bufferLength = b;
  }
}
class $c extends on {
  constructor(e, n, a) {
    if (super(n), !(a instanceof B))
      return e;
    const i = this.predictor = a.get("Predictor") || 1;
    if (i <= 1)
      return e;
    if (i !== 2 && (i < 10 || i > 15))
      throw new W(`Unsupported predictor: ${i}`);
    this.readBlock = i === 2 ? this.readBlockTiff : this.readBlockPng, this.str = e, this.dict = e.dict;
    const s = this.colors = a.get("Colors") || 1, r = this.bits = a.get("BPC", "BitsPerComponent") || 8, o = this.columns = a.get("Columns") || 1;
    return this.pixBytes = s * r + 7 >> 3, this.rowBytes = o * s * r + 7 >> 3, this;
  }
  readBlockTiff() {
    const e = this.rowBytes, n = this.bufferLength, a = this.ensureBuffer(n + e), i = this.bits, s = this.colors, r = this.str.getBytes(e);
    if (this.eof = !r.length, this.eof)
      return;
    let o = 0, c = 0, l = 0, h = 0, f = n, d;
    if (i === 1 && s === 1)
      for (d = 0; d < e; ++d) {
        let u = r[d] ^ o;
        u ^= u >> 1, u ^= u >> 2, u ^= u >> 4, o = (u & 1) << 7, a[f++] = u;
      }
    else if (i === 8) {
      for (d = 0; d < s; ++d)
        a[f++] = r[d];
      for (; d < e; ++d)
        a[f] = a[f - s] + r[d], f++;
    } else if (i === 16) {
      const u = s * 2;
      for (d = 0; d < u; ++d)
        a[f++] = r[d];
      for (; d < e; d += 2) {
        const x = ((r[d] & 255) << 8) + (r[d + 1] & 255) + ((a[f - u] & 255) << 8) + (a[f - u + 1] & 255);
        a[f++] = x >> 8 & 255, a[f++] = x & 255;
      }
    } else {
      const u = new Uint8Array(s + 1), x = (1 << i) - 1;
      let g = 0, p = n;
      const m = this.columns;
      for (d = 0; d < m; ++d)
        for (let b = 0; b < s; ++b)
          l < i && (o = o << 8 | r[g++] & 255, l += 8), u[b] = u[b] + (o >> l - i) & x, l -= i, c = c << i | u[b], h += i, h >= 8 && (a[p++] = c >> h - 8 & 255, h -= 8);
      h > 0 && (a[p++] = (c << 8 - h) + (o & (1 << 8 - h) - 1));
    }
    this.bufferLength += e;
  }
  readBlockPng() {
    const e = this.rowBytes, n = this.pixBytes, a = this.str.getByte(), i = this.str.getBytes(e);
    if (this.eof = !i.length, this.eof)
      return;
    const s = this.bufferLength, r = this.ensureBuffer(s + e);
    let o = r.subarray(s - e, s);
    o.length === 0 && (o = new Uint8Array(e));
    let c, l = s, h, f;
    switch (a) {
      case 0:
        for (c = 0; c < e; ++c)
          r[l++] = i[c];
        break;
      case 1:
        for (c = 0; c < n; ++c)
          r[l++] = i[c];
        for (; c < e; ++c)
          r[l] = r[l - n] + i[c] & 255, l++;
        break;
      case 2:
        for (c = 0; c < e; ++c)
          r[l++] = o[c] + i[c] & 255;
        break;
      case 3:
        for (c = 0; c < n; ++c)
          r[l++] = (o[c] >> 1) + i[c];
        for (; c < e; ++c)
          r[l] = (o[c] + r[l - n] >> 1) + i[c] & 255, l++;
        break;
      case 4:
        for (c = 0; c < n; ++c)
          h = o[c], f = i[c], r[l++] = h + f;
        for (; c < e; ++c) {
          h = o[c];
          const d = o[c - n], u = r[l - n], x = u + h - d;
          let g = x - u;
          g < 0 && (g = -g);
          let p = x - h;
          p < 0 && (p = -p);
          let m = x - d;
          m < 0 && (m = -m), f = i[c], g <= p && g <= m ? r[l++] = u + f : p <= m ? r[l++] = h + f : r[l++] = d + f;
        }
        break;
      default:
        throw new W(`Unsupported predictor: ${a}`);
    }
    this.bufferLength += e;
  }
}
class Nu extends on {
  constructor(e, n) {
    super(n), this.str = e, this.dict = e.dict;
  }
  readBlock() {
    const e = this.str.getBytes(2);
    if (!e || e.length < 2 || e[0] === 128) {
      this.eof = !0;
      return;
    }
    let n, a = this.bufferLength, i = e[0];
    if (i < 128) {
      if (n = this.ensureBuffer(a + i + 1), n[a++] = e[1], i > 0) {
        const s = this.str.getBytes(i);
        n.set(s, a), a += i;
      }
    } else
      i = 257 - i, n = this.ensureBuffer(a + i + 1), n.fill(e[1], a, a + i), a += i;
    this.bufferLength = a;
  }
}
const Du = 1e3;
function Lu(t) {
  const e = [], n = t.length;
  let a = 0;
  for (; a < n - 1; )
    e.push(t[a++] << 8 | t[a++]);
  return a < n && e.push(t[a]), n + "_" + String.fromCharCode.apply(null, e);
}
class ka {
  constructor({
    lexer: e,
    xref: n,
    allowStreams: a = !1,
    recoveryMode: i = !1
  }) {
    this.lexer = e, this.xref = n, this.allowStreams = a, this.recoveryMode = i, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
  }
  shift() {
    this.buf2 instanceof Ct && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
  }
  tryShift() {
    try {
      return this.shift(), !0;
    } catch (e) {
      if (e instanceof ht)
        throw e;
      return !1;
    }
  }
  getObj(e = null) {
    const n = this.buf1;
    if (this.shift(), n instanceof Ct)
      switch (n.cmd) {
        case "BI":
          return this.makeInlineImage(e);
        case "[":
          const a = [];
          for (; !Bt(this.buf1, "]") && this.buf1 !== Dt; )
            a.push(this.getObj(e));
          if (this.buf1 === Dt) {
            if (this.recoveryMode)
              return a;
            throw new eo("End of file inside array.");
          }
          return this.shift(), a;
        case "<<":
          const i = new B(this.xref);
          for (; !Bt(this.buf1, ">>") && this.buf1 !== Dt; ) {
            if (!(this.buf1 instanceof Z)) {
              Ue("Malformed dictionary: key must be a name object"), this.shift();
              continue;
            }
            const s = this.buf1.name;
            if (this.shift(), this.buf1 === Dt)
              break;
            i.set(s, this.getObj(e));
          }
          if (this.buf1 === Dt) {
            if (this.recoveryMode)
              return i;
            throw new eo("End of file inside dictionary.");
          }
          return Bt(this.buf2, "stream") ? this.allowStreams ? this.makeStream(i, e) : i : (this.shift(), i);
        default:
          return n;
      }
    if (Number.isInteger(n)) {
      if (Number.isInteger(this.buf1) && Bt(this.buf2, "R")) {
        const a = le.get(n, this.buf1);
        return this.shift(), this.shift(), a;
      }
      return n;
    }
    return typeof n == "string" && e ? e.decryptString(n) : n;
  }
  findDefaultInlineStreamEnd(e) {
    const {
      knownCommands: c
    } = this.lexer, l = e.pos, h = 15;
    let f = 0, d, u;
    for (; (d = e.getByte()) !== -1; )
      if (f === 0)
        f = d === 69 ? 1 : 0;
      else if (f === 1)
        f = d === 73 ? 2 : 0;
      else if (d === 32 || d === 10 || d === 13) {
        u = e.pos;
        const g = e.peekBytes(h), p = g.length;
        if (p === 0)
          break;
        for (let y = 0; y < p; y++)
          if (d = g[y], !(d === 0 && g[y + 1] !== 0) && d !== 10 && d !== 13 && (d < 32 || d > 127)) {
            f = 0;
            break;
          }
        if (f !== 2)
          continue;
        if (!c) {
          F("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
          continue;
        }
        const m = new Un(new pt(e.peekBytes(5 * h)), c);
        m._hexStringWarn = () => {
        };
        let b = 0;
        for (; ; ) {
          const y = m.getObj();
          if (y === Dt) {
            f = 0;
            break;
          }
          if (y instanceof Ct) {
            const w = c[y.cmd];
            if (w) {
              if (w.variableArgs ? b <= w.numArgs : b === w.numArgs)
                break;
            } else {
              f = 0;
              break;
            }
            b = 0;
            continue;
          }
          b++;
        }
        if (f === 2)
          break;
      } else
        f = 0;
    d === -1 && (F("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), u && (F('... trying to recover by using the last "EI" occurrence.'), e.skip(-(e.pos - u))));
    let x = 4;
    return e.skip(-x), d = e.peekByte(), e.skip(x), An(d) || x--, e.pos - x - l;
  }
  findDCTDecodeInlineStreamEnd(e) {
    const n = e.pos;
    let a = !1, i, s;
    for (; (i = e.getByte()) !== -1; )
      if (i === 255) {
        switch (e.getByte()) {
          case 0:
            break;
          case 255:
            e.skip(-1);
            break;
          case 217:
            a = !0;
            break;
          case 192:
          case 193:
          case 194:
          case 195:
          case 197:
          case 198:
          case 199:
          case 201:
          case 202:
          case 203:
          case 205:
          case 206:
          case 207:
          case 196:
          case 204:
          case 218:
          case 219:
          case 220:
          case 221:
          case 222:
          case 223:
          case 224:
          case 225:
          case 226:
          case 227:
          case 228:
          case 229:
          case 230:
          case 231:
          case 232:
          case 233:
          case 234:
          case 235:
          case 236:
          case 237:
          case 238:
          case 239:
          case 254:
            s = e.getUint16(), s > 2 ? e.skip(s - 2) : e.skip(-2);
            break;
        }
        if (a)
          break;
      }
    const r = e.pos - n;
    return i === -1 ? (F("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), e.skip(-r), this.findDefaultInlineStreamEnd(e)) : (this.inlineStreamSkipEI(e), r);
  }
  findASCII85DecodeInlineStreamEnd(e) {
    const i = e.pos;
    let s;
    for (; (s = e.getByte()) !== -1; )
      if (s === 126) {
        const o = e.pos;
        for (s = e.peekByte(); An(s); )
          e.skip(), s = e.peekByte();
        if (s === 62) {
          e.skip();
          break;
        }
        if (e.pos > o) {
          const c = e.peekBytes(2);
          if (c[0] === 69 && c[1] === 73)
            break;
        }
      }
    const r = e.pos - i;
    return s === -1 ? (F("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), e.skip(-r), this.findDefaultInlineStreamEnd(e)) : (this.inlineStreamSkipEI(e), r);
  }
  findASCIIHexDecodeInlineStreamEnd(e) {
    const a = e.pos;
    let i;
    for (; (i = e.getByte()) !== -1 && i !== 62; )
      ;
    const s = e.pos - a;
    return i === -1 ? (F("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), e.skip(-s), this.findDefaultInlineStreamEnd(e)) : (this.inlineStreamSkipEI(e), s);
  }
  inlineStreamSkipEI(e) {
    let i = 0, s;
    for (; (s = e.getByte()) !== -1; )
      if (i === 0)
        i = s === 69 ? 1 : 0;
      else if (i === 1)
        i = s === 73 ? 2 : 0;
      else if (i === 2)
        break;
  }
  makeInlineImage(e) {
    const n = this.lexer, a = n.stream, i = /* @__PURE__ */ Object.create(null);
    let s;
    for (; !Bt(this.buf1, "ID") && this.buf1 !== Dt; ) {
      if (!(this.buf1 instanceof Z))
        throw new W("Dictionary key must be a name object");
      const u = this.buf1.name;
      if (this.shift(), this.buf1 === Dt)
        break;
      i[u] = this.getObj(e);
    }
    n.beginInlineImagePos !== -1 && (s = a.pos - n.beginInlineImagePos);
    const r = this.xref.fetchIfRef(i.F || i.Filter);
    let o;
    if (r instanceof Z)
      o = r.name;
    else if (Array.isArray(r)) {
      const u = this.xref.fetchIfRef(r[0]);
      u instanceof Z && (o = u.name);
    }
    const c = a.pos;
    let l;
    switch (o) {
      case "DCT":
      case "DCTDecode":
        l = this.findDCTDecodeInlineStreamEnd(a);
        break;
      case "A85":
      case "ASCII85Decode":
        l = this.findASCII85DecodeInlineStreamEnd(a);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        l = this.findASCIIHexDecodeInlineStreamEnd(a);
        break;
      default:
        l = this.findDefaultInlineStreamEnd(a);
    }
    let h;
    if (l < Du && s > 0) {
      const u = a.pos;
      a.pos = n.beginInlineImagePos, h = Lu(a.getBytes(s + l)), a.pos = u;
      const x = this.imageCache[h];
      if (x !== void 0)
        return this.buf2 = Ct.get("EI"), this.shift(), x.reset(), x;
    }
    const f = new B(this.xref);
    for (const u in i)
      f.set(u, i[u]);
    let d = a.makeSubStream(c, l, f);
    return e && (d = e.createStream(d, l)), d = this.filter(d, f, l), d.dict = f, h !== void 0 && (d.cacheKey = `inline_img_${++this._imageId}`, this.imageCache[h] = d), this.buf2 = Ct.get("EI"), this.shift(), d;
  }
  #e(e) {
    const {
      stream: n
    } = this.lexer;
    n.pos = e;
    const a = 2048, i = 9, s = new Uint8Array([101, 110, 100]), r = s.length, o = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], c = i - r;
    for (; n.pos < n.end; ) {
      const l = n.peekBytes(a), h = l.length - i;
      if (h <= 0)
        break;
      let f = 0;
      for (; f < h; ) {
        let d = 0;
        for (; d < r && l[f + d] === s[d]; )
          d++;
        if (d >= r) {
          let u = !1;
          for (const x of o) {
            const g = x.length;
            let p = 0;
            for (; p < g && l[f + d + p] === x[p]; )
              p++;
            if (p >= c) {
              u = !0;
              break;
            }
            if (p >= g) {
              const m = l[f + d + p];
              An(m) && (Ue(`Found "${xn([...s, ...x])}" when searching for endstream command.`), u = !0);
              break;
            }
          }
          if (u)
            return n.pos += f, n.pos - e;
        }
        f++;
      }
      n.pos += h;
    }
    return -1;
  }
  makeStream(e, n) {
    const a = this.lexer;
    let i = a.stream;
    a.skipToNextLine();
    const s = i.pos - 1;
    let r = e.get("Length");
    if (Number.isInteger(r) || (Ue(`Bad length "${r && r.toString()}" in stream.`), r = 0), i.pos = s + r, a.nextChar(), this.tryShift() && Bt(this.buf2, "endstream"))
      this.shift();
    else {
      if (r = this.#e(s), r < 0)
        throw new W("Missing endstream command.");
      a.nextChar(), this.shift(), this.shift();
    }
    return this.shift(), i = i.makeSubStream(s, r, e), n && (i = n.createStream(i, r)), i = this.filter(i, e, r), i.dict = e, i;
  }
  filter(e, n, a) {
    let i = n.get("F", "Filter"), s = n.get("DP", "DecodeParms");
    if (i instanceof Z)
      return Array.isArray(s) && F("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(e, i.name, a, s);
    let r = a;
    if (Array.isArray(i)) {
      const o = i, c = s;
      for (let l = 0, h = o.length; l < h; ++l) {
        if (i = this.xref.fetchIfRef(o[l]), !(i instanceof Z))
          throw new W(`Bad filter name "${i}"`);
        s = null, Array.isArray(c) && l in c && (s = this.xref.fetchIfRef(c[l])), e = this.makeFilter(e, i.name, r, s), r = null;
      }
    }
    return e;
  }
  makeFilter(e, n, a, i) {
    if (a === 0)
      return F(`Empty "${n}" stream.`), new io();
    try {
      switch (n) {
        case "Fl":
        case "FlateDecode":
          return i ? new $c(new Dc(e, a), a, i) : new Dc(e, a);
        case "LZW":
        case "LZWDecode":
          let s = 1;
          return i ? (i.has("EarlyChange") && (s = i.get("EarlyChange")), new $c(new Hc(e, a, s), a, i)) : new Hc(e, a, s);
        case "DCT":
        case "DCTDecode":
          return new Wi(e, a, i);
        case "JPX":
        case "JPXDecode":
          return new Pu(e, a, i);
        case "A85":
        case "ASCII85Decode":
          return new ru(e, a);
        case "AHx":
        case "ASCIIHexDecode":
          return new ou(e, a);
        case "CCF":
        case "CCITTFaxDecode":
          return new cu(e, a, i);
        case "RL":
        case "RunLengthDecode":
          return new Nu(e, a);
        case "JBIG2Decode":
          return new Mu(e, a, i);
      }
      return F(`Filter "${n}" is not supported.`), e;
    } catch (s) {
      if (s instanceof ht)
        throw s;
      return F(`Invalid stream: "${s}"`), new io();
    }
  }
}
const bi = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function C0(t) {
  return t >= 48 && t <= 57 ? t & 15 : t >= 65 && t <= 70 || t >= 97 && t <= 102 ? (t & 15) + 9 : -1;
}
class Un {
  constructor(e, n = null) {
    this.stream = e, this.nextChar(), this.strBuf = [], this.knownCommands = n, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let e = this.currentChar, n = !1, a = 0, i = 1;
    if (e === 45 ? (i = -1, e = this.nextChar(), e === 45 && (e = this.nextChar())) : e === 43 && (e = this.nextChar()), e === 10 || e === 13)
      do
        e = this.nextChar();
      while (e === 10 || e === 13);
    if (e === 46 && (a = 10, e = this.nextChar()), e < 48 || e > 57) {
      const c = `Invalid number: ${String.fromCharCode(e)} (charCode ${e})`;
      if (An(e) || e === 40 || e === 60 || e === -1)
        return Ue(`Lexer.getNumber - "${c}".`), 0;
      throw new W(c);
    }
    let s = e - 48, r = 0, o = 1;
    for (; (e = this.nextChar()) >= 0; )
      if (e >= 48 && e <= 57) {
        const c = e - 48;
        n ? r = r * 10 + c : (a !== 0 && (a *= 10), s = s * 10 + c);
      } else if (e === 46)
        if (a === 0)
          a = 1;
        else
          break;
      else if (e === 45)
        F("Badly formatted number: minus sign in the middle");
      else if (e === 69 || e === 101) {
        if (e = this.peekChar(), e === 43 || e === 45)
          o = e === 45 ? -1 : 1, this.nextChar();
        else if (e < 48 || e > 57)
          break;
        n = !0;
      } else
        break;
    return a !== 0 && (s /= a), n && (s *= 10 ** (o * r)), i * s;
  }
  getString() {
    let e = 1, n = !1;
    const a = this.strBuf;
    a.length = 0;
    let i = this.nextChar();
    for (; ; ) {
      let s = !1;
      switch (i | 0) {
        case -1:
          F("Unterminated string"), n = !0;
          break;
        case 40:
          ++e, a.push("(");
          break;
        case 41:
          --e === 0 ? (this.nextChar(), n = !0) : a.push(")");
          break;
        case 92:
          switch (i = this.nextChar(), i) {
            case -1:
              F("Unterminated string"), n = !0;
              break;
            case 110:
              a.push(`
`);
              break;
            case 114:
              a.push("\r");
              break;
            case 116:
              a.push("	");
              break;
            case 98:
              a.push("\b");
              break;
            case 102:
              a.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              a.push(String.fromCharCode(i));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let r = i & 15;
              i = this.nextChar(), s = !0, i >= 48 && i <= 55 && (r = (r << 3) + (i & 15), i = this.nextChar(), i >= 48 && i <= 55 && (s = !1, r = (r << 3) + (i & 15))), a.push(String.fromCharCode(r));
              break;
            case 13:
              this.peekChar() === 10 && this.nextChar();
              break;
            case 10:
              break;
            default:
              a.push(String.fromCharCode(i));
              break;
          }
          break;
        default:
          a.push(String.fromCharCode(i));
          break;
      }
      if (n)
        break;
      s || (i = this.nextChar());
    }
    return a.join("");
  }
  getName() {
    let e, n;
    const a = this.strBuf;
    for (a.length = 0; (e = this.nextChar()) >= 0 && !bi[e]; )
      if (e === 35) {
        if (e = this.nextChar(), bi[e]) {
          F("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), a.push("#");
          break;
        }
        const i = C0(e);
        if (i !== -1) {
          n = e, e = this.nextChar();
          const s = C0(e);
          if (s === -1) {
            if (F(`Lexer_getName: Illegal digit (${String.fromCharCode(e)}) in hexadecimal number.`), a.push("#", String.fromCharCode(n)), bi[e])
              break;
            a.push(String.fromCharCode(e));
            continue;
          }
          a.push(String.fromCharCode(i << 4 | s));
        } else
          a.push("#", String.fromCharCode(e));
      } else
        a.push(String.fromCharCode(e));
    return a.length > 127 && F(`Name token is longer than allowed by the spec: ${a.length}`), Z.get(a.join(""));
  }
  _hexStringWarn(e) {
    if (this._hexStringNumWarn++ === 5) {
      F("getHexString - ignoring additional invalid characters.");
      return;
    }
    this._hexStringNumWarn > 5 || F(`getHexString - ignoring invalid character: ${e}`);
  }
  getHexString() {
    const e = this.strBuf;
    e.length = 0;
    let n = this.currentChar, a = -1, i = -1;
    for (this._hexStringNumWarn = 0; ; )
      if (n < 0) {
        F("Unterminated hex string");
        break;
      } else if (n === 62) {
        this.nextChar();
        break;
      } else if (bi[n] === 1) {
        n = this.nextChar();
        continue;
      } else
        i = C0(n), i === -1 ? this._hexStringWarn(n) : a === -1 ? a = i : (e.push(String.fromCharCode(a << 4 | i)), a = -1), n = this.nextChar();
    return a !== -1 && e.push(String.fromCharCode(a << 4)), e.join("");
  }
  getObj() {
    let e = !1, n = this.currentChar;
    for (; ; ) {
      if (n < 0)
        return Dt;
      if (e)
        (n === 10 || n === 13) && (e = !1);
      else if (n === 37)
        e = !0;
      else if (bi[n] !== 1)
        break;
      n = this.nextChar();
    }
    switch (n | 0) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        return this.nextChar(), Ct.get("[");
      case 93:
        return this.nextChar(), Ct.get("]");
      case 60:
        return n = this.nextChar(), n === 60 ? (this.nextChar(), Ct.get("<<")) : this.getHexString();
      case 62:
        return n = this.nextChar(), n === 62 ? (this.nextChar(), Ct.get(">>")) : Ct.get(">");
      case 123:
        return this.nextChar(), Ct.get("{");
      case 125:
        return this.nextChar(), Ct.get("}");
      case 41:
        throw this.nextChar(), new W(`Illegal character: ${n}`);
    }
    let a = String.fromCharCode(n);
    if (n < 32 || n > 127) {
      const r = this.peekChar();
      if (r >= 32 && r <= 127)
        return this.nextChar(), Ct.get(a);
    }
    const i = this.knownCommands;
    let s = i?.[a] !== void 0;
    for (; (n = this.nextChar()) >= 0 && !bi[n]; ) {
      const r = a + String.fromCharCode(n);
      if (s && i[r] === void 0)
        break;
      if (a.length === 128)
        throw new W(`Command token too long: ${a.length}`);
      a = r, s = i?.[a] !== void 0;
    }
    return a === "true" ? !0 : a === "false" ? !1 : a === "null" ? null : (a === "BI" && (this.beginInlineImagePos = this.stream.pos), Ct.get(a));
  }
  skipToNextLine() {
    let e = this.currentChar;
    for (; e >= 0; ) {
      if (e === 13) {
        e = this.nextChar(), e === 10 && this.nextChar();
        break;
      } else if (e === 10) {
        this.nextChar();
        break;
      }
      e = this.nextChar();
    }
  }
}
class Uu {
  static create(e) {
    function n(f, d, u = !1) {
      const x = f.get(d);
      if (Number.isInteger(x) && (u ? x >= 0 : x > 0))
        return x;
      throw new Error(`The "${d}" parameter in the linearization dictionary is invalid.`);
    }
    function a(f) {
      const d = f.get("H");
      let u;
      if (Array.isArray(d) && ((u = d.length) === 2 || u === 4)) {
        for (let x = 0; x < u; x++) {
          const g = d[x];
          if (!(Number.isInteger(g) && g > 0))
            throw new Error(`Hint (${x}) in the linearization dictionary is invalid.`);
        }
        return d;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    }
    const i = new ka({
      lexer: new Un(e),
      xref: null
    }), s = i.getObj(), r = i.getObj(), o = i.getObj(), c = i.getObj();
    let l, h;
    if (Number.isInteger(s) && Number.isInteger(r) && Bt(o, "obj") && c instanceof B && typeof (l = c.get("Linearized")) == "number" && l > 0) {
      if ((h = n(c, "L")) !== e.length)
        throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    } else return null;
    return {
      length: h,
      hints: a(c),
      objectNumberFirst: n(c, "O"),
      endFirst: n(c, "E"),
      numPages: n(c, "N"),
      mainXRefEntriesOffset: n(c, "T"),
      pageFirst: c.has("P") ? n(c, "P", !0) : 0
    };
  }
}
const ju = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], I0 = 2 ** 24 - 1;
class Uo {
  constructor(e = !1) {
    this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = e;
  }
  addCodespaceRange(e, n, a) {
    this.codespaceRanges[e - 1].push(n, a), this.numCodespaceRanges++;
  }
  mapCidRange(e, n, a) {
    if (n - e > I0)
      throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; e <= n; )
      this._map[e++] = a++;
  }
  mapBfRange(e, n, a) {
    if (n - e > I0)
      throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const i = a.length - 1;
    for (; e <= n; ) {
      this._map[e++] = a;
      const s = a.charCodeAt(i) + 1;
      if (s > 255) {
        a = a.substring(0, i - 1) + String.fromCharCode(a.charCodeAt(i - 1) + 1) + "\0";
        continue;
      }
      a = a.substring(0, i) + String.fromCharCode(s);
    }
  }
  mapBfRangeToArray(e, n, a) {
    if (n - e > I0)
      throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const i = a.length;
    let s = 0;
    for (; e <= n && s < i; )
      this._map[e] = a[s++], ++e;
  }
  mapOne(e, n) {
    this._map[e] = n;
  }
  lookup(e) {
    return this._map[e];
  }
  contains(e) {
    return this._map[e] !== void 0;
  }
  forEach(e) {
    const n = this._map, a = n.length;
    if (a <= 65536)
      for (let i = 0; i < a; i++)
        n[i] !== void 0 && e(i, n[i]);
    else
      for (const i in n)
        e(i, n[i]);
  }
  charCodeOf(e) {
    const n = this._map;
    if (n.length <= 65536)
      return n.indexOf(e);
    for (const a in n)
      if (n[a] === e)
        return a | 0;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(e, n, a) {
    let i = 0;
    const s = this.codespaceRanges;
    for (let r = 0, o = s.length; r < o; r++) {
      i = (i << 8 | e.charCodeAt(n + r)) >>> 0;
      const c = s[r];
      for (let l = 0, h = c.length; l < h; ) {
        const f = c[l++], d = c[l++];
        if (i >= f && i <= d) {
          a.charcode = i, a.length = r + 1;
          return;
        }
      }
    }
    a.charcode = 0, a.length = 1;
  }
  getCharCodeLength(e) {
    const n = this.codespaceRanges;
    for (let a = 0, i = n.length; a < i; a++) {
      const s = n[a];
      for (let r = 0, o = s.length; r < o; ) {
        const c = s[r++], l = s[r++];
        if (e >= c && e <= l)
          return a + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
      return !1;
    for (let e = 0; e < 65536; e++)
      if (this._map[e] !== e)
        return !1;
    return !0;
  }
}
class Bi extends Uo {
  constructor(e, n) {
    super(), this.vertical = e, this.addCodespaceRange(n, 0, 65535);
  }
  mapCidRange(e, n, a) {
    _e("should not call mapCidRange");
  }
  mapBfRange(e, n, a) {
    _e("should not call mapBfRange");
  }
  mapBfRangeToArray(e, n, a) {
    _e("should not call mapBfRangeToArray");
  }
  mapOne(e, n) {
    _e("should not call mapCidOne");
  }
  lookup(e) {
    return Number.isInteger(e) && e <= 65535 ? e : void 0;
  }
  contains(e) {
    return Number.isInteger(e) && e <= 65535;
  }
  forEach(e) {
    for (let n = 0; n <= 65535; n++)
      e(n, n);
  }
  charCodeOf(e) {
    return Number.isInteger(e) && e <= 65535 ? e : -1;
  }
  getMap() {
    const e = new Array(65536);
    for (let n = 0; n <= 65535; n++)
      e[n] = n;
    return e;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    _e("should not access .isIdentityCMap");
  }
}
function La(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e = e << 8 | t.charCodeAt(n);
  return e >>> 0;
}
function hi(t) {
  if (typeof t != "string")
    throw new W("Malformed CMap: expected string.");
}
function I1(t) {
  if (!Number.isInteger(t))
    throw new W("Malformed CMap: expected int.");
}
function Hu(t, e) {
  for (; ; ) {
    let n = e.getObj();
    if (n === Dt)
      break;
    if (Bt(n, "endbfchar"))
      return;
    hi(n);
    const a = La(n);
    n = e.getObj(), hi(n);
    const i = n;
    t.mapOne(a, i);
  }
}
function $u(t, e) {
  for (; ; ) {
    let n = e.getObj();
    if (n === Dt)
      break;
    if (Bt(n, "endbfrange"))
      return;
    hi(n);
    const a = La(n);
    n = e.getObj(), hi(n);
    const i = La(n);
    if (n = e.getObj(), Number.isInteger(n) || typeof n == "string") {
      const s = Number.isInteger(n) ? String.fromCharCode(n) : n;
      t.mapBfRange(a, i, s);
    } else if (Bt(n, "[")) {
      n = e.getObj();
      const s = [];
      for (; !Bt(n, "]") && n !== Dt; )
        s.push(n), n = e.getObj();
      t.mapBfRangeToArray(a, i, s);
    } else
      break;
  }
  throw new W("Invalid bf range.");
}
function Gu(t, e) {
  for (; ; ) {
    let n = e.getObj();
    if (n === Dt)
      break;
    if (Bt(n, "endcidchar"))
      return;
    hi(n);
    const a = La(n);
    n = e.getObj(), I1(n);
    const i = n;
    t.mapOne(a, i);
  }
}
function zu(t, e) {
  for (; ; ) {
    let n = e.getObj();
    if (n === Dt)
      break;
    if (Bt(n, "endcidrange"))
      return;
    hi(n);
    const a = La(n);
    n = e.getObj(), hi(n);
    const i = La(n);
    n = e.getObj(), I1(n);
    const s = n;
    t.mapCidRange(a, i, s);
  }
}
function _u(t, e) {
  for (; ; ) {
    let n = e.getObj();
    if (n === Dt)
      break;
    if (Bt(n, "endcodespacerange"))
      return;
    if (typeof n != "string")
      break;
    const a = La(n);
    if (n = e.getObj(), typeof n != "string")
      break;
    const i = La(n);
    t.addCodespaceRange(n.length, a, i);
  }
  throw new W("Invalid codespace range.");
}
function Wu(t, e) {
  const n = e.getObj();
  Number.isInteger(n) && (t.vertical = !!n);
}
function Vu(t, e) {
  const n = e.getObj();
  n instanceof Z && (t.name = n.name);
}
async function T1(t, e, n, a) {
  let i, s;
  e: for (; ; )
    try {
      const r = e.getObj();
      if (r === Dt)
        break;
      if (r instanceof Z)
        r.name === "WMode" ? Wu(t, e) : r.name === "CMapName" && Vu(t, e), i = r;
      else if (r instanceof Ct)
        switch (r.cmd) {
          case "endcmap":
            break e;
          case "usecmap":
            i instanceof Z && (s = i.name);
            break;
          case "begincodespacerange":
            _u(t, e);
            break;
          case "beginbfchar":
            Hu(t, e);
            break;
          case "begincidchar":
            Gu(t, e);
            break;
          case "beginbfrange":
            $u(t, e);
            break;
          case "begincidrange":
            zu(t, e);
            break;
        }
    } catch (r) {
      if (r instanceof ht)
        throw r;
      F("Invalid cMap data: " + r);
      continue;
    }
  return !a && s && (a = s), a ? E1(t, n, a) : t;
}
async function E1(t, e, n) {
  if (t.useCMap = await fo(n, e), t.numCodespaceRanges === 0) {
    const a = t.useCMap.codespaceRanges;
    for (let i = 0; i < a.length; i++)
      t.codespaceRanges[i] = a[i].slice();
    t.numCodespaceRanges = t.useCMap.numCodespaceRanges;
  }
  return t.useCMap.forEach(function(a, i) {
    t.contains(a) || t.mapOne(a, i);
  }), t;
}
async function fo(t, e) {
  if (t === "Identity-H")
    return new Bi(!1, 2);
  if (t === "Identity-V")
    return new Bi(!0, 2);
  if (!ju.includes(t))
    throw new Error("Unknown CMap name: " + t);
  if (!e)
    throw new Error("Built-in CMap parameters are not provided.");
  const {
    cMapData: n,
    isCompressed: a
  } = await e(t), i = new Uo(!0);
  if (a)
    return new su().process(n, i, (r) => E1(i, e, r));
  const s = new Un(new pt(n));
  return T1(i, s, e, null);
}
class xr {
  static async create({
    encoding: e,
    fetchBuiltInCMap: n,
    useCMap: a
  }) {
    if (e instanceof Z)
      return fo(e.name, n);
    if (e instanceof Ne) {
      const i = await T1(new Uo(), new Un(e), n, a);
      return i.isIdentityCMap ? fo(i.name, n) : i;
    }
    throw new Error("Encoding required.");
  }
}
const F1 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], Xu = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], jo = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"], xa = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""], Bs = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"], Ho = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""], $o = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function Ms(t) {
  switch (t) {
    case "WinAnsiEncoding":
      return Bs;
    case "StandardEncoding":
      return xa;
    case "MacRomanEncoding":
      return jo;
    case "SymbolSetEncoding":
      return Ho;
    case "ZapfDingbatsEncoding":
      return $o;
    case "ExpertEncoding":
      return F1;
    case "MacExpertEncoding":
      return Xu;
    default:
      return null;
  }
}
const Qn = ut(function(t) {
  t.A = 65, t.AE = 198, t.AEacute = 508, t.AEmacron = 482, t.AEsmall = 63462, t.Aacute = 193, t.Aacutesmall = 63457, t.Abreve = 258, t.Abreveacute = 7854, t.Abrevecyrillic = 1232, t.Abrevedotbelow = 7862, t.Abrevegrave = 7856, t.Abrevehookabove = 7858, t.Abrevetilde = 7860, t.Acaron = 461, t.Acircle = 9398, t.Acircumflex = 194, t.Acircumflexacute = 7844, t.Acircumflexdotbelow = 7852, t.Acircumflexgrave = 7846, t.Acircumflexhookabove = 7848, t.Acircumflexsmall = 63458, t.Acircumflextilde = 7850, t.Acute = 63177, t.Acutesmall = 63412, t.Acyrillic = 1040, t.Adblgrave = 512, t.Adieresis = 196, t.Adieresiscyrillic = 1234, t.Adieresismacron = 478, t.Adieresissmall = 63460, t.Adotbelow = 7840, t.Adotmacron = 480, t.Agrave = 192, t.Agravesmall = 63456, t.Ahookabove = 7842, t.Aiecyrillic = 1236, t.Ainvertedbreve = 514, t.Alpha = 913, t.Alphatonos = 902, t.Amacron = 256, t.Amonospace = 65313, t.Aogonek = 260, t.Aring = 197, t.Aringacute = 506, t.Aringbelow = 7680, t.Aringsmall = 63461, t.Asmall = 63329, t.Atilde = 195, t.Atildesmall = 63459, t.Aybarmenian = 1329, t.B = 66, t.Bcircle = 9399, t.Bdotaccent = 7682, t.Bdotbelow = 7684, t.Becyrillic = 1041, t.Benarmenian = 1330, t.Beta = 914, t.Bhook = 385, t.Blinebelow = 7686, t.Bmonospace = 65314, t.Brevesmall = 63220, t.Bsmall = 63330, t.Btopbar = 386, t.C = 67, t.Caarmenian = 1342, t.Cacute = 262, t.Caron = 63178, t.Caronsmall = 63221, t.Ccaron = 268, t.Ccedilla = 199, t.Ccedillaacute = 7688, t.Ccedillasmall = 63463, t.Ccircle = 9400, t.Ccircumflex = 264, t.Cdot = 266, t.Cdotaccent = 266, t.Cedillasmall = 63416, t.Chaarmenian = 1353, t.Cheabkhasiancyrillic = 1212, t.Checyrillic = 1063, t.Chedescenderabkhasiancyrillic = 1214, t.Chedescendercyrillic = 1206, t.Chedieresiscyrillic = 1268, t.Cheharmenian = 1347, t.Chekhakassiancyrillic = 1227, t.Cheverticalstrokecyrillic = 1208, t.Chi = 935, t.Chook = 391, t.Circumflexsmall = 63222, t.Cmonospace = 65315, t.Coarmenian = 1361, t.Csmall = 63331, t.D = 68, t.DZ = 497, t.DZcaron = 452, t.Daarmenian = 1332, t.Dafrican = 393, t.Dcaron = 270, t.Dcedilla = 7696, t.Dcircle = 9401, t.Dcircumflexbelow = 7698, t.Dcroat = 272, t.Ddotaccent = 7690, t.Ddotbelow = 7692, t.Decyrillic = 1044, t.Deicoptic = 1006, t.Delta = 8710, t.Deltagreek = 916, t.Dhook = 394, t.Dieresis = 63179, t.DieresisAcute = 63180, t.DieresisGrave = 63181, t.Dieresissmall = 63400, t.Digammagreek = 988, t.Djecyrillic = 1026, t.Dlinebelow = 7694, t.Dmonospace = 65316, t.Dotaccentsmall = 63223, t.Dslash = 272, t.Dsmall = 63332, t.Dtopbar = 395, t.Dz = 498, t.Dzcaron = 453, t.Dzeabkhasiancyrillic = 1248, t.Dzecyrillic = 1029, t.Dzhecyrillic = 1039, t.E = 69, t.Eacute = 201, t.Eacutesmall = 63465, t.Ebreve = 276, t.Ecaron = 282, t.Ecedillabreve = 7708, t.Echarmenian = 1333, t.Ecircle = 9402, t.Ecircumflex = 202, t.Ecircumflexacute = 7870, t.Ecircumflexbelow = 7704, t.Ecircumflexdotbelow = 7878, t.Ecircumflexgrave = 7872, t.Ecircumflexhookabove = 7874, t.Ecircumflexsmall = 63466, t.Ecircumflextilde = 7876, t.Ecyrillic = 1028, t.Edblgrave = 516, t.Edieresis = 203, t.Edieresissmall = 63467, t.Edot = 278, t.Edotaccent = 278, t.Edotbelow = 7864, t.Efcyrillic = 1060, t.Egrave = 200, t.Egravesmall = 63464, t.Eharmenian = 1335, t.Ehookabove = 7866, t.Eightroman = 8551, t.Einvertedbreve = 518, t.Eiotifiedcyrillic = 1124, t.Elcyrillic = 1051, t.Elevenroman = 8554, t.Emacron = 274, t.Emacronacute = 7702, t.Emacrongrave = 7700, t.Emcyrillic = 1052, t.Emonospace = 65317, t.Encyrillic = 1053, t.Endescendercyrillic = 1186, t.Eng = 330, t.Enghecyrillic = 1188, t.Enhookcyrillic = 1223, t.Eogonek = 280, t.Eopen = 400, t.Epsilon = 917, t.Epsilontonos = 904, t.Ercyrillic = 1056, t.Ereversed = 398, t.Ereversedcyrillic = 1069, t.Escyrillic = 1057, t.Esdescendercyrillic = 1194, t.Esh = 425, t.Esmall = 63333, t.Eta = 919, t.Etarmenian = 1336, t.Etatonos = 905, t.Eth = 208, t.Ethsmall = 63472, t.Etilde = 7868, t.Etildebelow = 7706, t.Euro = 8364, t.Ezh = 439, t.Ezhcaron = 494, t.Ezhreversed = 440, t.F = 70, t.Fcircle = 9403, t.Fdotaccent = 7710, t.Feharmenian = 1366, t.Feicoptic = 996, t.Fhook = 401, t.Fitacyrillic = 1138, t.Fiveroman = 8548, t.Fmonospace = 65318, t.Fourroman = 8547, t.Fsmall = 63334, t.G = 71, t.GBsquare = 13191, t.Gacute = 500, t.Gamma = 915, t.Gammaafrican = 404, t.Gangiacoptic = 1002, t.Gbreve = 286, t.Gcaron = 486, t.Gcedilla = 290, t.Gcircle = 9404, t.Gcircumflex = 284, t.Gcommaaccent = 290, t.Gdot = 288, t.Gdotaccent = 288, t.Gecyrillic = 1043, t.Ghadarmenian = 1346, t.Ghemiddlehookcyrillic = 1172, t.Ghestrokecyrillic = 1170, t.Gheupturncyrillic = 1168, t.Ghook = 403, t.Gimarmenian = 1331, t.Gjecyrillic = 1027, t.Gmacron = 7712, t.Gmonospace = 65319, t.Grave = 63182, t.Gravesmall = 63328, t.Gsmall = 63335, t.Gsmallhook = 667, t.Gstroke = 484, t.H = 72, t.H18533 = 9679, t.H18543 = 9642, t.H18551 = 9643, t.H22073 = 9633, t.HPsquare = 13259, t.Haabkhasiancyrillic = 1192, t.Hadescendercyrillic = 1202, t.Hardsigncyrillic = 1066, t.Hbar = 294, t.Hbrevebelow = 7722, t.Hcedilla = 7720, t.Hcircle = 9405, t.Hcircumflex = 292, t.Hdieresis = 7718, t.Hdotaccent = 7714, t.Hdotbelow = 7716, t.Hmonospace = 65320, t.Hoarmenian = 1344, t.Horicoptic = 1e3, t.Hsmall = 63336, t.Hungarumlaut = 63183, t.Hungarumlautsmall = 63224, t.Hzsquare = 13200, t.I = 73, t.IAcyrillic = 1071, t.IJ = 306, t.IUcyrillic = 1070, t.Iacute = 205, t.Iacutesmall = 63469, t.Ibreve = 300, t.Icaron = 463, t.Icircle = 9406, t.Icircumflex = 206, t.Icircumflexsmall = 63470, t.Icyrillic = 1030, t.Idblgrave = 520, t.Idieresis = 207, t.Idieresisacute = 7726, t.Idieresiscyrillic = 1252, t.Idieresissmall = 63471, t.Idot = 304, t.Idotaccent = 304, t.Idotbelow = 7882, t.Iebrevecyrillic = 1238, t.Iecyrillic = 1045, t.Ifraktur = 8465, t.Igrave = 204, t.Igravesmall = 63468, t.Ihookabove = 7880, t.Iicyrillic = 1048, t.Iinvertedbreve = 522, t.Iishortcyrillic = 1049, t.Imacron = 298, t.Imacroncyrillic = 1250, t.Imonospace = 65321, t.Iniarmenian = 1339, t.Iocyrillic = 1025, t.Iogonek = 302, t.Iota = 921, t.Iotaafrican = 406, t.Iotadieresis = 938, t.Iotatonos = 906, t.Ismall = 63337, t.Istroke = 407, t.Itilde = 296, t.Itildebelow = 7724, t.Izhitsacyrillic = 1140, t.Izhitsadblgravecyrillic = 1142, t.J = 74, t.Jaarmenian = 1345, t.Jcircle = 9407, t.Jcircumflex = 308, t.Jecyrillic = 1032, t.Jheharmenian = 1355, t.Jmonospace = 65322, t.Jsmall = 63338, t.K = 75, t.KBsquare = 13189, t.KKsquare = 13261, t.Kabashkircyrillic = 1184, t.Kacute = 7728, t.Kacyrillic = 1050, t.Kadescendercyrillic = 1178, t.Kahookcyrillic = 1219, t.Kappa = 922, t.Kastrokecyrillic = 1182, t.Kaverticalstrokecyrillic = 1180, t.Kcaron = 488, t.Kcedilla = 310, t.Kcircle = 9408, t.Kcommaaccent = 310, t.Kdotbelow = 7730, t.Keharmenian = 1364, t.Kenarmenian = 1343, t.Khacyrillic = 1061, t.Kheicoptic = 998, t.Khook = 408, t.Kjecyrillic = 1036, t.Klinebelow = 7732, t.Kmonospace = 65323, t.Koppacyrillic = 1152, t.Koppagreek = 990, t.Ksicyrillic = 1134, t.Ksmall = 63339, t.L = 76, t.LJ = 455, t.LL = 63167, t.Lacute = 313, t.Lambda = 923, t.Lcaron = 317, t.Lcedilla = 315, t.Lcircle = 9409, t.Lcircumflexbelow = 7740, t.Lcommaaccent = 315, t.Ldot = 319, t.Ldotaccent = 319, t.Ldotbelow = 7734, t.Ldotbelowmacron = 7736, t.Liwnarmenian = 1340, t.Lj = 456, t.Ljecyrillic = 1033, t.Llinebelow = 7738, t.Lmonospace = 65324, t.Lslash = 321, t.Lslashsmall = 63225, t.Lsmall = 63340, t.M = 77, t.MBsquare = 13190, t.Macron = 63184, t.Macronsmall = 63407, t.Macute = 7742, t.Mcircle = 9410, t.Mdotaccent = 7744, t.Mdotbelow = 7746, t.Menarmenian = 1348, t.Mmonospace = 65325, t.Msmall = 63341, t.Mturned = 412, t.Mu = 924, t.N = 78, t.NJ = 458, t.Nacute = 323, t.Ncaron = 327, t.Ncedilla = 325, t.Ncircle = 9411, t.Ncircumflexbelow = 7754, t.Ncommaaccent = 325, t.Ndotaccent = 7748, t.Ndotbelow = 7750, t.Nhookleft = 413, t.Nineroman = 8552, t.Nj = 459, t.Njecyrillic = 1034, t.Nlinebelow = 7752, t.Nmonospace = 65326, t.Nowarmenian = 1350, t.Nsmall = 63342, t.Ntilde = 209, t.Ntildesmall = 63473, t.Nu = 925, t.O = 79, t.OE = 338, t.OEsmall = 63226, t.Oacute = 211, t.Oacutesmall = 63475, t.Obarredcyrillic = 1256, t.Obarreddieresiscyrillic = 1258, t.Obreve = 334, t.Ocaron = 465, t.Ocenteredtilde = 415, t.Ocircle = 9412, t.Ocircumflex = 212, t.Ocircumflexacute = 7888, t.Ocircumflexdotbelow = 7896, t.Ocircumflexgrave = 7890, t.Ocircumflexhookabove = 7892, t.Ocircumflexsmall = 63476, t.Ocircumflextilde = 7894, t.Ocyrillic = 1054, t.Odblacute = 336, t.Odblgrave = 524, t.Odieresis = 214, t.Odieresiscyrillic = 1254, t.Odieresissmall = 63478, t.Odotbelow = 7884, t.Ogoneksmall = 63227, t.Ograve = 210, t.Ogravesmall = 63474, t.Oharmenian = 1365, t.Ohm = 8486, t.Ohookabove = 7886, t.Ohorn = 416, t.Ohornacute = 7898, t.Ohorndotbelow = 7906, t.Ohorngrave = 7900, t.Ohornhookabove = 7902, t.Ohorntilde = 7904, t.Ohungarumlaut = 336, t.Oi = 418, t.Oinvertedbreve = 526, t.Omacron = 332, t.Omacronacute = 7762, t.Omacrongrave = 7760, t.Omega = 8486, t.Omegacyrillic = 1120, t.Omegagreek = 937, t.Omegaroundcyrillic = 1146, t.Omegatitlocyrillic = 1148, t.Omegatonos = 911, t.Omicron = 927, t.Omicrontonos = 908, t.Omonospace = 65327, t.Oneroman = 8544, t.Oogonek = 490, t.Oogonekmacron = 492, t.Oopen = 390, t.Oslash = 216, t.Oslashacute = 510, t.Oslashsmall = 63480, t.Osmall = 63343, t.Ostrokeacute = 510, t.Otcyrillic = 1150, t.Otilde = 213, t.Otildeacute = 7756, t.Otildedieresis = 7758, t.Otildesmall = 63477, t.P = 80, t.Pacute = 7764, t.Pcircle = 9413, t.Pdotaccent = 7766, t.Pecyrillic = 1055, t.Peharmenian = 1354, t.Pemiddlehookcyrillic = 1190, t.Phi = 934, t.Phook = 420, t.Pi = 928, t.Piwrarmenian = 1363, t.Pmonospace = 65328, t.Psi = 936, t.Psicyrillic = 1136, t.Psmall = 63344, t.Q = 81, t.Qcircle = 9414, t.Qmonospace = 65329, t.Qsmall = 63345, t.R = 82, t.Raarmenian = 1356, t.Racute = 340, t.Rcaron = 344, t.Rcedilla = 342, t.Rcircle = 9415, t.Rcommaaccent = 342, t.Rdblgrave = 528, t.Rdotaccent = 7768, t.Rdotbelow = 7770, t.Rdotbelowmacron = 7772, t.Reharmenian = 1360, t.Rfraktur = 8476, t.Rho = 929, t.Ringsmall = 63228, t.Rinvertedbreve = 530, t.Rlinebelow = 7774, t.Rmonospace = 65330, t.Rsmall = 63346, t.Rsmallinverted = 641, t.Rsmallinvertedsuperior = 694, t.S = 83, t.SF010000 = 9484, t.SF020000 = 9492, t.SF030000 = 9488, t.SF040000 = 9496, t.SF050000 = 9532, t.SF060000 = 9516, t.SF070000 = 9524, t.SF080000 = 9500, t.SF090000 = 9508, t.SF100000 = 9472, t.SF110000 = 9474, t.SF190000 = 9569, t.SF200000 = 9570, t.SF210000 = 9558, t.SF220000 = 9557, t.SF230000 = 9571, t.SF240000 = 9553, t.SF250000 = 9559, t.SF260000 = 9565, t.SF270000 = 9564, t.SF280000 = 9563, t.SF360000 = 9566, t.SF370000 = 9567, t.SF380000 = 9562, t.SF390000 = 9556, t.SF400000 = 9577, t.SF410000 = 9574, t.SF420000 = 9568, t.SF430000 = 9552, t.SF440000 = 9580, t.SF450000 = 9575, t.SF460000 = 9576, t.SF470000 = 9572, t.SF480000 = 9573, t.SF490000 = 9561, t.SF500000 = 9560, t.SF510000 = 9554, t.SF520000 = 9555, t.SF530000 = 9579, t.SF540000 = 9578, t.Sacute = 346, t.Sacutedotaccent = 7780, t.Sampigreek = 992, t.Scaron = 352, t.Scarondotaccent = 7782, t.Scaronsmall = 63229, t.Scedilla = 350, t.Schwa = 399, t.Schwacyrillic = 1240, t.Schwadieresiscyrillic = 1242, t.Scircle = 9416, t.Scircumflex = 348, t.Scommaaccent = 536, t.Sdotaccent = 7776, t.Sdotbelow = 7778, t.Sdotbelowdotaccent = 7784, t.Seharmenian = 1357, t.Sevenroman = 8550, t.Shaarmenian = 1351, t.Shacyrillic = 1064, t.Shchacyrillic = 1065, t.Sheicoptic = 994, t.Shhacyrillic = 1210, t.Shimacoptic = 1004, t.Sigma = 931, t.Sixroman = 8549, t.Smonospace = 65331, t.Softsigncyrillic = 1068, t.Ssmall = 63347, t.Stigmagreek = 986, t.T = 84, t.Tau = 932, t.Tbar = 358, t.Tcaron = 356, t.Tcedilla = 354, t.Tcircle = 9417, t.Tcircumflexbelow = 7792, t.Tcommaaccent = 354, t.Tdotaccent = 7786, t.Tdotbelow = 7788, t.Tecyrillic = 1058, t.Tedescendercyrillic = 1196, t.Tenroman = 8553, t.Tetsecyrillic = 1204, t.Theta = 920, t.Thook = 428, t.Thorn = 222, t.Thornsmall = 63486, t.Threeroman = 8546, t.Tildesmall = 63230, t.Tiwnarmenian = 1359, t.Tlinebelow = 7790, t.Tmonospace = 65332, t.Toarmenian = 1337, t.Tonefive = 444, t.Tonesix = 388, t.Tonetwo = 423, t.Tretroflexhook = 430, t.Tsecyrillic = 1062, t.Tshecyrillic = 1035, t.Tsmall = 63348, t.Twelveroman = 8555, t.Tworoman = 8545, t.U = 85, t.Uacute = 218, t.Uacutesmall = 63482, t.Ubreve = 364, t.Ucaron = 467, t.Ucircle = 9418, t.Ucircumflex = 219, t.Ucircumflexbelow = 7798, t.Ucircumflexsmall = 63483, t.Ucyrillic = 1059, t.Udblacute = 368, t.Udblgrave = 532, t.Udieresis = 220, t.Udieresisacute = 471, t.Udieresisbelow = 7794, t.Udieresiscaron = 473, t.Udieresiscyrillic = 1264, t.Udieresisgrave = 475, t.Udieresismacron = 469, t.Udieresissmall = 63484, t.Udotbelow = 7908, t.Ugrave = 217, t.Ugravesmall = 63481, t.Uhookabove = 7910, t.Uhorn = 431, t.Uhornacute = 7912, t.Uhorndotbelow = 7920, t.Uhorngrave = 7914, t.Uhornhookabove = 7916, t.Uhorntilde = 7918, t.Uhungarumlaut = 368, t.Uhungarumlautcyrillic = 1266, t.Uinvertedbreve = 534, t.Ukcyrillic = 1144, t.Umacron = 362, t.Umacroncyrillic = 1262, t.Umacrondieresis = 7802, t.Umonospace = 65333, t.Uogonek = 370, t.Upsilon = 933, t.Upsilon1 = 978, t.Upsilonacutehooksymbolgreek = 979, t.Upsilonafrican = 433, t.Upsilondieresis = 939, t.Upsilondieresishooksymbolgreek = 980, t.Upsilonhooksymbol = 978, t.Upsilontonos = 910, t.Uring = 366, t.Ushortcyrillic = 1038, t.Usmall = 63349, t.Ustraightcyrillic = 1198, t.Ustraightstrokecyrillic = 1200, t.Utilde = 360, t.Utildeacute = 7800, t.Utildebelow = 7796, t.V = 86, t.Vcircle = 9419, t.Vdotbelow = 7806, t.Vecyrillic = 1042, t.Vewarmenian = 1358, t.Vhook = 434, t.Vmonospace = 65334, t.Voarmenian = 1352, t.Vsmall = 63350, t.Vtilde = 7804, t.W = 87, t.Wacute = 7810, t.Wcircle = 9420, t.Wcircumflex = 372, t.Wdieresis = 7812, t.Wdotaccent = 7814, t.Wdotbelow = 7816, t.Wgrave = 7808, t.Wmonospace = 65335, t.Wsmall = 63351, t.X = 88, t.Xcircle = 9421, t.Xdieresis = 7820, t.Xdotaccent = 7818, t.Xeharmenian = 1341, t.Xi = 926, t.Xmonospace = 65336, t.Xsmall = 63352, t.Y = 89, t.Yacute = 221, t.Yacutesmall = 63485, t.Yatcyrillic = 1122, t.Ycircle = 9422, t.Ycircumflex = 374, t.Ydieresis = 376, t.Ydieresissmall = 63487, t.Ydotaccent = 7822, t.Ydotbelow = 7924, t.Yericyrillic = 1067, t.Yerudieresiscyrillic = 1272, t.Ygrave = 7922, t.Yhook = 435, t.Yhookabove = 7926, t.Yiarmenian = 1349, t.Yicyrillic = 1031, t.Yiwnarmenian = 1362, t.Ymonospace = 65337, t.Ysmall = 63353, t.Ytilde = 7928, t.Yusbigcyrillic = 1130, t.Yusbigiotifiedcyrillic = 1132, t.Yuslittlecyrillic = 1126, t.Yuslittleiotifiedcyrillic = 1128, t.Z = 90, t.Zaarmenian = 1334, t.Zacute = 377, t.Zcaron = 381, t.Zcaronsmall = 63231, t.Zcircle = 9423, t.Zcircumflex = 7824, t.Zdot = 379, t.Zdotaccent = 379, t.Zdotbelow = 7826, t.Zecyrillic = 1047, t.Zedescendercyrillic = 1176, t.Zedieresiscyrillic = 1246, t.Zeta = 918, t.Zhearmenian = 1338, t.Zhebrevecyrillic = 1217, t.Zhecyrillic = 1046, t.Zhedescendercyrillic = 1174, t.Zhedieresiscyrillic = 1244, t.Zlinebelow = 7828, t.Zmonospace = 65338, t.Zsmall = 63354, t.Zstroke = 437, t.a = 97, t.aabengali = 2438, t.aacute = 225, t.aadeva = 2310, t.aagujarati = 2694, t.aagurmukhi = 2566, t.aamatragurmukhi = 2622, t.aarusquare = 13059, t.aavowelsignbengali = 2494, t.aavowelsigndeva = 2366, t.aavowelsigngujarati = 2750, t.abbreviationmarkarmenian = 1375, t.abbreviationsigndeva = 2416, t.abengali = 2437, t.abopomofo = 12570, t.abreve = 259, t.abreveacute = 7855, t.abrevecyrillic = 1233, t.abrevedotbelow = 7863, t.abrevegrave = 7857, t.abrevehookabove = 7859, t.abrevetilde = 7861, t.acaron = 462, t.acircle = 9424, t.acircumflex = 226, t.acircumflexacute = 7845, t.acircumflexdotbelow = 7853, t.acircumflexgrave = 7847, t.acircumflexhookabove = 7849, t.acircumflextilde = 7851, t.acute = 180, t.acutebelowcmb = 791, t.acutecmb = 769, t.acutecomb = 769, t.acutedeva = 2388, t.acutelowmod = 719, t.acutetonecmb = 833, t.acyrillic = 1072, t.adblgrave = 513, t.addakgurmukhi = 2673, t.adeva = 2309, t.adieresis = 228, t.adieresiscyrillic = 1235, t.adieresismacron = 479, t.adotbelow = 7841, t.adotmacron = 481, t.ae = 230, t.aeacute = 509, t.aekorean = 12624, t.aemacron = 483, t.afii00208 = 8213, t.afii08941 = 8356, t.afii10017 = 1040, t.afii10018 = 1041, t.afii10019 = 1042, t.afii10020 = 1043, t.afii10021 = 1044, t.afii10022 = 1045, t.afii10023 = 1025, t.afii10024 = 1046, t.afii10025 = 1047, t.afii10026 = 1048, t.afii10027 = 1049, t.afii10028 = 1050, t.afii10029 = 1051, t.afii10030 = 1052, t.afii10031 = 1053, t.afii10032 = 1054, t.afii10033 = 1055, t.afii10034 = 1056, t.afii10035 = 1057, t.afii10036 = 1058, t.afii10037 = 1059, t.afii10038 = 1060, t.afii10039 = 1061, t.afii10040 = 1062, t.afii10041 = 1063, t.afii10042 = 1064, t.afii10043 = 1065, t.afii10044 = 1066, t.afii10045 = 1067, t.afii10046 = 1068, t.afii10047 = 1069, t.afii10048 = 1070, t.afii10049 = 1071, t.afii10050 = 1168, t.afii10051 = 1026, t.afii10052 = 1027, t.afii10053 = 1028, t.afii10054 = 1029, t.afii10055 = 1030, t.afii10056 = 1031, t.afii10057 = 1032, t.afii10058 = 1033, t.afii10059 = 1034, t.afii10060 = 1035, t.afii10061 = 1036, t.afii10062 = 1038, t.afii10063 = 63172, t.afii10064 = 63173, t.afii10065 = 1072, t.afii10066 = 1073, t.afii10067 = 1074, t.afii10068 = 1075, t.afii10069 = 1076, t.afii10070 = 1077, t.afii10071 = 1105, t.afii10072 = 1078, t.afii10073 = 1079, t.afii10074 = 1080, t.afii10075 = 1081, t.afii10076 = 1082, t.afii10077 = 1083, t.afii10078 = 1084, t.afii10079 = 1085, t.afii10080 = 1086, t.afii10081 = 1087, t.afii10082 = 1088, t.afii10083 = 1089, t.afii10084 = 1090, t.afii10085 = 1091, t.afii10086 = 1092, t.afii10087 = 1093, t.afii10088 = 1094, t.afii10089 = 1095, t.afii10090 = 1096, t.afii10091 = 1097, t.afii10092 = 1098, t.afii10093 = 1099, t.afii10094 = 1100, t.afii10095 = 1101, t.afii10096 = 1102, t.afii10097 = 1103, t.afii10098 = 1169, t.afii10099 = 1106, t.afii10100 = 1107, t.afii10101 = 1108, t.afii10102 = 1109, t.afii10103 = 1110, t.afii10104 = 1111, t.afii10105 = 1112, t.afii10106 = 1113, t.afii10107 = 1114, t.afii10108 = 1115, t.afii10109 = 1116, t.afii10110 = 1118, t.afii10145 = 1039, t.afii10146 = 1122, t.afii10147 = 1138, t.afii10148 = 1140, t.afii10192 = 63174, t.afii10193 = 1119, t.afii10194 = 1123, t.afii10195 = 1139, t.afii10196 = 1141, t.afii10831 = 63175, t.afii10832 = 63176, t.afii10846 = 1241, t.afii299 = 8206, t.afii300 = 8207, t.afii301 = 8205, t.afii57381 = 1642, t.afii57388 = 1548, t.afii57392 = 1632, t.afii57393 = 1633, t.afii57394 = 1634, t.afii57395 = 1635, t.afii57396 = 1636, t.afii57397 = 1637, t.afii57398 = 1638, t.afii57399 = 1639, t.afii57400 = 1640, t.afii57401 = 1641, t.afii57403 = 1563, t.afii57407 = 1567, t.afii57409 = 1569, t.afii57410 = 1570, t.afii57411 = 1571, t.afii57412 = 1572, t.afii57413 = 1573, t.afii57414 = 1574, t.afii57415 = 1575, t.afii57416 = 1576, t.afii57417 = 1577, t.afii57418 = 1578, t.afii57419 = 1579, t.afii57420 = 1580, t.afii57421 = 1581, t.afii57422 = 1582, t.afii57423 = 1583, t.afii57424 = 1584, t.afii57425 = 1585, t.afii57426 = 1586, t.afii57427 = 1587, t.afii57428 = 1588, t.afii57429 = 1589, t.afii57430 = 1590, t.afii57431 = 1591, t.afii57432 = 1592, t.afii57433 = 1593, t.afii57434 = 1594, t.afii57440 = 1600, t.afii57441 = 1601, t.afii57442 = 1602, t.afii57443 = 1603, t.afii57444 = 1604, t.afii57445 = 1605, t.afii57446 = 1606, t.afii57448 = 1608, t.afii57449 = 1609, t.afii57450 = 1610, t.afii57451 = 1611, t.afii57452 = 1612, t.afii57453 = 1613, t.afii57454 = 1614, t.afii57455 = 1615, t.afii57456 = 1616, t.afii57457 = 1617, t.afii57458 = 1618, t.afii57470 = 1607, t.afii57505 = 1700, t.afii57506 = 1662, t.afii57507 = 1670, t.afii57508 = 1688, t.afii57509 = 1711, t.afii57511 = 1657, t.afii57512 = 1672, t.afii57513 = 1681, t.afii57514 = 1722, t.afii57519 = 1746, t.afii57534 = 1749, t.afii57636 = 8362, t.afii57645 = 1470, t.afii57658 = 1475, t.afii57664 = 1488, t.afii57665 = 1489, t.afii57666 = 1490, t.afii57667 = 1491, t.afii57668 = 1492, t.afii57669 = 1493, t.afii57670 = 1494, t.afii57671 = 1495, t.afii57672 = 1496, t.afii57673 = 1497, t.afii57674 = 1498, t.afii57675 = 1499, t.afii57676 = 1500, t.afii57677 = 1501, t.afii57678 = 1502, t.afii57679 = 1503, t.afii57680 = 1504, t.afii57681 = 1505, t.afii57682 = 1506, t.afii57683 = 1507, t.afii57684 = 1508, t.afii57685 = 1509, t.afii57686 = 1510, t.afii57687 = 1511, t.afii57688 = 1512, t.afii57689 = 1513, t.afii57690 = 1514, t.afii57694 = 64298, t.afii57695 = 64299, t.afii57700 = 64331, t.afii57705 = 64287, t.afii57716 = 1520, t.afii57717 = 1521, t.afii57718 = 1522, t.afii57723 = 64309, t.afii57793 = 1460, t.afii57794 = 1461, t.afii57795 = 1462, t.afii57796 = 1467, t.afii57797 = 1464, t.afii57798 = 1463, t.afii57799 = 1456, t.afii57800 = 1458, t.afii57801 = 1457, t.afii57802 = 1459, t.afii57803 = 1474, t.afii57804 = 1473, t.afii57806 = 1465, t.afii57807 = 1468, t.afii57839 = 1469, t.afii57841 = 1471, t.afii57842 = 1472, t.afii57929 = 700, t.afii61248 = 8453, t.afii61289 = 8467, t.afii61352 = 8470, t.afii61573 = 8236, t.afii61574 = 8237, t.afii61575 = 8238, t.afii61664 = 8204, t.afii63167 = 1645, t.afii64937 = 701, t.agrave = 224, t.agujarati = 2693, t.agurmukhi = 2565, t.ahiragana = 12354, t.ahookabove = 7843, t.aibengali = 2448, t.aibopomofo = 12574, t.aideva = 2320, t.aiecyrillic = 1237, t.aigujarati = 2704, t.aigurmukhi = 2576, t.aimatragurmukhi = 2632, t.ainarabic = 1593, t.ainfinalarabic = 65226, t.aininitialarabic = 65227, t.ainmedialarabic = 65228, t.ainvertedbreve = 515, t.aivowelsignbengali = 2504, t.aivowelsigndeva = 2376, t.aivowelsigngujarati = 2760, t.akatakana = 12450, t.akatakanahalfwidth = 65393, t.akorean = 12623, t.alef = 1488, t.alefarabic = 1575, t.alefdageshhebrew = 64304, t.aleffinalarabic = 65166, t.alefhamzaabovearabic = 1571, t.alefhamzaabovefinalarabic = 65156, t.alefhamzabelowarabic = 1573, t.alefhamzabelowfinalarabic = 65160, t.alefhebrew = 1488, t.aleflamedhebrew = 64335, t.alefmaddaabovearabic = 1570, t.alefmaddaabovefinalarabic = 65154, t.alefmaksuraarabic = 1609, t.alefmaksurafinalarabic = 65264, t.alefmaksurainitialarabic = 65267, t.alefmaksuramedialarabic = 65268, t.alefpatahhebrew = 64302, t.alefqamatshebrew = 64303, t.aleph = 8501, t.allequal = 8780, t.alpha = 945, t.alphatonos = 940, t.amacron = 257, t.amonospace = 65345, t.ampersand = 38, t.ampersandmonospace = 65286, t.ampersandsmall = 63270, t.amsquare = 13250, t.anbopomofo = 12578, t.angbopomofo = 12580, t.angbracketleft = 12296, t.angbracketright = 12297, t.angkhankhuthai = 3674, t.angle = 8736, t.anglebracketleft = 12296, t.anglebracketleftvertical = 65087, t.anglebracketright = 12297, t.anglebracketrightvertical = 65088, t.angleleft = 9001, t.angleright = 9002, t.angstrom = 8491, t.anoteleia = 903, t.anudattadeva = 2386, t.anusvarabengali = 2434, t.anusvaradeva = 2306, t.anusvaragujarati = 2690, t.aogonek = 261, t.apaatosquare = 13056, t.aparen = 9372, t.apostrophearmenian = 1370, t.apostrophemod = 700, t.apple = 63743, t.approaches = 8784, t.approxequal = 8776, t.approxequalorimage = 8786, t.approximatelyequal = 8773, t.araeaekorean = 12686, t.araeakorean = 12685, t.arc = 8978, t.arighthalfring = 7834, t.aring = 229, t.aringacute = 507, t.aringbelow = 7681, t.arrowboth = 8596, t.arrowdashdown = 8675, t.arrowdashleft = 8672, t.arrowdashright = 8674, t.arrowdashup = 8673, t.arrowdblboth = 8660, t.arrowdbldown = 8659, t.arrowdblleft = 8656, t.arrowdblright = 8658, t.arrowdblup = 8657, t.arrowdown = 8595, t.arrowdownleft = 8601, t.arrowdownright = 8600, t.arrowdownwhite = 8681, t.arrowheaddownmod = 709, t.arrowheadleftmod = 706, t.arrowheadrightmod = 707, t.arrowheadupmod = 708, t.arrowhorizex = 63719, t.arrowleft = 8592, t.arrowleftdbl = 8656, t.arrowleftdblstroke = 8653, t.arrowleftoverright = 8646, t.arrowleftwhite = 8678, t.arrowright = 8594, t.arrowrightdblstroke = 8655, t.arrowrightheavy = 10142, t.arrowrightoverleft = 8644, t.arrowrightwhite = 8680, t.arrowtableft = 8676, t.arrowtabright = 8677, t.arrowup = 8593, t.arrowupdn = 8597, t.arrowupdnbse = 8616, t.arrowupdownbase = 8616, t.arrowupleft = 8598, t.arrowupleftofdown = 8645, t.arrowupright = 8599, t.arrowupwhite = 8679, t.arrowvertex = 63718, t.asciicircum = 94, t.asciicircummonospace = 65342, t.asciitilde = 126, t.asciitildemonospace = 65374, t.ascript = 593, t.ascriptturned = 594, t.asmallhiragana = 12353, t.asmallkatakana = 12449, t.asmallkatakanahalfwidth = 65383, t.asterisk = 42, t.asteriskaltonearabic = 1645, t.asteriskarabic = 1645, t.asteriskmath = 8727, t.asteriskmonospace = 65290, t.asterisksmall = 65121, t.asterism = 8258, t.asuperior = 63209, t.asymptoticallyequal = 8771, t.at = 64, t.atilde = 227, t.atmonospace = 65312, t.atsmall = 65131, t.aturned = 592, t.aubengali = 2452, t.aubopomofo = 12576, t.audeva = 2324, t.augujarati = 2708, t.augurmukhi = 2580, t.aulengthmarkbengali = 2519, t.aumatragurmukhi = 2636, t.auvowelsignbengali = 2508, t.auvowelsigndeva = 2380, t.auvowelsigngujarati = 2764, t.avagrahadeva = 2365, t.aybarmenian = 1377, t.ayin = 1506, t.ayinaltonehebrew = 64288, t.ayinhebrew = 1506, t.b = 98, t.babengali = 2476, t.backslash = 92, t.backslashmonospace = 65340, t.badeva = 2348, t.bagujarati = 2732, t.bagurmukhi = 2604, t.bahiragana = 12400, t.bahtthai = 3647, t.bakatakana = 12496, t.bar = 124, t.barmonospace = 65372, t.bbopomofo = 12549, t.bcircle = 9425, t.bdotaccent = 7683, t.bdotbelow = 7685, t.beamedsixteenthnotes = 9836, t.because = 8757, t.becyrillic = 1073, t.beharabic = 1576, t.behfinalarabic = 65168, t.behinitialarabic = 65169, t.behiragana = 12409, t.behmedialarabic = 65170, t.behmeeminitialarabic = 64671, t.behmeemisolatedarabic = 64520, t.behnoonfinalarabic = 64621, t.bekatakana = 12505, t.benarmenian = 1378, t.bet = 1489, t.beta = 946, t.betasymbolgreek = 976, t.betdagesh = 64305, t.betdageshhebrew = 64305, t.bethebrew = 1489, t.betrafehebrew = 64332, t.bhabengali = 2477, t.bhadeva = 2349, t.bhagujarati = 2733, t.bhagurmukhi = 2605, t.bhook = 595, t.bihiragana = 12403, t.bikatakana = 12499, t.bilabialclick = 664, t.bindigurmukhi = 2562, t.birusquare = 13105, t.blackcircle = 9679, t.blackdiamond = 9670, t.blackdownpointingtriangle = 9660, t.blackleftpointingpointer = 9668, t.blackleftpointingtriangle = 9664, t.blacklenticularbracketleft = 12304, t.blacklenticularbracketleftvertical = 65083, t.blacklenticularbracketright = 12305, t.blacklenticularbracketrightvertical = 65084, t.blacklowerlefttriangle = 9699, t.blacklowerrighttriangle = 9698, t.blackrectangle = 9644, t.blackrightpointingpointer = 9658, t.blackrightpointingtriangle = 9654, t.blacksmallsquare = 9642, t.blacksmilingface = 9787, t.blacksquare = 9632, t.blackstar = 9733, t.blackupperlefttriangle = 9700, t.blackupperrighttriangle = 9701, t.blackuppointingsmalltriangle = 9652, t.blackuppointingtriangle = 9650, t.blank = 9251, t.blinebelow = 7687, t.block = 9608, t.bmonospace = 65346, t.bobaimaithai = 3610, t.bohiragana = 12412, t.bokatakana = 12508, t.bparen = 9373, t.bqsquare = 13251, t.braceex = 63732, t.braceleft = 123, t.braceleftbt = 63731, t.braceleftmid = 63730, t.braceleftmonospace = 65371, t.braceleftsmall = 65115, t.bracelefttp = 63729, t.braceleftvertical = 65079, t.braceright = 125, t.bracerightbt = 63742, t.bracerightmid = 63741, t.bracerightmonospace = 65373, t.bracerightsmall = 65116, t.bracerighttp = 63740, t.bracerightvertical = 65080, t.bracketleft = 91, t.bracketleftbt = 63728, t.bracketleftex = 63727, t.bracketleftmonospace = 65339, t.bracketlefttp = 63726, t.bracketright = 93, t.bracketrightbt = 63739, t.bracketrightex = 63738, t.bracketrightmonospace = 65341, t.bracketrighttp = 63737, t.breve = 728, t.brevebelowcmb = 814, t.brevecmb = 774, t.breveinvertedbelowcmb = 815, t.breveinvertedcmb = 785, t.breveinverteddoublecmb = 865, t.bridgebelowcmb = 810, t.bridgeinvertedbelowcmb = 826, t.brokenbar = 166, t.bstroke = 384, t.bsuperior = 63210, t.btopbar = 387, t.buhiragana = 12406, t.bukatakana = 12502, t.bullet = 8226, t.bulletinverse = 9688, t.bulletoperator = 8729, t.bullseye = 9678, t.c = 99, t.caarmenian = 1390, t.cabengali = 2458, t.cacute = 263, t.cadeva = 2330, t.cagujarati = 2714, t.cagurmukhi = 2586, t.calsquare = 13192, t.candrabindubengali = 2433, t.candrabinducmb = 784, t.candrabindudeva = 2305, t.candrabindugujarati = 2689, t.capslock = 8682, t.careof = 8453, t.caron = 711, t.caronbelowcmb = 812, t.caroncmb = 780, t.carriagereturn = 8629, t.cbopomofo = 12568, t.ccaron = 269, t.ccedilla = 231, t.ccedillaacute = 7689, t.ccircle = 9426, t.ccircumflex = 265, t.ccurl = 597, t.cdot = 267, t.cdotaccent = 267, t.cdsquare = 13253, t.cedilla = 184, t.cedillacmb = 807, t.cent = 162, t.centigrade = 8451, t.centinferior = 63199, t.centmonospace = 65504, t.centoldstyle = 63394, t.centsuperior = 63200, t.chaarmenian = 1401, t.chabengali = 2459, t.chadeva = 2331, t.chagujarati = 2715, t.chagurmukhi = 2587, t.chbopomofo = 12564, t.cheabkhasiancyrillic = 1213, t.checkmark = 10003, t.checyrillic = 1095, t.chedescenderabkhasiancyrillic = 1215, t.chedescendercyrillic = 1207, t.chedieresiscyrillic = 1269, t.cheharmenian = 1395, t.chekhakassiancyrillic = 1228, t.cheverticalstrokecyrillic = 1209, t.chi = 967, t.chieuchacirclekorean = 12919, t.chieuchaparenkorean = 12823, t.chieuchcirclekorean = 12905, t.chieuchkorean = 12618, t.chieuchparenkorean = 12809, t.chochangthai = 3594, t.chochanthai = 3592, t.chochingthai = 3593, t.chochoethai = 3596, t.chook = 392, t.cieucacirclekorean = 12918, t.cieucaparenkorean = 12822, t.cieuccirclekorean = 12904, t.cieuckorean = 12616, t.cieucparenkorean = 12808, t.cieucuparenkorean = 12828, t.circle = 9675, t.circlecopyrt = 169, t.circlemultiply = 8855, t.circleot = 8857, t.circleplus = 8853, t.circlepostalmark = 12342, t.circlewithlefthalfblack = 9680, t.circlewithrighthalfblack = 9681, t.circumflex = 710, t.circumflexbelowcmb = 813, t.circumflexcmb = 770, t.clear = 8999, t.clickalveolar = 450, t.clickdental = 448, t.clicklateral = 449, t.clickretroflex = 451, t.club = 9827, t.clubsuitblack = 9827, t.clubsuitwhite = 9831, t.cmcubedsquare = 13220, t.cmonospace = 65347, t.cmsquaredsquare = 13216, t.coarmenian = 1409, t.colon = 58, t.colonmonetary = 8353, t.colonmonospace = 65306, t.colonsign = 8353, t.colonsmall = 65109, t.colontriangularhalfmod = 721, t.colontriangularmod = 720, t.comma = 44, t.commaabovecmb = 787, t.commaaboverightcmb = 789, t.commaaccent = 63171, t.commaarabic = 1548, t.commaarmenian = 1373, t.commainferior = 63201, t.commamonospace = 65292, t.commareversedabovecmb = 788, t.commareversedmod = 701, t.commasmall = 65104, t.commasuperior = 63202, t.commaturnedabovecmb = 786, t.commaturnedmod = 699, t.compass = 9788, t.congruent = 8773, t.contourintegral = 8750, t.control = 8963, t.controlACK = 6, t.controlBEL = 7, t.controlBS = 8, t.controlCAN = 24, t.controlCR = 13, t.controlDC1 = 17, t.controlDC2 = 18, t.controlDC3 = 19, t.controlDC4 = 20, t.controlDEL = 127, t.controlDLE = 16, t.controlEM = 25, t.controlENQ = 5, t.controlEOT = 4, t.controlESC = 27, t.controlETB = 23, t.controlETX = 3, t.controlFF = 12, t.controlFS = 28, t.controlGS = 29, t.controlHT = 9, t.controlLF = 10, t.controlNAK = 21, t.controlNULL = 0, t.controlRS = 30, t.controlSI = 15, t.controlSO = 14, t.controlSOT = 2, t.controlSTX = 1, t.controlSUB = 26, t.controlSYN = 22, t.controlUS = 31, t.controlVT = 11, t.copyright = 169, t.copyrightsans = 63721, t.copyrightserif = 63193, t.cornerbracketleft = 12300, t.cornerbracketlefthalfwidth = 65378, t.cornerbracketleftvertical = 65089, t.cornerbracketright = 12301, t.cornerbracketrighthalfwidth = 65379, t.cornerbracketrightvertical = 65090, t.corporationsquare = 13183, t.cosquare = 13255, t.coverkgsquare = 13254, t.cparen = 9374, t.cruzeiro = 8354, t.cstretched = 663, t.curlyand = 8911, t.curlyor = 8910, t.currency = 164, t.cyrBreve = 63185, t.cyrFlex = 63186, t.cyrbreve = 63188, t.cyrflex = 63189, t.d = 100, t.daarmenian = 1380, t.dabengali = 2470, t.dadarabic = 1590, t.dadeva = 2342, t.dadfinalarabic = 65214, t.dadinitialarabic = 65215, t.dadmedialarabic = 65216, t.dagesh = 1468, t.dageshhebrew = 1468, t.dagger = 8224, t.daggerdbl = 8225, t.dagujarati = 2726, t.dagurmukhi = 2598, t.dahiragana = 12384, t.dakatakana = 12480, t.dalarabic = 1583, t.dalet = 1491, t.daletdagesh = 64307, t.daletdageshhebrew = 64307, t.dalethebrew = 1491, t.dalfinalarabic = 65194, t.dammaarabic = 1615, t.dammalowarabic = 1615, t.dammatanaltonearabic = 1612, t.dammatanarabic = 1612, t.danda = 2404, t.dargahebrew = 1447, t.dargalefthebrew = 1447, t.dasiapneumatacyrilliccmb = 1157, t.dblGrave = 63187, t.dblanglebracketleft = 12298, t.dblanglebracketleftvertical = 65085, t.dblanglebracketright = 12299, t.dblanglebracketrightvertical = 65086, t.dblarchinvertedbelowcmb = 811, t.dblarrowleft = 8660, t.dblarrowright = 8658, t.dbldanda = 2405, t.dblgrave = 63190, t.dblgravecmb = 783, t.dblintegral = 8748, t.dbllowline = 8215, t.dbllowlinecmb = 819, t.dbloverlinecmb = 831, t.dblprimemod = 698, t.dblverticalbar = 8214, t.dblverticallineabovecmb = 782, t.dbopomofo = 12553, t.dbsquare = 13256, t.dcaron = 271, t.dcedilla = 7697, t.dcircle = 9427, t.dcircumflexbelow = 7699, t.dcroat = 273, t.ddabengali = 2465, t.ddadeva = 2337, t.ddagujarati = 2721, t.ddagurmukhi = 2593, t.ddalarabic = 1672, t.ddalfinalarabic = 64393, t.dddhadeva = 2396, t.ddhabengali = 2466, t.ddhadeva = 2338, t.ddhagujarati = 2722, t.ddhagurmukhi = 2594, t.ddotaccent = 7691, t.ddotbelow = 7693, t.decimalseparatorarabic = 1643, t.decimalseparatorpersian = 1643, t.decyrillic = 1076, t.degree = 176, t.dehihebrew = 1453, t.dehiragana = 12391, t.deicoptic = 1007, t.dekatakana = 12487, t.deleteleft = 9003, t.deleteright = 8998, t.delta = 948, t.deltaturned = 397, t.denominatorminusonenumeratorbengali = 2552, t.dezh = 676, t.dhabengali = 2471, t.dhadeva = 2343, t.dhagujarati = 2727, t.dhagurmukhi = 2599, t.dhook = 599, t.dialytikatonos = 901, t.dialytikatonoscmb = 836, t.diamond = 9830, t.diamondsuitwhite = 9826, t.dieresis = 168, t.dieresisacute = 63191, t.dieresisbelowcmb = 804, t.dieresiscmb = 776, t.dieresisgrave = 63192, t.dieresistonos = 901, t.dihiragana = 12386, t.dikatakana = 12482, t.dittomark = 12291, t.divide = 247, t.divides = 8739, t.divisionslash = 8725, t.djecyrillic = 1106, t.dkshade = 9619, t.dlinebelow = 7695, t.dlsquare = 13207, t.dmacron = 273, t.dmonospace = 65348, t.dnblock = 9604, t.dochadathai = 3598, t.dodekthai = 3604, t.dohiragana = 12393, t.dokatakana = 12489, t.dollar = 36, t.dollarinferior = 63203, t.dollarmonospace = 65284, t.dollaroldstyle = 63268, t.dollarsmall = 65129, t.dollarsuperior = 63204, t.dong = 8363, t.dorusquare = 13094, t.dotaccent = 729, t.dotaccentcmb = 775, t.dotbelowcmb = 803, t.dotbelowcomb = 803, t.dotkatakana = 12539, t.dotlessi = 305, t.dotlessj = 63166, t.dotlessjstrokehook = 644, t.dotmath = 8901, t.dottedcircle = 9676, t.doubleyodpatah = 64287, t.doubleyodpatahhebrew = 64287, t.downtackbelowcmb = 798, t.downtackmod = 725, t.dparen = 9375, t.dsuperior = 63211, t.dtail = 598, t.dtopbar = 396, t.duhiragana = 12389, t.dukatakana = 12485, t.dz = 499, t.dzaltone = 675, t.dzcaron = 454, t.dzcurl = 677, t.dzeabkhasiancyrillic = 1249, t.dzecyrillic = 1109, t.dzhecyrillic = 1119, t.e = 101, t.eacute = 233, t.earth = 9793, t.ebengali = 2447, t.ebopomofo = 12572, t.ebreve = 277, t.ecandradeva = 2317, t.ecandragujarati = 2701, t.ecandravowelsigndeva = 2373, t.ecandravowelsigngujarati = 2757, t.ecaron = 283, t.ecedillabreve = 7709, t.echarmenian = 1381, t.echyiwnarmenian = 1415, t.ecircle = 9428, t.ecircumflex = 234, t.ecircumflexacute = 7871, t.ecircumflexbelow = 7705, t.ecircumflexdotbelow = 7879, t.ecircumflexgrave = 7873, t.ecircumflexhookabove = 7875, t.ecircumflextilde = 7877, t.ecyrillic = 1108, t.edblgrave = 517, t.edeva = 2319, t.edieresis = 235, t.edot = 279, t.edotaccent = 279, t.edotbelow = 7865, t.eegurmukhi = 2575, t.eematragurmukhi = 2631, t.efcyrillic = 1092, t.egrave = 232, t.egujarati = 2703, t.eharmenian = 1383, t.ehbopomofo = 12573, t.ehiragana = 12360, t.ehookabove = 7867, t.eibopomofo = 12575, t.eight = 56, t.eightarabic = 1640, t.eightbengali = 2542, t.eightcircle = 9319, t.eightcircleinversesansserif = 10129, t.eightdeva = 2414, t.eighteencircle = 9329, t.eighteenparen = 9349, t.eighteenperiod = 9369, t.eightgujarati = 2798, t.eightgurmukhi = 2670, t.eighthackarabic = 1640, t.eighthangzhou = 12328, t.eighthnotebeamed = 9835, t.eightideographicparen = 12839, t.eightinferior = 8328, t.eightmonospace = 65304, t.eightoldstyle = 63288, t.eightparen = 9339, t.eightperiod = 9359, t.eightpersian = 1784, t.eightroman = 8567, t.eightsuperior = 8312, t.eightthai = 3672, t.einvertedbreve = 519, t.eiotifiedcyrillic = 1125, t.ekatakana = 12456, t.ekatakanahalfwidth = 65396, t.ekonkargurmukhi = 2676, t.ekorean = 12628, t.elcyrillic = 1083, t.element = 8712, t.elevencircle = 9322, t.elevenparen = 9342, t.elevenperiod = 9362, t.elevenroman = 8570, t.ellipsis = 8230, t.ellipsisvertical = 8942, t.emacron = 275, t.emacronacute = 7703, t.emacrongrave = 7701, t.emcyrillic = 1084, t.emdash = 8212, t.emdashvertical = 65073, t.emonospace = 65349, t.emphasismarkarmenian = 1371, t.emptyset = 8709, t.enbopomofo = 12579, t.encyrillic = 1085, t.endash = 8211, t.endashvertical = 65074, t.endescendercyrillic = 1187, t.eng = 331, t.engbopomofo = 12581, t.enghecyrillic = 1189, t.enhookcyrillic = 1224, t.enspace = 8194, t.eogonek = 281, t.eokorean = 12627, t.eopen = 603, t.eopenclosed = 666, t.eopenreversed = 604, t.eopenreversedclosed = 606, t.eopenreversedhook = 605, t.eparen = 9376, t.epsilon = 949, t.epsilontonos = 941, t.equal = 61, t.equalmonospace = 65309, t.equalsmall = 65126, t.equalsuperior = 8316, t.equivalence = 8801, t.erbopomofo = 12582, t.ercyrillic = 1088, t.ereversed = 600, t.ereversedcyrillic = 1101, t.escyrillic = 1089, t.esdescendercyrillic = 1195, t.esh = 643, t.eshcurl = 646, t.eshortdeva = 2318, t.eshortvowelsigndeva = 2374, t.eshreversedloop = 426, t.eshsquatreversed = 645, t.esmallhiragana = 12359, t.esmallkatakana = 12455, t.esmallkatakanahalfwidth = 65386, t.estimated = 8494, t.esuperior = 63212, t.eta = 951, t.etarmenian = 1384, t.etatonos = 942, t.eth = 240, t.etilde = 7869, t.etildebelow = 7707, t.etnahtafoukhhebrew = 1425, t.etnahtafoukhlefthebrew = 1425, t.etnahtahebrew = 1425, t.etnahtalefthebrew = 1425, t.eturned = 477, t.eukorean = 12641, t.euro = 8364, t.evowelsignbengali = 2503, t.evowelsigndeva = 2375, t.evowelsigngujarati = 2759, t.exclam = 33, t.exclamarmenian = 1372, t.exclamdbl = 8252, t.exclamdown = 161, t.exclamdownsmall = 63393, t.exclammonospace = 65281, t.exclamsmall = 63265, t.existential = 8707, t.ezh = 658, t.ezhcaron = 495, t.ezhcurl = 659, t.ezhreversed = 441, t.ezhtail = 442, t.f = 102, t.fadeva = 2398, t.fagurmukhi = 2654, t.fahrenheit = 8457, t.fathaarabic = 1614, t.fathalowarabic = 1614, t.fathatanarabic = 1611, t.fbopomofo = 12552, t.fcircle = 9429, t.fdotaccent = 7711, t.feharabic = 1601, t.feharmenian = 1414, t.fehfinalarabic = 65234, t.fehinitialarabic = 65235, t.fehmedialarabic = 65236, t.feicoptic = 997, t.female = 9792, t.ff = 64256, t.f_f = 64256, t.ffi = 64259, t.f_f_i = 64259, t.ffl = 64260, t.f_f_l = 64260, t.fi = 64257, t.f_i = 64257, t.fifteencircle = 9326, t.fifteenparen = 9346, t.fifteenperiod = 9366, t.figuredash = 8210, t.filledbox = 9632, t.filledrect = 9644, t.finalkaf = 1498, t.finalkafdagesh = 64314, t.finalkafdageshhebrew = 64314, t.finalkafhebrew = 1498, t.finalmem = 1501, t.finalmemhebrew = 1501, t.finalnun = 1503, t.finalnunhebrew = 1503, t.finalpe = 1507, t.finalpehebrew = 1507, t.finaltsadi = 1509, t.finaltsadihebrew = 1509, t.firsttonechinese = 713, t.fisheye = 9673, t.fitacyrillic = 1139, t.five = 53, t.fivearabic = 1637, t.fivebengali = 2539, t.fivecircle = 9316, t.fivecircleinversesansserif = 10126, t.fivedeva = 2411, t.fiveeighths = 8541, t.fivegujarati = 2795, t.fivegurmukhi = 2667, t.fivehackarabic = 1637, t.fivehangzhou = 12325, t.fiveideographicparen = 12836, t.fiveinferior = 8325, t.fivemonospace = 65301, t.fiveoldstyle = 63285, t.fiveparen = 9336, t.fiveperiod = 9356, t.fivepersian = 1781, t.fiveroman = 8564, t.fivesuperior = 8309, t.fivethai = 3669, t.fl = 64258, t.f_l = 64258, t.florin = 402, t.fmonospace = 65350, t.fmsquare = 13209, t.fofanthai = 3615, t.fofathai = 3613, t.fongmanthai = 3663, t.forall = 8704, t.four = 52, t.fourarabic = 1636, t.fourbengali = 2538, t.fourcircle = 9315, t.fourcircleinversesansserif = 10125, t.fourdeva = 2410, t.fourgujarati = 2794, t.fourgurmukhi = 2666, t.fourhackarabic = 1636, t.fourhangzhou = 12324, t.fourideographicparen = 12835, t.fourinferior = 8324, t.fourmonospace = 65300, t.fournumeratorbengali = 2551, t.fouroldstyle = 63284, t.fourparen = 9335, t.fourperiod = 9355, t.fourpersian = 1780, t.fourroman = 8563, t.foursuperior = 8308, t.fourteencircle = 9325, t.fourteenparen = 9345, t.fourteenperiod = 9365, t.fourthai = 3668, t.fourthtonechinese = 715, t.fparen = 9377, t.fraction = 8260, t.franc = 8355, t.g = 103, t.gabengali = 2455, t.gacute = 501, t.gadeva = 2327, t.gafarabic = 1711, t.gaffinalarabic = 64403, t.gafinitialarabic = 64404, t.gafmedialarabic = 64405, t.gagujarati = 2711, t.gagurmukhi = 2583, t.gahiragana = 12364, t.gakatakana = 12460, t.gamma = 947, t.gammalatinsmall = 611, t.gammasuperior = 736, t.gangiacoptic = 1003, t.gbopomofo = 12557, t.gbreve = 287, t.gcaron = 487, t.gcedilla = 291, t.gcircle = 9430, t.gcircumflex = 285, t.gcommaaccent = 291, t.gdot = 289, t.gdotaccent = 289, t.gecyrillic = 1075, t.gehiragana = 12370, t.gekatakana = 12466, t.geometricallyequal = 8785, t.gereshaccenthebrew = 1436, t.gereshhebrew = 1523, t.gereshmuqdamhebrew = 1437, t.germandbls = 223, t.gershayimaccenthebrew = 1438, t.gershayimhebrew = 1524, t.getamark = 12307, t.ghabengali = 2456, t.ghadarmenian = 1394, t.ghadeva = 2328, t.ghagujarati = 2712, t.ghagurmukhi = 2584, t.ghainarabic = 1594, t.ghainfinalarabic = 65230, t.ghaininitialarabic = 65231, t.ghainmedialarabic = 65232, t.ghemiddlehookcyrillic = 1173, t.ghestrokecyrillic = 1171, t.gheupturncyrillic = 1169, t.ghhadeva = 2394, t.ghhagurmukhi = 2650, t.ghook = 608, t.ghzsquare = 13203, t.gihiragana = 12366, t.gikatakana = 12462, t.gimarmenian = 1379, t.gimel = 1490, t.gimeldagesh = 64306, t.gimeldageshhebrew = 64306, t.gimelhebrew = 1490, t.gjecyrillic = 1107, t.glottalinvertedstroke = 446, t.glottalstop = 660, t.glottalstopinverted = 662, t.glottalstopmod = 704, t.glottalstopreversed = 661, t.glottalstopreversedmod = 705, t.glottalstopreversedsuperior = 740, t.glottalstopstroke = 673, t.glottalstopstrokereversed = 674, t.gmacron = 7713, t.gmonospace = 65351, t.gohiragana = 12372, t.gokatakana = 12468, t.gparen = 9378, t.gpasquare = 13228, t.gradient = 8711, t.grave = 96, t.gravebelowcmb = 790, t.gravecmb = 768, t.gravecomb = 768, t.gravedeva = 2387, t.gravelowmod = 718, t.gravemonospace = 65344, t.gravetonecmb = 832, t.greater = 62, t.greaterequal = 8805, t.greaterequalorless = 8923, t.greatermonospace = 65310, t.greaterorequivalent = 8819, t.greaterorless = 8823, t.greateroverequal = 8807, t.greatersmall = 65125, t.gscript = 609, t.gstroke = 485, t.guhiragana = 12368, t.guillemotleft = 171, t.guillemotright = 187, t.guilsinglleft = 8249, t.guilsinglright = 8250, t.gukatakana = 12464, t.guramusquare = 13080, t.gysquare = 13257, t.h = 104, t.haabkhasiancyrillic = 1193, t.haaltonearabic = 1729, t.habengali = 2489, t.hadescendercyrillic = 1203, t.hadeva = 2361, t.hagujarati = 2745, t.hagurmukhi = 2617, t.haharabic = 1581, t.hahfinalarabic = 65186, t.hahinitialarabic = 65187, t.hahiragana = 12399, t.hahmedialarabic = 65188, t.haitusquare = 13098, t.hakatakana = 12495, t.hakatakanahalfwidth = 65418, t.halantgurmukhi = 2637, t.hamzaarabic = 1569, t.hamzalowarabic = 1569, t.hangulfiller = 12644, t.hardsigncyrillic = 1098, t.harpoonleftbarbup = 8636, t.harpoonrightbarbup = 8640, t.hasquare = 13258, t.hatafpatah = 1458, t.hatafpatah16 = 1458, t.hatafpatah23 = 1458, t.hatafpatah2f = 1458, t.hatafpatahhebrew = 1458, t.hatafpatahnarrowhebrew = 1458, t.hatafpatahquarterhebrew = 1458, t.hatafpatahwidehebrew = 1458, t.hatafqamats = 1459, t.hatafqamats1b = 1459, t.hatafqamats28 = 1459, t.hatafqamats34 = 1459, t.hatafqamatshebrew = 1459, t.hatafqamatsnarrowhebrew = 1459, t.hatafqamatsquarterhebrew = 1459, t.hatafqamatswidehebrew = 1459, t.hatafsegol = 1457, t.hatafsegol17 = 1457, t.hatafsegol24 = 1457, t.hatafsegol30 = 1457, t.hatafsegolhebrew = 1457, t.hatafsegolnarrowhebrew = 1457, t.hatafsegolquarterhebrew = 1457, t.hatafsegolwidehebrew = 1457, t.hbar = 295, t.hbopomofo = 12559, t.hbrevebelow = 7723, t.hcedilla = 7721, t.hcircle = 9431, t.hcircumflex = 293, t.hdieresis = 7719, t.hdotaccent = 7715, t.hdotbelow = 7717, t.he = 1492, t.heart = 9829, t.heartsuitblack = 9829, t.heartsuitwhite = 9825, t.hedagesh = 64308, t.hedageshhebrew = 64308, t.hehaltonearabic = 1729, t.heharabic = 1607, t.hehebrew = 1492, t.hehfinalaltonearabic = 64423, t.hehfinalalttwoarabic = 65258, t.hehfinalarabic = 65258, t.hehhamzaabovefinalarabic = 64421, t.hehhamzaaboveisolatedarabic = 64420, t.hehinitialaltonearabic = 64424, t.hehinitialarabic = 65259, t.hehiragana = 12408, t.hehmedialaltonearabic = 64425, t.hehmedialarabic = 65260, t.heiseierasquare = 13179, t.hekatakana = 12504, t.hekatakanahalfwidth = 65421, t.hekutaarusquare = 13110, t.henghook = 615, t.herutusquare = 13113, t.het = 1495, t.hethebrew = 1495, t.hhook = 614, t.hhooksuperior = 689, t.hieuhacirclekorean = 12923, t.hieuhaparenkorean = 12827, t.hieuhcirclekorean = 12909, t.hieuhkorean = 12622, t.hieuhparenkorean = 12813, t.hihiragana = 12402, t.hikatakana = 12498, t.hikatakanahalfwidth = 65419, t.hiriq = 1460, t.hiriq14 = 1460, t.hiriq21 = 1460, t.hiriq2d = 1460, t.hiriqhebrew = 1460, t.hiriqnarrowhebrew = 1460, t.hiriqquarterhebrew = 1460, t.hiriqwidehebrew = 1460, t.hlinebelow = 7830, t.hmonospace = 65352, t.hoarmenian = 1392, t.hohipthai = 3627, t.hohiragana = 12411, t.hokatakana = 12507, t.hokatakanahalfwidth = 65422, t.holam = 1465, t.holam19 = 1465, t.holam26 = 1465, t.holam32 = 1465, t.holamhebrew = 1465, t.holamnarrowhebrew = 1465, t.holamquarterhebrew = 1465, t.holamwidehebrew = 1465, t.honokhukthai = 3630, t.hookabovecomb = 777, t.hookcmb = 777, t.hookpalatalizedbelowcmb = 801, t.hookretroflexbelowcmb = 802, t.hoonsquare = 13122, t.horicoptic = 1001, t.horizontalbar = 8213, t.horncmb = 795, t.hotsprings = 9832, t.house = 8962, t.hparen = 9379, t.hsuperior = 688, t.hturned = 613, t.huhiragana = 12405, t.huiitosquare = 13107, t.hukatakana = 12501, t.hukatakanahalfwidth = 65420, t.hungarumlaut = 733, t.hungarumlautcmb = 779, t.hv = 405, t.hyphen = 45, t.hypheninferior = 63205, t.hyphenmonospace = 65293, t.hyphensmall = 65123, t.hyphensuperior = 63206, t.hyphentwo = 8208, t.i = 105, t.iacute = 237, t.iacyrillic = 1103, t.ibengali = 2439, t.ibopomofo = 12583, t.ibreve = 301, t.icaron = 464, t.icircle = 9432, t.icircumflex = 238, t.icyrillic = 1110, t.idblgrave = 521, t.ideographearthcircle = 12943, t.ideographfirecircle = 12939, t.ideographicallianceparen = 12863, t.ideographiccallparen = 12858, t.ideographiccentrecircle = 12965, t.ideographicclose = 12294, t.ideographiccomma = 12289, t.ideographiccommaleft = 65380, t.ideographiccongratulationparen = 12855, t.ideographiccorrectcircle = 12963, t.ideographicearthparen = 12847, t.ideographicenterpriseparen = 12861, t.ideographicexcellentcircle = 12957, t.ideographicfestivalparen = 12864, t.ideographicfinancialcircle = 12950, t.ideographicfinancialparen = 12854, t.ideographicfireparen = 12843, t.ideographichaveparen = 12850, t.ideographichighcircle = 12964, t.ideographiciterationmark = 12293, t.ideographiclaborcircle = 12952, t.ideographiclaborparen = 12856, t.ideographicleftcircle = 12967, t.ideographiclowcircle = 12966, t.ideographicmedicinecircle = 12969, t.ideographicmetalparen = 12846, t.ideographicmoonparen = 12842, t.ideographicnameparen = 12852, t.ideographicperiod = 12290, t.ideographicprintcircle = 12958, t.ideographicreachparen = 12867, t.ideographicrepresentparen = 12857, t.ideographicresourceparen = 12862, t.ideographicrightcircle = 12968, t.ideographicsecretcircle = 12953, t.ideographicselfparen = 12866, t.ideographicsocietyparen = 12851, t.ideographicspace = 12288, t.ideographicspecialparen = 12853, t.ideographicstockparen = 12849, t.ideographicstudyparen = 12859, t.ideographicsunparen = 12848, t.ideographicsuperviseparen = 12860, t.ideographicwaterparen = 12844, t.ideographicwoodparen = 12845, t.ideographiczero = 12295, t.ideographmetalcircle = 12942, t.ideographmooncircle = 12938, t.ideographnamecircle = 12948, t.ideographsuncircle = 12944, t.ideographwatercircle = 12940, t.ideographwoodcircle = 12941, t.ideva = 2311, t.idieresis = 239, t.idieresisacute = 7727, t.idieresiscyrillic = 1253, t.idotbelow = 7883, t.iebrevecyrillic = 1239, t.iecyrillic = 1077, t.ieungacirclekorean = 12917, t.ieungaparenkorean = 12821, t.ieungcirclekorean = 12903, t.ieungkorean = 12615, t.ieungparenkorean = 12807, t.igrave = 236, t.igujarati = 2695, t.igurmukhi = 2567, t.ihiragana = 12356, t.ihookabove = 7881, t.iibengali = 2440, t.iicyrillic = 1080, t.iideva = 2312, t.iigujarati = 2696, t.iigurmukhi = 2568, t.iimatragurmukhi = 2624, t.iinvertedbreve = 523, t.iishortcyrillic = 1081, t.iivowelsignbengali = 2496, t.iivowelsigndeva = 2368, t.iivowelsigngujarati = 2752, t.ij = 307, t.ikatakana = 12452, t.ikatakanahalfwidth = 65394, t.ikorean = 12643, t.ilde = 732, t.iluyhebrew = 1452, t.imacron = 299, t.imacroncyrillic = 1251, t.imageorapproximatelyequal = 8787, t.imatragurmukhi = 2623, t.imonospace = 65353, t.increment = 8710, t.infinity = 8734, t.iniarmenian = 1387, t.integral = 8747, t.integralbottom = 8993, t.integralbt = 8993, t.integralex = 63733, t.integraltop = 8992, t.integraltp = 8992, t.intersection = 8745, t.intisquare = 13061, t.invbullet = 9688, t.invcircle = 9689, t.invsmileface = 9787, t.iocyrillic = 1105, t.iogonek = 303, t.iota = 953, t.iotadieresis = 970, t.iotadieresistonos = 912, t.iotalatin = 617, t.iotatonos = 943, t.iparen = 9380, t.irigurmukhi = 2674, t.ismallhiragana = 12355, t.ismallkatakana = 12451, t.ismallkatakanahalfwidth = 65384, t.issharbengali = 2554, t.istroke = 616, t.isuperior = 63213, t.iterationhiragana = 12445, t.iterationkatakana = 12541, t.itilde = 297, t.itildebelow = 7725, t.iubopomofo = 12585, t.iucyrillic = 1102, t.ivowelsignbengali = 2495, t.ivowelsigndeva = 2367, t.ivowelsigngujarati = 2751, t.izhitsacyrillic = 1141, t.izhitsadblgravecyrillic = 1143, t.j = 106, t.jaarmenian = 1393, t.jabengali = 2460, t.jadeva = 2332, t.jagujarati = 2716, t.jagurmukhi = 2588, t.jbopomofo = 12560, t.jcaron = 496, t.jcircle = 9433, t.jcircumflex = 309, t.jcrossedtail = 669, t.jdotlessstroke = 607, t.jecyrillic = 1112, t.jeemarabic = 1580, t.jeemfinalarabic = 65182, t.jeeminitialarabic = 65183, t.jeemmedialarabic = 65184, t.jeharabic = 1688, t.jehfinalarabic = 64395, t.jhabengali = 2461, t.jhadeva = 2333, t.jhagujarati = 2717, t.jhagurmukhi = 2589, t.jheharmenian = 1403, t.jis = 12292, t.jmonospace = 65354, t.jparen = 9381, t.jsuperior = 690, t.k = 107, t.kabashkircyrillic = 1185, t.kabengali = 2453, t.kacute = 7729, t.kacyrillic = 1082, t.kadescendercyrillic = 1179, t.kadeva = 2325, t.kaf = 1499, t.kafarabic = 1603, t.kafdagesh = 64315, t.kafdageshhebrew = 64315, t.kaffinalarabic = 65242, t.kafhebrew = 1499, t.kafinitialarabic = 65243, t.kafmedialarabic = 65244, t.kafrafehebrew = 64333, t.kagujarati = 2709, t.kagurmukhi = 2581, t.kahiragana = 12363, t.kahookcyrillic = 1220, t.kakatakana = 12459, t.kakatakanahalfwidth = 65398, t.kappa = 954, t.kappasymbolgreek = 1008, t.kapyeounmieumkorean = 12657, t.kapyeounphieuphkorean = 12676, t.kapyeounpieupkorean = 12664, t.kapyeounssangpieupkorean = 12665, t.karoriisquare = 13069, t.kashidaautoarabic = 1600, t.kashidaautonosidebearingarabic = 1600, t.kasmallkatakana = 12533, t.kasquare = 13188, t.kasraarabic = 1616, t.kasratanarabic = 1613, t.kastrokecyrillic = 1183, t.katahiraprolongmarkhalfwidth = 65392, t.kaverticalstrokecyrillic = 1181, t.kbopomofo = 12558, t.kcalsquare = 13193, t.kcaron = 489, t.kcedilla = 311, t.kcircle = 9434, t.kcommaaccent = 311, t.kdotbelow = 7731, t.keharmenian = 1412, t.kehiragana = 12369, t.kekatakana = 12465, t.kekatakanahalfwidth = 65401, t.kenarmenian = 1391, t.kesmallkatakana = 12534, t.kgreenlandic = 312, t.khabengali = 2454, t.khacyrillic = 1093, t.khadeva = 2326, t.khagujarati = 2710, t.khagurmukhi = 2582, t.khaharabic = 1582, t.khahfinalarabic = 65190, t.khahinitialarabic = 65191, t.khahmedialarabic = 65192, t.kheicoptic = 999, t.khhadeva = 2393, t.khhagurmukhi = 2649, t.khieukhacirclekorean = 12920, t.khieukhaparenkorean = 12824, t.khieukhcirclekorean = 12906, t.khieukhkorean = 12619, t.khieukhparenkorean = 12810, t.khokhaithai = 3586, t.khokhonthai = 3589, t.khokhuatthai = 3587, t.khokhwaithai = 3588, t.khomutthai = 3675, t.khook = 409, t.khorakhangthai = 3590, t.khzsquare = 13201, t.kihiragana = 12365, t.kikatakana = 12461, t.kikatakanahalfwidth = 65399, t.kiroguramusquare = 13077, t.kiromeetorusquare = 13078, t.kirosquare = 13076, t.kiyeokacirclekorean = 12910, t.kiyeokaparenkorean = 12814, t.kiyeokcirclekorean = 12896, t.kiyeokkorean = 12593, t.kiyeokparenkorean = 12800, t.kiyeoksioskorean = 12595, t.kjecyrillic = 1116, t.klinebelow = 7733, t.klsquare = 13208, t.kmcubedsquare = 13222, t.kmonospace = 65355, t.kmsquaredsquare = 13218, t.kohiragana = 12371, t.kohmsquare = 13248, t.kokaithai = 3585, t.kokatakana = 12467, t.kokatakanahalfwidth = 65402, t.kooposquare = 13086, t.koppacyrillic = 1153, t.koreanstandardsymbol = 12927, t.koroniscmb = 835, t.kparen = 9382, t.kpasquare = 13226, t.ksicyrillic = 1135, t.ktsquare = 13263, t.kturned = 670, t.kuhiragana = 12367, t.kukatakana = 12463, t.kukatakanahalfwidth = 65400, t.kvsquare = 13240, t.kwsquare = 13246, t.l = 108, t.labengali = 2482, t.lacute = 314, t.ladeva = 2354, t.lagujarati = 2738, t.lagurmukhi = 2610, t.lakkhangyaothai = 3653, t.lamaleffinalarabic = 65276, t.lamalefhamzaabovefinalarabic = 65272, t.lamalefhamzaaboveisolatedarabic = 65271, t.lamalefhamzabelowfinalarabic = 65274, t.lamalefhamzabelowisolatedarabic = 65273, t.lamalefisolatedarabic = 65275, t.lamalefmaddaabovefinalarabic = 65270, t.lamalefmaddaaboveisolatedarabic = 65269, t.lamarabic = 1604, t.lambda = 955, t.lambdastroke = 411, t.lamed = 1500, t.lameddagesh = 64316, t.lameddageshhebrew = 64316, t.lamedhebrew = 1500, t.lamfinalarabic = 65246, t.lamhahinitialarabic = 64714, t.laminitialarabic = 65247, t.lamjeeminitialarabic = 64713, t.lamkhahinitialarabic = 64715, t.lamlamhehisolatedarabic = 65010, t.lammedialarabic = 65248, t.lammeemhahinitialarabic = 64904, t.lammeeminitialarabic = 64716, t.largecircle = 9711, t.lbar = 410, t.lbelt = 620, t.lbopomofo = 12556, t.lcaron = 318, t.lcedilla = 316, t.lcircle = 9435, t.lcircumflexbelow = 7741, t.lcommaaccent = 316, t.ldot = 320, t.ldotaccent = 320, t.ldotbelow = 7735, t.ldotbelowmacron = 7737, t.leftangleabovecmb = 794, t.lefttackbelowcmb = 792, t.less = 60, t.lessequal = 8804, t.lessequalorgreater = 8922, t.lessmonospace = 65308, t.lessorequivalent = 8818, t.lessorgreater = 8822, t.lessoverequal = 8806, t.lesssmall = 65124, t.lezh = 622, t.lfblock = 9612, t.lhookretroflex = 621, t.lira = 8356, t.liwnarmenian = 1388, t.lj = 457, t.ljecyrillic = 1113, t.ll = 63168, t.lladeva = 2355, t.llagujarati = 2739, t.llinebelow = 7739, t.llladeva = 2356, t.llvocalicbengali = 2529, t.llvocalicdeva = 2401, t.llvocalicvowelsignbengali = 2531, t.llvocalicvowelsigndeva = 2403, t.lmiddletilde = 619, t.lmonospace = 65356, t.lmsquare = 13264, t.lochulathai = 3628, t.logicaland = 8743, t.logicalnot = 172, t.logicalnotreversed = 8976, t.logicalor = 8744, t.lolingthai = 3621, t.longs = 383, t.lowlinecenterline = 65102, t.lowlinecmb = 818, t.lowlinedashed = 65101, t.lozenge = 9674, t.lparen = 9383, t.lslash = 322, t.lsquare = 8467, t.lsuperior = 63214, t.ltshade = 9617, t.luthai = 3622, t.lvocalicbengali = 2444, t.lvocalicdeva = 2316, t.lvocalicvowelsignbengali = 2530, t.lvocalicvowelsigndeva = 2402, t.lxsquare = 13267, t.m = 109, t.mabengali = 2478, t.macron = 175, t.macronbelowcmb = 817, t.macroncmb = 772, t.macronlowmod = 717, t.macronmonospace = 65507, t.macute = 7743, t.madeva = 2350, t.magujarati = 2734, t.magurmukhi = 2606, t.mahapakhhebrew = 1444, t.mahapakhlefthebrew = 1444, t.mahiragana = 12414, t.maichattawalowleftthai = 63637, t.maichattawalowrightthai = 63636, t.maichattawathai = 3659, t.maichattawaupperleftthai = 63635, t.maieklowleftthai = 63628, t.maieklowrightthai = 63627, t.maiekthai = 3656, t.maiekupperleftthai = 63626, t.maihanakatleftthai = 63620, t.maihanakatthai = 3633, t.maitaikhuleftthai = 63625, t.maitaikhuthai = 3655, t.maitholowleftthai = 63631, t.maitholowrightthai = 63630, t.maithothai = 3657, t.maithoupperleftthai = 63629, t.maitrilowleftthai = 63634, t.maitrilowrightthai = 63633, t.maitrithai = 3658, t.maitriupperleftthai = 63632, t.maiyamokthai = 3654, t.makatakana = 12510, t.makatakanahalfwidth = 65423, t.male = 9794, t.mansyonsquare = 13127, t.maqafhebrew = 1470, t.mars = 9794, t.masoracirclehebrew = 1455, t.masquare = 13187, t.mbopomofo = 12551, t.mbsquare = 13268, t.mcircle = 9436, t.mcubedsquare = 13221, t.mdotaccent = 7745, t.mdotbelow = 7747, t.meemarabic = 1605, t.meemfinalarabic = 65250, t.meeminitialarabic = 65251, t.meemmedialarabic = 65252, t.meemmeeminitialarabic = 64721, t.meemmeemisolatedarabic = 64584, t.meetorusquare = 13133, t.mehiragana = 12417, t.meizierasquare = 13182, t.mekatakana = 12513, t.mekatakanahalfwidth = 65426, t.mem = 1502, t.memdagesh = 64318, t.memdageshhebrew = 64318, t.memhebrew = 1502, t.menarmenian = 1396, t.merkhahebrew = 1445, t.merkhakefulahebrew = 1446, t.merkhakefulalefthebrew = 1446, t.merkhalefthebrew = 1445, t.mhook = 625, t.mhzsquare = 13202, t.middledotkatakanahalfwidth = 65381, t.middot = 183, t.mieumacirclekorean = 12914, t.mieumaparenkorean = 12818, t.mieumcirclekorean = 12900, t.mieumkorean = 12609, t.mieumpansioskorean = 12656, t.mieumparenkorean = 12804, t.mieumpieupkorean = 12654, t.mieumsioskorean = 12655, t.mihiragana = 12415, t.mikatakana = 12511, t.mikatakanahalfwidth = 65424, t.minus = 8722, t.minusbelowcmb = 800, t.minuscircle = 8854, t.minusmod = 727, t.minusplus = 8723, t.minute = 8242, t.miribaarusquare = 13130, t.mirisquare = 13129, t.mlonglegturned = 624, t.mlsquare = 13206, t.mmcubedsquare = 13219, t.mmonospace = 65357, t.mmsquaredsquare = 13215, t.mohiragana = 12418, t.mohmsquare = 13249, t.mokatakana = 12514, t.mokatakanahalfwidth = 65427, t.molsquare = 13270, t.momathai = 3617, t.moverssquare = 13223, t.moverssquaredsquare = 13224, t.mparen = 9384, t.mpasquare = 13227, t.mssquare = 13235, t.msuperior = 63215, t.mturned = 623, t.mu = 181, t.mu1 = 181, t.muasquare = 13186, t.muchgreater = 8811, t.muchless = 8810, t.mufsquare = 13196, t.mugreek = 956, t.mugsquare = 13197, t.muhiragana = 12416, t.mukatakana = 12512, t.mukatakanahalfwidth = 65425, t.mulsquare = 13205, t.multiply = 215, t.mumsquare = 13211, t.munahhebrew = 1443, t.munahlefthebrew = 1443, t.musicalnote = 9834, t.musicalnotedbl = 9835, t.musicflatsign = 9837, t.musicsharpsign = 9839, t.mussquare = 13234, t.muvsquare = 13238, t.muwsquare = 13244, t.mvmegasquare = 13241, t.mvsquare = 13239, t.mwmegasquare = 13247, t.mwsquare = 13245, t.n = 110, t.nabengali = 2472, t.nabla = 8711, t.nacute = 324, t.nadeva = 2344, t.nagujarati = 2728, t.nagurmukhi = 2600, t.nahiragana = 12394, t.nakatakana = 12490, t.nakatakanahalfwidth = 65413, t.napostrophe = 329, t.nasquare = 13185, t.nbopomofo = 12555, t.nbspace = 160, t.ncaron = 328, t.ncedilla = 326, t.ncircle = 9437, t.ncircumflexbelow = 7755, t.ncommaaccent = 326, t.ndotaccent = 7749, t.ndotbelow = 7751, t.nehiragana = 12397, t.nekatakana = 12493, t.nekatakanahalfwidth = 65416, t.newsheqelsign = 8362, t.nfsquare = 13195, t.ngabengali = 2457, t.ngadeva = 2329, t.ngagujarati = 2713, t.ngagurmukhi = 2585, t.ngonguthai = 3591, t.nhiragana = 12435, t.nhookleft = 626, t.nhookretroflex = 627, t.nieunacirclekorean = 12911, t.nieunaparenkorean = 12815, t.nieuncieuckorean = 12597, t.nieuncirclekorean = 12897, t.nieunhieuhkorean = 12598, t.nieunkorean = 12596, t.nieunpansioskorean = 12648, t.nieunparenkorean = 12801, t.nieunsioskorean = 12647, t.nieuntikeutkorean = 12646, t.nihiragana = 12395, t.nikatakana = 12491, t.nikatakanahalfwidth = 65414, t.nikhahitleftthai = 63641, t.nikhahitthai = 3661, t.nine = 57, t.ninearabic = 1641, t.ninebengali = 2543, t.ninecircle = 9320, t.ninecircleinversesansserif = 10130, t.ninedeva = 2415, t.ninegujarati = 2799, t.ninegurmukhi = 2671, t.ninehackarabic = 1641, t.ninehangzhou = 12329, t.nineideographicparen = 12840, t.nineinferior = 8329, t.ninemonospace = 65305, t.nineoldstyle = 63289, t.nineparen = 9340, t.nineperiod = 9360, t.ninepersian = 1785, t.nineroman = 8568, t.ninesuperior = 8313, t.nineteencircle = 9330, t.nineteenparen = 9350, t.nineteenperiod = 9370, t.ninethai = 3673, t.nj = 460, t.njecyrillic = 1114, t.nkatakana = 12531, t.nkatakanahalfwidth = 65437, t.nlegrightlong = 414, t.nlinebelow = 7753, t.nmonospace = 65358, t.nmsquare = 13210, t.nnabengali = 2467, t.nnadeva = 2339, t.nnagujarati = 2723, t.nnagurmukhi = 2595, t.nnnadeva = 2345, t.nohiragana = 12398, t.nokatakana = 12494, t.nokatakanahalfwidth = 65417, t.nonbreakingspace = 160, t.nonenthai = 3603, t.nonuthai = 3609, t.noonarabic = 1606, t.noonfinalarabic = 65254, t.noonghunnaarabic = 1722, t.noonghunnafinalarabic = 64415, t.nooninitialarabic = 65255, t.noonjeeminitialarabic = 64722, t.noonjeemisolatedarabic = 64587, t.noonmedialarabic = 65256, t.noonmeeminitialarabic = 64725, t.noonmeemisolatedarabic = 64590, t.noonnoonfinalarabic = 64653, t.notcontains = 8716, t.notelement = 8713, t.notelementof = 8713, t.notequal = 8800, t.notgreater = 8815, t.notgreaternorequal = 8817, t.notgreaternorless = 8825, t.notidentical = 8802, t.notless = 8814, t.notlessnorequal = 8816, t.notparallel = 8742, t.notprecedes = 8832, t.notsubset = 8836, t.notsucceeds = 8833, t.notsuperset = 8837, t.nowarmenian = 1398, t.nparen = 9385, t.nssquare = 13233, t.nsuperior = 8319, t.ntilde = 241, t.nu = 957, t.nuhiragana = 12396, t.nukatakana = 12492, t.nukatakanahalfwidth = 65415, t.nuktabengali = 2492, t.nuktadeva = 2364, t.nuktagujarati = 2748, t.nuktagurmukhi = 2620, t.numbersign = 35, t.numbersignmonospace = 65283, t.numbersignsmall = 65119, t.numeralsigngreek = 884, t.numeralsignlowergreek = 885, t.numero = 8470, t.nun = 1504, t.nundagesh = 64320, t.nundageshhebrew = 64320, t.nunhebrew = 1504, t.nvsquare = 13237, t.nwsquare = 13243, t.nyabengali = 2462, t.nyadeva = 2334, t.nyagujarati = 2718, t.nyagurmukhi = 2590, t.o = 111, t.oacute = 243, t.oangthai = 3629, t.obarred = 629, t.obarredcyrillic = 1257, t.obarreddieresiscyrillic = 1259, t.obengali = 2451, t.obopomofo = 12571, t.obreve = 335, t.ocandradeva = 2321, t.ocandragujarati = 2705, t.ocandravowelsigndeva = 2377, t.ocandravowelsigngujarati = 2761, t.ocaron = 466, t.ocircle = 9438, t.ocircumflex = 244, t.ocircumflexacute = 7889, t.ocircumflexdotbelow = 7897, t.ocircumflexgrave = 7891, t.ocircumflexhookabove = 7893, t.ocircumflextilde = 7895, t.ocyrillic = 1086, t.odblacute = 337, t.odblgrave = 525, t.odeva = 2323, t.odieresis = 246, t.odieresiscyrillic = 1255, t.odotbelow = 7885, t.oe = 339, t.oekorean = 12634, t.ogonek = 731, t.ogonekcmb = 808, t.ograve = 242, t.ogujarati = 2707, t.oharmenian = 1413, t.ohiragana = 12362, t.ohookabove = 7887, t.ohorn = 417, t.ohornacute = 7899, t.ohorndotbelow = 7907, t.ohorngrave = 7901, t.ohornhookabove = 7903, t.ohorntilde = 7905, t.ohungarumlaut = 337, t.oi = 419, t.oinvertedbreve = 527, t.okatakana = 12458, t.okatakanahalfwidth = 65397, t.okorean = 12631, t.olehebrew = 1451, t.omacron = 333, t.omacronacute = 7763, t.omacrongrave = 7761, t.omdeva = 2384, t.omega = 969, t.omega1 = 982, t.omegacyrillic = 1121, t.omegalatinclosed = 631, t.omegaroundcyrillic = 1147, t.omegatitlocyrillic = 1149, t.omegatonos = 974, t.omgujarati = 2768, t.omicron = 959, t.omicrontonos = 972, t.omonospace = 65359, t.one = 49, t.onearabic = 1633, t.onebengali = 2535, t.onecircle = 9312, t.onecircleinversesansserif = 10122, t.onedeva = 2407, t.onedotenleader = 8228, t.oneeighth = 8539, t.onefitted = 63196, t.onegujarati = 2791, t.onegurmukhi = 2663, t.onehackarabic = 1633, t.onehalf = 189, t.onehangzhou = 12321, t.oneideographicparen = 12832, t.oneinferior = 8321, t.onemonospace = 65297, t.onenumeratorbengali = 2548, t.oneoldstyle = 63281, t.oneparen = 9332, t.oneperiod = 9352, t.onepersian = 1777, t.onequarter = 188, t.oneroman = 8560, t.onesuperior = 185, t.onethai = 3665, t.onethird = 8531, t.oogonek = 491, t.oogonekmacron = 493, t.oogurmukhi = 2579, t.oomatragurmukhi = 2635, t.oopen = 596, t.oparen = 9386, t.openbullet = 9702, t.option = 8997, t.ordfeminine = 170, t.ordmasculine = 186, t.orthogonal = 8735, t.oshortdeva = 2322, t.oshortvowelsigndeva = 2378, t.oslash = 248, t.oslashacute = 511, t.osmallhiragana = 12361, t.osmallkatakana = 12457, t.osmallkatakanahalfwidth = 65387, t.ostrokeacute = 511, t.osuperior = 63216, t.otcyrillic = 1151, t.otilde = 245, t.otildeacute = 7757, t.otildedieresis = 7759, t.oubopomofo = 12577, t.overline = 8254, t.overlinecenterline = 65098, t.overlinecmb = 773, t.overlinedashed = 65097, t.overlinedblwavy = 65100, t.overlinewavy = 65099, t.overscore = 175, t.ovowelsignbengali = 2507, t.ovowelsigndeva = 2379, t.ovowelsigngujarati = 2763, t.p = 112, t.paampssquare = 13184, t.paasentosquare = 13099, t.pabengali = 2474, t.pacute = 7765, t.padeva = 2346, t.pagedown = 8671, t.pageup = 8670, t.pagujarati = 2730, t.pagurmukhi = 2602, t.pahiragana = 12401, t.paiyannoithai = 3631, t.pakatakana = 12497, t.palatalizationcyrilliccmb = 1156, t.palochkacyrillic = 1216, t.pansioskorean = 12671, t.paragraph = 182, t.parallel = 8741, t.parenleft = 40, t.parenleftaltonearabic = 64830, t.parenleftbt = 63725, t.parenleftex = 63724, t.parenleftinferior = 8333, t.parenleftmonospace = 65288, t.parenleftsmall = 65113, t.parenleftsuperior = 8317, t.parenlefttp = 63723, t.parenleftvertical = 65077, t.parenright = 41, t.parenrightaltonearabic = 64831, t.parenrightbt = 63736, t.parenrightex = 63735, t.parenrightinferior = 8334, t.parenrightmonospace = 65289, t.parenrightsmall = 65114, t.parenrightsuperior = 8318, t.parenrighttp = 63734, t.parenrightvertical = 65078, t.partialdiff = 8706, t.paseqhebrew = 1472, t.pashtahebrew = 1433, t.pasquare = 13225, t.patah = 1463, t.patah11 = 1463, t.patah1d = 1463, t.patah2a = 1463, t.patahhebrew = 1463, t.patahnarrowhebrew = 1463, t.patahquarterhebrew = 1463, t.patahwidehebrew = 1463, t.pazerhebrew = 1441, t.pbopomofo = 12550, t.pcircle = 9439, t.pdotaccent = 7767, t.pe = 1508, t.pecyrillic = 1087, t.pedagesh = 64324, t.pedageshhebrew = 64324, t.peezisquare = 13115, t.pefinaldageshhebrew = 64323, t.peharabic = 1662, t.peharmenian = 1402, t.pehebrew = 1508, t.pehfinalarabic = 64343, t.pehinitialarabic = 64344, t.pehiragana = 12410, t.pehmedialarabic = 64345, t.pekatakana = 12506, t.pemiddlehookcyrillic = 1191, t.perafehebrew = 64334, t.percent = 37, t.percentarabic = 1642, t.percentmonospace = 65285, t.percentsmall = 65130, t.period = 46, t.periodarmenian = 1417, t.periodcentered = 183, t.periodhalfwidth = 65377, t.periodinferior = 63207, t.periodmonospace = 65294, t.periodsmall = 65106, t.periodsuperior = 63208, t.perispomenigreekcmb = 834, t.perpendicular = 8869, t.perthousand = 8240, t.peseta = 8359, t.pfsquare = 13194, t.phabengali = 2475, t.phadeva = 2347, t.phagujarati = 2731, t.phagurmukhi = 2603, t.phi = 966, t.phi1 = 981, t.phieuphacirclekorean = 12922, t.phieuphaparenkorean = 12826, t.phieuphcirclekorean = 12908, t.phieuphkorean = 12621, t.phieuphparenkorean = 12812, t.philatin = 632, t.phinthuthai = 3642, t.phisymbolgreek = 981, t.phook = 421, t.phophanthai = 3614, t.phophungthai = 3612, t.phosamphaothai = 3616, t.pi = 960, t.pieupacirclekorean = 12915, t.pieupaparenkorean = 12819, t.pieupcieuckorean = 12662, t.pieupcirclekorean = 12901, t.pieupkiyeokkorean = 12658, t.pieupkorean = 12610, t.pieupparenkorean = 12805, t.pieupsioskiyeokkorean = 12660, t.pieupsioskorean = 12612, t.pieupsiostikeutkorean = 12661, t.pieupthieuthkorean = 12663, t.pieuptikeutkorean = 12659, t.pihiragana = 12404, t.pikatakana = 12500, t.pisymbolgreek = 982, t.piwrarmenian = 1411, t.planckover2pi = 8463, t.planckover2pi1 = 8463, t.plus = 43, t.plusbelowcmb = 799, t.pluscircle = 8853, t.plusminus = 177, t.plusmod = 726, t.plusmonospace = 65291, t.plussmall = 65122, t.plussuperior = 8314, t.pmonospace = 65360, t.pmsquare = 13272, t.pohiragana = 12413, t.pointingindexdownwhite = 9759, t.pointingindexleftwhite = 9756, t.pointingindexrightwhite = 9758, t.pointingindexupwhite = 9757, t.pokatakana = 12509, t.poplathai = 3611, t.postalmark = 12306, t.postalmarkface = 12320, t.pparen = 9387, t.precedes = 8826, t.prescription = 8478, t.primemod = 697, t.primereversed = 8245, t.product = 8719, t.projective = 8965, t.prolongedkana = 12540, t.propellor = 8984, t.propersubset = 8834, t.propersuperset = 8835, t.proportion = 8759, t.proportional = 8733, t.psi = 968, t.psicyrillic = 1137, t.psilipneumatacyrilliccmb = 1158, t.pssquare = 13232, t.puhiragana = 12407, t.pukatakana = 12503, t.pvsquare = 13236, t.pwsquare = 13242, t.q = 113, t.qadeva = 2392, t.qadmahebrew = 1448, t.qafarabic = 1602, t.qaffinalarabic = 65238, t.qafinitialarabic = 65239, t.qafmedialarabic = 65240, t.qamats = 1464, t.qamats10 = 1464, t.qamats1a = 1464, t.qamats1c = 1464, t.qamats27 = 1464, t.qamats29 = 1464, t.qamats33 = 1464, t.qamatsde = 1464, t.qamatshebrew = 1464, t.qamatsnarrowhebrew = 1464, t.qamatsqatanhebrew = 1464, t.qamatsqatannarrowhebrew = 1464, t.qamatsqatanquarterhebrew = 1464, t.qamatsqatanwidehebrew = 1464, t.qamatsquarterhebrew = 1464, t.qamatswidehebrew = 1464, t.qarneyparahebrew = 1439, t.qbopomofo = 12561, t.qcircle = 9440, t.qhook = 672, t.qmonospace = 65361, t.qof = 1511, t.qofdagesh = 64327, t.qofdageshhebrew = 64327, t.qofhebrew = 1511, t.qparen = 9388, t.quarternote = 9833, t.qubuts = 1467, t.qubuts18 = 1467, t.qubuts25 = 1467, t.qubuts31 = 1467, t.qubutshebrew = 1467, t.qubutsnarrowhebrew = 1467, t.qubutsquarterhebrew = 1467, t.qubutswidehebrew = 1467, t.question = 63, t.questionarabic = 1567, t.questionarmenian = 1374, t.questiondown = 191, t.questiondownsmall = 63423, t.questiongreek = 894, t.questionmonospace = 65311, t.questionsmall = 63295, t.quotedbl = 34, t.quotedblbase = 8222, t.quotedblleft = 8220, t.quotedblmonospace = 65282, t.quotedblprime = 12318, t.quotedblprimereversed = 12317, t.quotedblright = 8221, t.quoteleft = 8216, t.quoteleftreversed = 8219, t.quotereversed = 8219, t.quoteright = 8217, t.quoterightn = 329, t.quotesinglbase = 8218, t.quotesingle = 39, t.quotesinglemonospace = 65287, t.r = 114, t.raarmenian = 1404, t.rabengali = 2480, t.racute = 341, t.radeva = 2352, t.radical = 8730, t.radicalex = 63717, t.radoverssquare = 13230, t.radoverssquaredsquare = 13231, t.radsquare = 13229, t.rafe = 1471, t.rafehebrew = 1471, t.ragujarati = 2736, t.ragurmukhi = 2608, t.rahiragana = 12425, t.rakatakana = 12521, t.rakatakanahalfwidth = 65431, t.ralowerdiagonalbengali = 2545, t.ramiddlediagonalbengali = 2544, t.ramshorn = 612, t.ratio = 8758, t.rbopomofo = 12566, t.rcaron = 345, t.rcedilla = 343, t.rcircle = 9441, t.rcommaaccent = 343, t.rdblgrave = 529, t.rdotaccent = 7769, t.rdotbelow = 7771, t.rdotbelowmacron = 7773, t.referencemark = 8251, t.reflexsubset = 8838, t.reflexsuperset = 8839, t.registered = 174, t.registersans = 63720, t.registerserif = 63194, t.reharabic = 1585, t.reharmenian = 1408, t.rehfinalarabic = 65198, t.rehiragana = 12428, t.rekatakana = 12524, t.rekatakanahalfwidth = 65434, t.resh = 1512, t.reshdageshhebrew = 64328, t.reshhebrew = 1512, t.reversedtilde = 8765, t.reviahebrew = 1431, t.reviamugrashhebrew = 1431, t.revlogicalnot = 8976, t.rfishhook = 638, t.rfishhookreversed = 639, t.rhabengali = 2525, t.rhadeva = 2397, t.rho = 961, t.rhook = 637, t.rhookturned = 635, t.rhookturnedsuperior = 693, t.rhosymbolgreek = 1009, t.rhotichookmod = 734, t.rieulacirclekorean = 12913, t.rieulaparenkorean = 12817, t.rieulcirclekorean = 12899, t.rieulhieuhkorean = 12608, t.rieulkiyeokkorean = 12602, t.rieulkiyeoksioskorean = 12649, t.rieulkorean = 12601, t.rieulmieumkorean = 12603, t.rieulpansioskorean = 12652, t.rieulparenkorean = 12803, t.rieulphieuphkorean = 12607, t.rieulpieupkorean = 12604, t.rieulpieupsioskorean = 12651, t.rieulsioskorean = 12605, t.rieulthieuthkorean = 12606, t.rieultikeutkorean = 12650, t.rieulyeorinhieuhkorean = 12653, t.rightangle = 8735, t.righttackbelowcmb = 793, t.righttriangle = 8895, t.rihiragana = 12426, t.rikatakana = 12522, t.rikatakanahalfwidth = 65432, t.ring = 730, t.ringbelowcmb = 805, t.ringcmb = 778, t.ringhalfleft = 703, t.ringhalfleftarmenian = 1369, t.ringhalfleftbelowcmb = 796, t.ringhalfleftcentered = 723, t.ringhalfright = 702, t.ringhalfrightbelowcmb = 825, t.ringhalfrightcentered = 722, t.rinvertedbreve = 531, t.rittorusquare = 13137, t.rlinebelow = 7775, t.rlongleg = 636, t.rlonglegturned = 634, t.rmonospace = 65362, t.rohiragana = 12429, t.rokatakana = 12525, t.rokatakanahalfwidth = 65435, t.roruathai = 3619, t.rparen = 9389, t.rrabengali = 2524, t.rradeva = 2353, t.rragurmukhi = 2652, t.rreharabic = 1681, t.rrehfinalarabic = 64397, t.rrvocalicbengali = 2528, t.rrvocalicdeva = 2400, t.rrvocalicgujarati = 2784, t.rrvocalicvowelsignbengali = 2500, t.rrvocalicvowelsigndeva = 2372, t.rrvocalicvowelsigngujarati = 2756, t.rsuperior = 63217, t.rtblock = 9616, t.rturned = 633, t.rturnedsuperior = 692, t.ruhiragana = 12427, t.rukatakana = 12523, t.rukatakanahalfwidth = 65433, t.rupeemarkbengali = 2546, t.rupeesignbengali = 2547, t.rupiah = 63197, t.ruthai = 3620, t.rvocalicbengali = 2443, t.rvocalicdeva = 2315, t.rvocalicgujarati = 2699, t.rvocalicvowelsignbengali = 2499, t.rvocalicvowelsigndeva = 2371, t.rvocalicvowelsigngujarati = 2755, t.s = 115, t.sabengali = 2488, t.sacute = 347, t.sacutedotaccent = 7781, t.sadarabic = 1589, t.sadeva = 2360, t.sadfinalarabic = 65210, t.sadinitialarabic = 65211, t.sadmedialarabic = 65212, t.sagujarati = 2744, t.sagurmukhi = 2616, t.sahiragana = 12373, t.sakatakana = 12469, t.sakatakanahalfwidth = 65403, t.sallallahoualayhewasallamarabic = 65018, t.samekh = 1505, t.samekhdagesh = 64321, t.samekhdageshhebrew = 64321, t.samekhhebrew = 1505, t.saraaathai = 3634, t.saraaethai = 3649, t.saraaimaimalaithai = 3652, t.saraaimaimuanthai = 3651, t.saraamthai = 3635, t.saraathai = 3632, t.saraethai = 3648, t.saraiileftthai = 63622, t.saraiithai = 3637, t.saraileftthai = 63621, t.saraithai = 3636, t.saraothai = 3650, t.saraueeleftthai = 63624, t.saraueethai = 3639, t.saraueleftthai = 63623, t.sarauethai = 3638, t.sarauthai = 3640, t.sarauuthai = 3641, t.sbopomofo = 12569, t.scaron = 353, t.scarondotaccent = 7783, t.scedilla = 351, t.schwa = 601, t.schwacyrillic = 1241, t.schwadieresiscyrillic = 1243, t.schwahook = 602, t.scircle = 9442, t.scircumflex = 349, t.scommaaccent = 537, t.sdotaccent = 7777, t.sdotbelow = 7779, t.sdotbelowdotaccent = 7785, t.seagullbelowcmb = 828, t.second = 8243, t.secondtonechinese = 714, t.section = 167, t.seenarabic = 1587, t.seenfinalarabic = 65202, t.seeninitialarabic = 65203, t.seenmedialarabic = 65204, t.segol = 1462, t.segol13 = 1462, t.segol1f = 1462, t.segol2c = 1462, t.segolhebrew = 1462, t.segolnarrowhebrew = 1462, t.segolquarterhebrew = 1462, t.segoltahebrew = 1426, t.segolwidehebrew = 1462, t.seharmenian = 1405, t.sehiragana = 12379, t.sekatakana = 12475, t.sekatakanahalfwidth = 65406, t.semicolon = 59, t.semicolonarabic = 1563, t.semicolonmonospace = 65307, t.semicolonsmall = 65108, t.semivoicedmarkkana = 12444, t.semivoicedmarkkanahalfwidth = 65439, t.sentisquare = 13090, t.sentosquare = 13091, t.seven = 55, t.sevenarabic = 1639, t.sevenbengali = 2541, t.sevencircle = 9318, t.sevencircleinversesansserif = 10128, t.sevendeva = 2413, t.seveneighths = 8542, t.sevengujarati = 2797, t.sevengurmukhi = 2669, t.sevenhackarabic = 1639, t.sevenhangzhou = 12327, t.sevenideographicparen = 12838, t.seveninferior = 8327, t.sevenmonospace = 65303, t.sevenoldstyle = 63287, t.sevenparen = 9338, t.sevenperiod = 9358, t.sevenpersian = 1783, t.sevenroman = 8566, t.sevensuperior = 8311, t.seventeencircle = 9328, t.seventeenparen = 9348, t.seventeenperiod = 9368, t.seventhai = 3671, t.sfthyphen = 173, t.shaarmenian = 1399, t.shabengali = 2486, t.shacyrillic = 1096, t.shaddaarabic = 1617, t.shaddadammaarabic = 64609, t.shaddadammatanarabic = 64606, t.shaddafathaarabic = 64608, t.shaddakasraarabic = 64610, t.shaddakasratanarabic = 64607, t.shade = 9618, t.shadedark = 9619, t.shadelight = 9617, t.shademedium = 9618, t.shadeva = 2358, t.shagujarati = 2742, t.shagurmukhi = 2614, t.shalshelethebrew = 1427, t.shbopomofo = 12565, t.shchacyrillic = 1097, t.sheenarabic = 1588, t.sheenfinalarabic = 65206, t.sheeninitialarabic = 65207, t.sheenmedialarabic = 65208, t.sheicoptic = 995, t.sheqel = 8362, t.sheqelhebrew = 8362, t.sheva = 1456, t.sheva115 = 1456, t.sheva15 = 1456, t.sheva22 = 1456, t.sheva2e = 1456, t.shevahebrew = 1456, t.shevanarrowhebrew = 1456, t.shevaquarterhebrew = 1456, t.shevawidehebrew = 1456, t.shhacyrillic = 1211, t.shimacoptic = 1005, t.shin = 1513, t.shindagesh = 64329, t.shindageshhebrew = 64329, t.shindageshshindot = 64300, t.shindageshshindothebrew = 64300, t.shindageshsindot = 64301, t.shindageshsindothebrew = 64301, t.shindothebrew = 1473, t.shinhebrew = 1513, t.shinshindot = 64298, t.shinshindothebrew = 64298, t.shinsindot = 64299, t.shinsindothebrew = 64299, t.shook = 642, t.sigma = 963, t.sigma1 = 962, t.sigmafinal = 962, t.sigmalunatesymbolgreek = 1010, t.sihiragana = 12375, t.sikatakana = 12471, t.sikatakanahalfwidth = 65404, t.siluqhebrew = 1469, t.siluqlefthebrew = 1469, t.similar = 8764, t.sindothebrew = 1474, t.siosacirclekorean = 12916, t.siosaparenkorean = 12820, t.sioscieuckorean = 12670, t.sioscirclekorean = 12902, t.sioskiyeokkorean = 12666, t.sioskorean = 12613, t.siosnieunkorean = 12667, t.siosparenkorean = 12806, t.siospieupkorean = 12669, t.siostikeutkorean = 12668, t.six = 54, t.sixarabic = 1638, t.sixbengali = 2540, t.sixcircle = 9317, t.sixcircleinversesansserif = 10127, t.sixdeva = 2412, t.sixgujarati = 2796, t.sixgurmukhi = 2668, t.sixhackarabic = 1638, t.sixhangzhou = 12326, t.sixideographicparen = 12837, t.sixinferior = 8326, t.sixmonospace = 65302, t.sixoldstyle = 63286, t.sixparen = 9337, t.sixperiod = 9357, t.sixpersian = 1782, t.sixroman = 8565, t.sixsuperior = 8310, t.sixteencircle = 9327, t.sixteencurrencydenominatorbengali = 2553, t.sixteenparen = 9347, t.sixteenperiod = 9367, t.sixthai = 3670, t.slash = 47, t.slashmonospace = 65295, t.slong = 383, t.slongdotaccent = 7835, t.smileface = 9786, t.smonospace = 65363, t.sofpasuqhebrew = 1475, t.softhyphen = 173, t.softsigncyrillic = 1100, t.sohiragana = 12381, t.sokatakana = 12477, t.sokatakanahalfwidth = 65407, t.soliduslongoverlaycmb = 824, t.solidusshortoverlaycmb = 823, t.sorusithai = 3625, t.sosalathai = 3624, t.sosothai = 3595, t.sosuathai = 3626, t.space = 32, t.spacehackarabic = 32, t.spade = 9824, t.spadesuitblack = 9824, t.spadesuitwhite = 9828, t.sparen = 9390, t.squarebelowcmb = 827, t.squarecc = 13252, t.squarecm = 13213, t.squarediagonalcrosshatchfill = 9641, t.squarehorizontalfill = 9636, t.squarekg = 13199, t.squarekm = 13214, t.squarekmcapital = 13262, t.squareln = 13265, t.squarelog = 13266, t.squaremg = 13198, t.squaremil = 13269, t.squaremm = 13212, t.squaremsquared = 13217, t.squareorthogonalcrosshatchfill = 9638, t.squareupperlefttolowerrightfill = 9639, t.squareupperrighttolowerleftfill = 9640, t.squareverticalfill = 9637, t.squarewhitewithsmallblack = 9635, t.srsquare = 13275, t.ssabengali = 2487, t.ssadeva = 2359, t.ssagujarati = 2743, t.ssangcieuckorean = 12617, t.ssanghieuhkorean = 12677, t.ssangieungkorean = 12672, t.ssangkiyeokkorean = 12594, t.ssangnieunkorean = 12645, t.ssangpieupkorean = 12611, t.ssangsioskorean = 12614, t.ssangtikeutkorean = 12600, t.ssuperior = 63218, t.sterling = 163, t.sterlingmonospace = 65505, t.strokelongoverlaycmb = 822, t.strokeshortoverlaycmb = 821, t.subset = 8834, t.subsetnotequal = 8842, t.subsetorequal = 8838, t.succeeds = 8827, t.suchthat = 8715, t.suhiragana = 12377, t.sukatakana = 12473, t.sukatakanahalfwidth = 65405, t.sukunarabic = 1618, t.summation = 8721, t.sun = 9788, t.superset = 8835, t.supersetnotequal = 8843, t.supersetorequal = 8839, t.svsquare = 13276, t.syouwaerasquare = 13180, t.t = 116, t.tabengali = 2468, t.tackdown = 8868, t.tackleft = 8867, t.tadeva = 2340, t.tagujarati = 2724, t.tagurmukhi = 2596, t.taharabic = 1591, t.tahfinalarabic = 65218, t.tahinitialarabic = 65219, t.tahiragana = 12383, t.tahmedialarabic = 65220, t.taisyouerasquare = 13181, t.takatakana = 12479, t.takatakanahalfwidth = 65408, t.tatweelarabic = 1600, t.tau = 964, t.tav = 1514, t.tavdages = 64330, t.tavdagesh = 64330, t.tavdageshhebrew = 64330, t.tavhebrew = 1514, t.tbar = 359, t.tbopomofo = 12554, t.tcaron = 357, t.tccurl = 680, t.tcedilla = 355, t.tcheharabic = 1670, t.tchehfinalarabic = 64379, t.tchehinitialarabic = 64380, t.tchehmedialarabic = 64381, t.tcircle = 9443, t.tcircumflexbelow = 7793, t.tcommaaccent = 355, t.tdieresis = 7831, t.tdotaccent = 7787, t.tdotbelow = 7789, t.tecyrillic = 1090, t.tedescendercyrillic = 1197, t.teharabic = 1578, t.tehfinalarabic = 65174, t.tehhahinitialarabic = 64674, t.tehhahisolatedarabic = 64524, t.tehinitialarabic = 65175, t.tehiragana = 12390, t.tehjeeminitialarabic = 64673, t.tehjeemisolatedarabic = 64523, t.tehmarbutaarabic = 1577, t.tehmarbutafinalarabic = 65172, t.tehmedialarabic = 65176, t.tehmeeminitialarabic = 64676, t.tehmeemisolatedarabic = 64526, t.tehnoonfinalarabic = 64627, t.tekatakana = 12486, t.tekatakanahalfwidth = 65411, t.telephone = 8481, t.telephoneblack = 9742, t.telishagedolahebrew = 1440, t.telishaqetanahebrew = 1449, t.tencircle = 9321, t.tenideographicparen = 12841, t.tenparen = 9341, t.tenperiod = 9361, t.tenroman = 8569, t.tesh = 679, t.tet = 1496, t.tetdagesh = 64312, t.tetdageshhebrew = 64312, t.tethebrew = 1496, t.tetsecyrillic = 1205, t.tevirhebrew = 1435, t.tevirlefthebrew = 1435, t.thabengali = 2469, t.thadeva = 2341, t.thagujarati = 2725, t.thagurmukhi = 2597, t.thalarabic = 1584, t.thalfinalarabic = 65196, t.thanthakhatlowleftthai = 63640, t.thanthakhatlowrightthai = 63639, t.thanthakhatthai = 3660, t.thanthakhatupperleftthai = 63638, t.theharabic = 1579, t.thehfinalarabic = 65178, t.thehinitialarabic = 65179, t.thehmedialarabic = 65180, t.thereexists = 8707, t.therefore = 8756, t.theta = 952, t.theta1 = 977, t.thetasymbolgreek = 977, t.thieuthacirclekorean = 12921, t.thieuthaparenkorean = 12825, t.thieuthcirclekorean = 12907, t.thieuthkorean = 12620, t.thieuthparenkorean = 12811, t.thirteencircle = 9324, t.thirteenparen = 9344, t.thirteenperiod = 9364, t.thonangmonthothai = 3601, t.thook = 429, t.thophuthaothai = 3602, t.thorn = 254, t.thothahanthai = 3607, t.thothanthai = 3600, t.thothongthai = 3608, t.thothungthai = 3606, t.thousandcyrillic = 1154, t.thousandsseparatorarabic = 1644, t.thousandsseparatorpersian = 1644, t.three = 51, t.threearabic = 1635, t.threebengali = 2537, t.threecircle = 9314, t.threecircleinversesansserif = 10124, t.threedeva = 2409, t.threeeighths = 8540, t.threegujarati = 2793, t.threegurmukhi = 2665, t.threehackarabic = 1635, t.threehangzhou = 12323, t.threeideographicparen = 12834, t.threeinferior = 8323, t.threemonospace = 65299, t.threenumeratorbengali = 2550, t.threeoldstyle = 63283, t.threeparen = 9334, t.threeperiod = 9354, t.threepersian = 1779, t.threequarters = 190, t.threequartersemdash = 63198, t.threeroman = 8562, t.threesuperior = 179, t.threethai = 3667, t.thzsquare = 13204, t.tihiragana = 12385, t.tikatakana = 12481, t.tikatakanahalfwidth = 65409, t.tikeutacirclekorean = 12912, t.tikeutaparenkorean = 12816, t.tikeutcirclekorean = 12898, t.tikeutkorean = 12599, t.tikeutparenkorean = 12802, t.tilde = 732, t.tildebelowcmb = 816, t.tildecmb = 771, t.tildecomb = 771, t.tildedoublecmb = 864, t.tildeoperator = 8764, t.tildeoverlaycmb = 820, t.tildeverticalcmb = 830, t.timescircle = 8855, t.tipehahebrew = 1430, t.tipehalefthebrew = 1430, t.tippigurmukhi = 2672, t.titlocyrilliccmb = 1155, t.tiwnarmenian = 1407, t.tlinebelow = 7791, t.tmonospace = 65364, t.toarmenian = 1385, t.tohiragana = 12392, t.tokatakana = 12488, t.tokatakanahalfwidth = 65412, t.tonebarextrahighmod = 741, t.tonebarextralowmod = 745, t.tonebarhighmod = 742, t.tonebarlowmod = 744, t.tonebarmidmod = 743, t.tonefive = 445, t.tonesix = 389, t.tonetwo = 424, t.tonos = 900, t.tonsquare = 13095, t.topatakthai = 3599, t.tortoiseshellbracketleft = 12308, t.tortoiseshellbracketleftsmall = 65117, t.tortoiseshellbracketleftvertical = 65081, t.tortoiseshellbracketright = 12309, t.tortoiseshellbracketrightsmall = 65118, t.tortoiseshellbracketrightvertical = 65082, t.totaothai = 3605, t.tpalatalhook = 427, t.tparen = 9391, t.trademark = 8482, t.trademarksans = 63722, t.trademarkserif = 63195, t.tretroflexhook = 648, t.triagdn = 9660, t.triaglf = 9668, t.triagrt = 9658, t.triagup = 9650, t.ts = 678, t.tsadi = 1510, t.tsadidagesh = 64326, t.tsadidageshhebrew = 64326, t.tsadihebrew = 1510, t.tsecyrillic = 1094, t.tsere = 1461, t.tsere12 = 1461, t.tsere1e = 1461, t.tsere2b = 1461, t.tserehebrew = 1461, t.tserenarrowhebrew = 1461, t.tserequarterhebrew = 1461, t.tserewidehebrew = 1461, t.tshecyrillic = 1115, t.tsuperior = 63219, t.ttabengali = 2463, t.ttadeva = 2335, t.ttagujarati = 2719, t.ttagurmukhi = 2591, t.tteharabic = 1657, t.ttehfinalarabic = 64359, t.ttehinitialarabic = 64360, t.ttehmedialarabic = 64361, t.tthabengali = 2464, t.tthadeva = 2336, t.tthagujarati = 2720, t.tthagurmukhi = 2592, t.tturned = 647, t.tuhiragana = 12388, t.tukatakana = 12484, t.tukatakanahalfwidth = 65410, t.tusmallhiragana = 12387, t.tusmallkatakana = 12483, t.tusmallkatakanahalfwidth = 65391, t.twelvecircle = 9323, t.twelveparen = 9343, t.twelveperiod = 9363, t.twelveroman = 8571, t.twentycircle = 9331, t.twentyhangzhou = 21316, t.twentyparen = 9351, t.twentyperiod = 9371, t.two = 50, t.twoarabic = 1634, t.twobengali = 2536, t.twocircle = 9313, t.twocircleinversesansserif = 10123, t.twodeva = 2408, t.twodotenleader = 8229, t.twodotleader = 8229, t.twodotleadervertical = 65072, t.twogujarati = 2792, t.twogurmukhi = 2664, t.twohackarabic = 1634, t.twohangzhou = 12322, t.twoideographicparen = 12833, t.twoinferior = 8322, t.twomonospace = 65298, t.twonumeratorbengali = 2549, t.twooldstyle = 63282, t.twoparen = 9333, t.twoperiod = 9353, t.twopersian = 1778, t.tworoman = 8561, t.twostroke = 443, t.twosuperior = 178, t.twothai = 3666, t.twothirds = 8532, t.u = 117, t.uacute = 250, t.ubar = 649, t.ubengali = 2441, t.ubopomofo = 12584, t.ubreve = 365, t.ucaron = 468, t.ucircle = 9444, t.ucircumflex = 251, t.ucircumflexbelow = 7799, t.ucyrillic = 1091, t.udattadeva = 2385, t.udblacute = 369, t.udblgrave = 533, t.udeva = 2313, t.udieresis = 252, t.udieresisacute = 472, t.udieresisbelow = 7795, t.udieresiscaron = 474, t.udieresiscyrillic = 1265, t.udieresisgrave = 476, t.udieresismacron = 470, t.udotbelow = 7909, t.ugrave = 249, t.ugujarati = 2697, t.ugurmukhi = 2569, t.uhiragana = 12358, t.uhookabove = 7911, t.uhorn = 432, t.uhornacute = 7913, t.uhorndotbelow = 7921, t.uhorngrave = 7915, t.uhornhookabove = 7917, t.uhorntilde = 7919, t.uhungarumlaut = 369, t.uhungarumlautcyrillic = 1267, t.uinvertedbreve = 535, t.ukatakana = 12454, t.ukatakanahalfwidth = 65395, t.ukcyrillic = 1145, t.ukorean = 12636, t.umacron = 363, t.umacroncyrillic = 1263, t.umacrondieresis = 7803, t.umatragurmukhi = 2625, t.umonospace = 65365, t.underscore = 95, t.underscoredbl = 8215, t.underscoremonospace = 65343, t.underscorevertical = 65075, t.underscorewavy = 65103, t.union = 8746, t.universal = 8704, t.uogonek = 371, t.uparen = 9392, t.upblock = 9600, t.upperdothebrew = 1476, t.upsilon = 965, t.upsilondieresis = 971, t.upsilondieresistonos = 944, t.upsilonlatin = 650, t.upsilontonos = 973, t.uptackbelowcmb = 797, t.uptackmod = 724, t.uragurmukhi = 2675, t.uring = 367, t.ushortcyrillic = 1118, t.usmallhiragana = 12357, t.usmallkatakana = 12453, t.usmallkatakanahalfwidth = 65385, t.ustraightcyrillic = 1199, t.ustraightstrokecyrillic = 1201, t.utilde = 361, t.utildeacute = 7801, t.utildebelow = 7797, t.uubengali = 2442, t.uudeva = 2314, t.uugujarati = 2698, t.uugurmukhi = 2570, t.uumatragurmukhi = 2626, t.uuvowelsignbengali = 2498, t.uuvowelsigndeva = 2370, t.uuvowelsigngujarati = 2754, t.uvowelsignbengali = 2497, t.uvowelsigndeva = 2369, t.uvowelsigngujarati = 2753, t.v = 118, t.vadeva = 2357, t.vagujarati = 2741, t.vagurmukhi = 2613, t.vakatakana = 12535, t.vav = 1493, t.vavdagesh = 64309, t.vavdagesh65 = 64309, t.vavdageshhebrew = 64309, t.vavhebrew = 1493, t.vavholam = 64331, t.vavholamhebrew = 64331, t.vavvavhebrew = 1520, t.vavyodhebrew = 1521, t.vcircle = 9445, t.vdotbelow = 7807, t.vecyrillic = 1074, t.veharabic = 1700, t.vehfinalarabic = 64363, t.vehinitialarabic = 64364, t.vehmedialarabic = 64365, t.vekatakana = 12537, t.venus = 9792, t.verticalbar = 124, t.verticallineabovecmb = 781, t.verticallinebelowcmb = 809, t.verticallinelowmod = 716, t.verticallinemod = 712, t.vewarmenian = 1406, t.vhook = 651, t.vikatakana = 12536, t.viramabengali = 2509, t.viramadeva = 2381, t.viramagujarati = 2765, t.visargabengali = 2435, t.visargadeva = 2307, t.visargagujarati = 2691, t.vmonospace = 65366, t.voarmenian = 1400, t.voicediterationhiragana = 12446, t.voicediterationkatakana = 12542, t.voicedmarkkana = 12443, t.voicedmarkkanahalfwidth = 65438, t.vokatakana = 12538, t.vparen = 9393, t.vtilde = 7805, t.vturned = 652, t.vuhiragana = 12436, t.vukatakana = 12532, t.w = 119, t.wacute = 7811, t.waekorean = 12633, t.wahiragana = 12431, t.wakatakana = 12527, t.wakatakanahalfwidth = 65436, t.wakorean = 12632, t.wasmallhiragana = 12430, t.wasmallkatakana = 12526, t.wattosquare = 13143, t.wavedash = 12316, t.wavyunderscorevertical = 65076, t.wawarabic = 1608, t.wawfinalarabic = 65262, t.wawhamzaabovearabic = 1572, t.wawhamzaabovefinalarabic = 65158, t.wbsquare = 13277, t.wcircle = 9446, t.wcircumflex = 373, t.wdieresis = 7813, t.wdotaccent = 7815, t.wdotbelow = 7817, t.wehiragana = 12433, t.weierstrass = 8472, t.wekatakana = 12529, t.wekorean = 12638, t.weokorean = 12637, t.wgrave = 7809, t.whitebullet = 9702, t.whitecircle = 9675, t.whitecircleinverse = 9689, t.whitecornerbracketleft = 12302, t.whitecornerbracketleftvertical = 65091, t.whitecornerbracketright = 12303, t.whitecornerbracketrightvertical = 65092, t.whitediamond = 9671, t.whitediamondcontainingblacksmalldiamond = 9672, t.whitedownpointingsmalltriangle = 9663, t.whitedownpointingtriangle = 9661, t.whiteleftpointingsmalltriangle = 9667, t.whiteleftpointingtriangle = 9665, t.whitelenticularbracketleft = 12310, t.whitelenticularbracketright = 12311, t.whiterightpointingsmalltriangle = 9657, t.whiterightpointingtriangle = 9655, t.whitesmallsquare = 9643, t.whitesmilingface = 9786, t.whitesquare = 9633, t.whitestar = 9734, t.whitetelephone = 9743, t.whitetortoiseshellbracketleft = 12312, t.whitetortoiseshellbracketright = 12313, t.whiteuppointingsmalltriangle = 9653, t.whiteuppointingtriangle = 9651, t.wihiragana = 12432, t.wikatakana = 12528, t.wikorean = 12639, t.wmonospace = 65367, t.wohiragana = 12434, t.wokatakana = 12530, t.wokatakanahalfwidth = 65382, t.won = 8361, t.wonmonospace = 65510, t.wowaenthai = 3623, t.wparen = 9394, t.wring = 7832, t.wsuperior = 695, t.wturned = 653, t.wynn = 447, t.x = 120, t.xabovecmb = 829, t.xbopomofo = 12562, t.xcircle = 9447, t.xdieresis = 7821, t.xdotaccent = 7819, t.xeharmenian = 1389, t.xi = 958, t.xmonospace = 65368, t.xparen = 9395, t.xsuperior = 739, t.y = 121, t.yaadosquare = 13134, t.yabengali = 2479, t.yacute = 253, t.yadeva = 2351, t.yaekorean = 12626, t.yagujarati = 2735, t.yagurmukhi = 2607, t.yahiragana = 12420, t.yakatakana = 12516, t.yakatakanahalfwidth = 65428, t.yakorean = 12625, t.yamakkanthai = 3662, t.yasmallhiragana = 12419, t.yasmallkatakana = 12515, t.yasmallkatakanahalfwidth = 65388, t.yatcyrillic = 1123, t.ycircle = 9448, t.ycircumflex = 375, t.ydieresis = 255, t.ydotaccent = 7823, t.ydotbelow = 7925, t.yeharabic = 1610, t.yehbarreearabic = 1746, t.yehbarreefinalarabic = 64431, t.yehfinalarabic = 65266, t.yehhamzaabovearabic = 1574, t.yehhamzaabovefinalarabic = 65162, t.yehhamzaaboveinitialarabic = 65163, t.yehhamzaabovemedialarabic = 65164, t.yehinitialarabic = 65267, t.yehmedialarabic = 65268, t.yehmeeminitialarabic = 64733, t.yehmeemisolatedarabic = 64600, t.yehnoonfinalarabic = 64660, t.yehthreedotsbelowarabic = 1745, t.yekorean = 12630, t.yen = 165, t.yenmonospace = 65509, t.yeokorean = 12629, t.yeorinhieuhkorean = 12678, t.yerahbenyomohebrew = 1450, t.yerahbenyomolefthebrew = 1450, t.yericyrillic = 1099, t.yerudieresiscyrillic = 1273, t.yesieungkorean = 12673, t.yesieungpansioskorean = 12675, t.yesieungsioskorean = 12674, t.yetivhebrew = 1434, t.ygrave = 7923, t.yhook = 436, t.yhookabove = 7927, t.yiarmenian = 1397, t.yicyrillic = 1111, t.yikorean = 12642, t.yinyang = 9775, t.yiwnarmenian = 1410, t.ymonospace = 65369, t.yod = 1497, t.yoddagesh = 64313, t.yoddageshhebrew = 64313, t.yodhebrew = 1497, t.yodyodhebrew = 1522, t.yodyodpatahhebrew = 64287, t.yohiragana = 12424, t.yoikorean = 12681, t.yokatakana = 12520, t.yokatakanahalfwidth = 65430, t.yokorean = 12635, t.yosmallhiragana = 12423, t.yosmallkatakana = 12519, t.yosmallkatakanahalfwidth = 65390, t.yotgreek = 1011, t.yoyaekorean = 12680, t.yoyakorean = 12679, t.yoyakthai = 3618, t.yoyingthai = 3597, t.yparen = 9396, t.ypogegrammeni = 890, t.ypogegrammenigreekcmb = 837, t.yr = 422, t.yring = 7833, t.ysuperior = 696, t.ytilde = 7929, t.yturned = 654, t.yuhiragana = 12422, t.yuikorean = 12684, t.yukatakana = 12518, t.yukatakanahalfwidth = 65429, t.yukorean = 12640, t.yusbigcyrillic = 1131, t.yusbigiotifiedcyrillic = 1133, t.yuslittlecyrillic = 1127, t.yuslittleiotifiedcyrillic = 1129, t.yusmallhiragana = 12421, t.yusmallkatakana = 12517, t.yusmallkatakanahalfwidth = 65389, t.yuyekorean = 12683, t.yuyeokorean = 12682, t.yyabengali = 2527, t.yyadeva = 2399, t.z = 122, t.zaarmenian = 1382, t.zacute = 378, t.zadeva = 2395, t.zagurmukhi = 2651, t.zaharabic = 1592, t.zahfinalarabic = 65222, t.zahinitialarabic = 65223, t.zahiragana = 12374, t.zahmedialarabic = 65224, t.zainarabic = 1586, t.zainfinalarabic = 65200, t.zakatakana = 12470, t.zaqefgadolhebrew = 1429, t.zaqefqatanhebrew = 1428, t.zarqahebrew = 1432, t.zayin = 1494, t.zayindagesh = 64310, t.zayindageshhebrew = 64310, t.zayinhebrew = 1494, t.zbopomofo = 12567, t.zcaron = 382, t.zcircle = 9449, t.zcircumflex = 7825, t.zcurl = 657, t.zdot = 380, t.zdotaccent = 380, t.zdotbelow = 7827, t.zecyrillic = 1079, t.zedescendercyrillic = 1177, t.zedieresiscyrillic = 1247, t.zehiragana = 12380, t.zekatakana = 12476, t.zero = 48, t.zeroarabic = 1632, t.zerobengali = 2534, t.zerodeva = 2406, t.zerogujarati = 2790, t.zerogurmukhi = 2662, t.zerohackarabic = 1632, t.zeroinferior = 8320, t.zeromonospace = 65296, t.zerooldstyle = 63280, t.zeropersian = 1776, t.zerosuperior = 8304, t.zerothai = 3664, t.zerowidthjoiner = 65279, t.zerowidthnonjoiner = 8204, t.zerowidthspace = 8203, t.zeta = 950, t.zhbopomofo = 12563, t.zhearmenian = 1386, t.zhebrevecyrillic = 1218, t.zhecyrillic = 1078, t.zhedescendercyrillic = 1175, t.zhedieresiscyrillic = 1245, t.zihiragana = 12376, t.zikatakana = 12472, t.zinorhebrew = 1454, t.zlinebelow = 7829, t.zmonospace = 65370, t.zohiragana = 12382, t.zokatakana = 12478, t.zparen = 9397, t.zretroflexhook = 656, t.zstroke = 438, t.zuhiragana = 12378, t.zukatakana = 12474, t[".notdef"] = 0, t.angbracketleftbig = 9001, t.angbracketleftBig = 9001, t.angbracketleftbigg = 9001, t.angbracketleftBigg = 9001, t.angbracketrightBig = 9002, t.angbracketrightbig = 9002, t.angbracketrightBigg = 9002, t.angbracketrightbigg = 9002, t.arrowhookleft = 8618, t.arrowhookright = 8617, t.arrowlefttophalf = 8636, t.arrowleftbothalf = 8637, t.arrownortheast = 8599, t.arrownorthwest = 8598, t.arrowrighttophalf = 8640, t.arrowrightbothalf = 8641, t.arrowsoutheast = 8600, t.arrowsouthwest = 8601, t.backslashbig = 8726, t.backslashBig = 8726, t.backslashBigg = 8726, t.backslashbigg = 8726, t.bardbl = 8214, t.bracehtipdownleft = 65079, t.bracehtipdownright = 65079, t.bracehtipupleft = 65080, t.bracehtipupright = 65080, t.braceleftBig = 123, t.braceleftbig = 123, t.braceleftbigg = 123, t.braceleftBigg = 123, t.bracerightBig = 125, t.bracerightbig = 125, t.bracerightbigg = 125, t.bracerightBigg = 125, t.bracketleftbig = 91, t.bracketleftBig = 91, t.bracketleftbigg = 91, t.bracketleftBigg = 91, t.bracketrightBig = 93, t.bracketrightbig = 93, t.bracketrightbigg = 93, t.bracketrightBigg = 93, t.ceilingleftbig = 8968, t.ceilingleftBig = 8968, t.ceilingleftBigg = 8968, t.ceilingleftbigg = 8968, t.ceilingrightbig = 8969, t.ceilingrightBig = 8969, t.ceilingrightbigg = 8969, t.ceilingrightBigg = 8969, t.circledotdisplay = 8857, t.circledottext = 8857, t.circlemultiplydisplay = 8855, t.circlemultiplytext = 8855, t.circleplusdisplay = 8853, t.circleplustext = 8853, t.contintegraldisplay = 8750, t.contintegraltext = 8750, t.coproductdisplay = 8720, t.coproducttext = 8720, t.floorleftBig = 8970, t.floorleftbig = 8970, t.floorleftbigg = 8970, t.floorleftBigg = 8970, t.floorrightbig = 8971, t.floorrightBig = 8971, t.floorrightBigg = 8971, t.floorrightbigg = 8971, t.hatwide = 770, t.hatwider = 770, t.hatwidest = 770, t.intercal = 7488, t.integraldisplay = 8747, t.integraltext = 8747, t.intersectiondisplay = 8898, t.intersectiontext = 8898, t.logicalanddisplay = 8743, t.logicalandtext = 8743, t.logicalordisplay = 8744, t.logicalortext = 8744, t.parenleftBig = 40, t.parenleftbig = 40, t.parenleftBigg = 40, t.parenleftbigg = 40, t.parenrightBig = 41, t.parenrightbig = 41, t.parenrightBigg = 41, t.parenrightbigg = 41, t.prime = 8242, t.productdisplay = 8719, t.producttext = 8719, t.radicalbig = 8730, t.radicalBig = 8730, t.radicalBigg = 8730, t.radicalbigg = 8730, t.radicalbt = 8730, t.radicaltp = 8730, t.radicalvertex = 8730, t.slashbig = 47, t.slashBig = 47, t.slashBigg = 47, t.slashbigg = 47, t.summationdisplay = 8721, t.summationtext = 8721, t.tildewide = 732, t.tildewider = 732, t.tildewidest = 732, t.uniondisplay = 8899, t.unionmultidisplay = 8846, t.unionmultitext = 8846, t.unionsqdisplay = 8852, t.unionsqtext = 8852, t.uniontext = 8899, t.vextenddouble = 8741, t.vextendsingle = 8739;
}), qu = ut(function(t) {
  t.space = 32, t.a1 = 9985, t.a2 = 9986, t.a202 = 9987, t.a3 = 9988, t.a4 = 9742, t.a5 = 9990, t.a119 = 9991, t.a118 = 9992, t.a117 = 9993, t.a11 = 9755, t.a12 = 9758, t.a13 = 9996, t.a14 = 9997, t.a15 = 9998, t.a16 = 9999, t.a105 = 1e4, t.a17 = 10001, t.a18 = 10002, t.a19 = 10003, t.a20 = 10004, t.a21 = 10005, t.a22 = 10006, t.a23 = 10007, t.a24 = 10008, t.a25 = 10009, t.a26 = 10010, t.a27 = 10011, t.a28 = 10012, t.a6 = 10013, t.a7 = 10014, t.a8 = 10015, t.a9 = 10016, t.a10 = 10017, t.a29 = 10018, t.a30 = 10019, t.a31 = 10020, t.a32 = 10021, t.a33 = 10022, t.a34 = 10023, t.a35 = 9733, t.a36 = 10025, t.a37 = 10026, t.a38 = 10027, t.a39 = 10028, t.a40 = 10029, t.a41 = 10030, t.a42 = 10031, t.a43 = 10032, t.a44 = 10033, t.a45 = 10034, t.a46 = 10035, t.a47 = 10036, t.a48 = 10037, t.a49 = 10038, t.a50 = 10039, t.a51 = 10040, t.a52 = 10041, t.a53 = 10042, t.a54 = 10043, t.a55 = 10044, t.a56 = 10045, t.a57 = 10046, t.a58 = 10047, t.a59 = 10048, t.a60 = 10049, t.a61 = 10050, t.a62 = 10051, t.a63 = 10052, t.a64 = 10053, t.a65 = 10054, t.a66 = 10055, t.a67 = 10056, t.a68 = 10057, t.a69 = 10058, t.a70 = 10059, t.a71 = 9679, t.a72 = 10061, t.a73 = 9632, t.a74 = 10063, t.a203 = 10064, t.a75 = 10065, t.a204 = 10066, t.a76 = 9650, t.a77 = 9660, t.a78 = 9670, t.a79 = 10070, t.a81 = 9687, t.a82 = 10072, t.a83 = 10073, t.a84 = 10074, t.a97 = 10075, t.a98 = 10076, t.a99 = 10077, t.a100 = 10078, t.a101 = 10081, t.a102 = 10082, t.a103 = 10083, t.a104 = 10084, t.a106 = 10085, t.a107 = 10086, t.a108 = 10087, t.a112 = 9827, t.a111 = 9830, t.a110 = 9829, t.a109 = 9824, t.a120 = 9312, t.a121 = 9313, t.a122 = 9314, t.a123 = 9315, t.a124 = 9316, t.a125 = 9317, t.a126 = 9318, t.a127 = 9319, t.a128 = 9320, t.a129 = 9321, t.a130 = 10102, t.a131 = 10103, t.a132 = 10104, t.a133 = 10105, t.a134 = 10106, t.a135 = 10107, t.a136 = 10108, t.a137 = 10109, t.a138 = 10110, t.a139 = 10111, t.a140 = 10112, t.a141 = 10113, t.a142 = 10114, t.a143 = 10115, t.a144 = 10116, t.a145 = 10117, t.a146 = 10118, t.a147 = 10119, t.a148 = 10120, t.a149 = 10121, t.a150 = 10122, t.a151 = 10123, t.a152 = 10124, t.a153 = 10125, t.a154 = 10126, t.a155 = 10127, t.a156 = 10128, t.a157 = 10129, t.a158 = 10130, t.a159 = 10131, t.a160 = 10132, t.a161 = 8594, t.a163 = 8596, t.a164 = 8597, t.a196 = 10136, t.a165 = 10137, t.a192 = 10138, t.a166 = 10139, t.a167 = 10140, t.a168 = 10141, t.a169 = 10142, t.a170 = 10143, t.a171 = 10144, t.a172 = 10145, t.a173 = 10146, t.a162 = 10147, t.a174 = 10148, t.a175 = 10149, t.a176 = 10150, t.a177 = 10151, t.a178 = 10152, t.a179 = 10153, t.a193 = 10154, t.a180 = 10155, t.a199 = 10156, t.a181 = 10157, t.a200 = 10158, t.a182 = 10159, t.a201 = 10161, t.a183 = 10162, t.a184 = 10163, t.a197 = 10164, t.a185 = 10165, t.a194 = 10166, t.a198 = 10167, t.a186 = 10168, t.a195 = 10169, t.a187 = 10170, t.a188 = 10171, t.a189 = 10172, t.a190 = 10173, t.a191 = 10174, t.a89 = 10088, t.a90 = 10089, t.a93 = 10090, t.a94 = 10091, t.a91 = 10092, t.a92 = 10093, t.a205 = 10094, t.a85 = 10095, t.a206 = 10096, t.a86 = 10097, t.a87 = 10098, t.a88 = 10099, t.a95 = 10100, t.a96 = 10101, t[".notdef"] = 0;
}), Ku = ut(function(t) {
  t[63721] = 169, t[63193] = 169, t[63720] = 174, t[63194] = 174, t[63722] = 8482, t[63195] = 8482, t[63729] = 9127, t[63730] = 9128, t[63731] = 9129, t[63740] = 9131, t[63741] = 9132, t[63742] = 9133, t[63726] = 9121, t[63727] = 9122, t[63728] = 9123, t[63737] = 9124, t[63738] = 9125, t[63739] = 9126, t[63723] = 9115, t[63724] = 9116, t[63725] = 9117, t[63734] = 9118, t[63735] = 9119, t[63736] = 9120;
});
function Yu(t) {
  return t >= 65520 && t <= 65535 ? 0 : t >= 62976 && t <= 63743 ? Ku()[t] || t : t === 173 ? 45 : t;
}
function Li(t, e) {
  let n = e[t];
  if (n !== void 0)
    return n;
  if (!t)
    return -1;
  if (t[0] === "u") {
    const a = t.length;
    let i;
    if (a === 7 && t[1] === "n" && t[2] === "i")
      i = t.substring(3);
    else if (a >= 5 && a <= 7)
      i = t.substring(1);
    else
      return -1;
    if (i === i.toUpperCase() && (n = parseInt(i, 16), n >= 0))
      return n;
  }
  return -1;
}
const T0 = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function Ju(t, e = -1) {
  if (e !== -1) {
    const n = T0[e];
    for (let a = 0, i = n.length; a < i; a += 2)
      if (t >= n[a] && t <= n[a + 1])
        return e;
  }
  for (let n = 0, a = T0.length; n < a; n++) {
    const i = T0[n];
    for (let s = 0, r = i.length; s < r; s += 2)
      if (t >= i[s] && t <= i[s + 1])
        return n;
  }
  return -1;
}
const Zu = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), uo = /* @__PURE__ */ new Map();
function Qu(t) {
  const e = uo.get(t);
  if (e)
    return e;
  const n = t.match(Zu), a = {
    isWhitespace: !!n?.[1],
    isZeroWidthDiacritic: !!n?.[2],
    isInvisibleFormatMark: !!n?.[3]
  };
  return uo.set(t, a), a;
}
function ed() {
  uo.clear();
}
const Mi = !0, Dn = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Nonsymbolic: 32
}, Gc = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function R1(t, e) {
  if (e[t] !== void 0)
    return t;
  const n = Li(t, e);
  if (n !== -1) {
    for (const a in e)
      if (e[a] === n)
        return a;
  }
  return Ue("Unable to recover a standard glyph name for: " + t), t;
}
function O1(t, e, n) {
  const a = /* @__PURE__ */ Object.create(null);
  let i, s, r;
  const o = !!(t.flags & Dn.Symbolic);
  if (t.isInternalFont)
    for (r = e, s = 0; s < r.length; s++)
      i = n.indexOf(r[s]), a[s] = i >= 0 ? i : 0;
  else if (t.baseEncodingName)
    for (r = Ms(t.baseEncodingName), s = 0; s < r.length; s++)
      i = n.indexOf(r[s]), a[s] = i >= 0 ? i : 0;
  else if (o)
    for (s in e)
      a[s] = e[s];
  else
    for (r = xa, s = 0; s < r.length; s++)
      i = n.indexOf(r[s]), a[s] = i >= 0 ? i : 0;
  const c = t.differences;
  let l;
  if (c)
    for (s in c) {
      const h = c[s];
      if (i = n.indexOf(h), i === -1) {
        l || (l = Qn());
        const f = R1(h, l);
        f !== h && (i = n.indexOf(f));
      }
      a[s] = i >= 0 ? i : 0;
    }
  return a;
}
function Vs(t) {
  return t.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const td = ut((t) => {
  t[8211] = 65074, t[8212] = 65073, t[8229] = 65072, t[8230] = 65049, t[12289] = 65041, t[12290] = 65042, t[12296] = 65087, t[12297] = 65088, t[12298] = 65085, t[12299] = 65086, t[12300] = 65089, t[12301] = 65090, t[12302] = 65091, t[12303] = 65092, t[12304] = 65083, t[12305] = 65084, t[12308] = 65081, t[12309] = 65082, t[12310] = 65047, t[12311] = 65048, t[65103] = 65076, t[65281] = 65045, t[65288] = 65077, t[65289] = 65078, t[65292] = 65040, t[65306] = 65043, t[65307] = 65044, t[65311] = 65046, t[65339] = 65095, t[65341] = 65096, t[65343] = 65075, t[65371] = 65079, t[65373] = 65080;
}), zc = 1e3;
function nd({
  data: t,
  width: e,
  height: n
}) {
  if (e > zc || n > zc)
    return null;
  const a = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), s = e + 1, r = new Uint8Array(s * (n + 1));
  let o, c, l;
  const h = e + 7 & -8, f = new Uint8Array(h * n);
  let d = 0;
  for (const v of t) {
    let k = 128;
    for (; k > 0; )
      f[d++] = v & k ? 0 : 255, k >>= 1;
  }
  let u = 0;
  for (d = 0, f[d] !== 0 && (r[0] = 1, ++u), c = 1; c < e; c++)
    f[d] !== f[d + 1] && (r[c] = f[d] ? 2 : 1, ++u), d++;
  for (f[d] !== 0 && (r[c] = 2, ++u), o = 1; o < n; o++) {
    d = o * h, l = o * s, f[d - h] !== f[d] && (r[l] = f[d] ? 1 : 8, ++u);
    let v = (f[d] ? 4 : 0) + (f[d - h] ? 8 : 0);
    for (c = 1; c < e; c++)
      v = (v >> 2) + (f[d + 1] ? 4 : 0) + (f[d - h + 1] ? 8 : 0), i[v] && (r[l + c] = i[v], ++u), d++;
    if (f[d - h] !== f[d] && (r[l + c] = f[d] ? 2 : 4, ++u), u > a)
      return null;
  }
  for (d = h * (n - 1), l = o * s, f[d] !== 0 && (r[l] = 8, ++u), c = 1; c < e; c++)
    f[d] !== f[d + 1] && (r[l + c] = f[d] ? 4 : 8, ++u), d++;
  if (f[d] !== 0 && (r[l + c] = 4, ++u), u > a)
    return null;
  const x = new Int32Array([0, s, -1, 0, -s, 0, 0, 0, 1]), g = [], {
    a: p,
    b: m,
    c: b,
    d: y,
    e: w,
    f: S
  } = new DOMMatrix().scaleSelf(1 / e, -1 / n).translateSelf(0, -n);
  for (o = 0; u && o <= n; o++) {
    let v = o * s;
    const k = v + e;
    for (; v < k && !r[v]; )
      v++;
    if (v === k)
      continue;
    let A = v % s, C = o;
    g.push(Et.moveTo, p * A + b * C + w, m * A + y * C + S);
    const T = v;
    let M = r[v];
    do {
      const O = x[M];
      do
        v += O;
      while (!r[v]);
      const N = r[v];
      N !== 5 && N !== 10 ? (M = N, r[v] = 0) : (M = N & 51 * M >> 4, r[v] &= M >> 2 | M << 2), A = v % s, C = v / s | 0, g.push(Et.lineTo, p * A + b * C + w, m * A + y * C + S), r[v] || --u;
    } while (T !== v);
    --o;
  }
  return [I.rawFillPath, [new Float32Array(g)], new Float32Array([0, 0, e, n])];
}
We(1806);
const ad = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"], id = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], sd = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"], rd = 10, Rr = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], gr = 391, yi = [null, {
  id: "hstem",
  min: 2,
  stackClearing: !0,
  stem: !0
}, null, {
  id: "vstem",
  min: 2,
  stackClearing: !0,
  stem: !0
}, {
  id: "vmoveto",
  min: 1,
  stackClearing: !0
}, {
  id: "rlineto",
  min: 2,
  resetStack: !0
}, {
  id: "hlineto",
  min: 1,
  resetStack: !0
}, {
  id: "vlineto",
  min: 1,
  resetStack: !0
}, {
  id: "rrcurveto",
  min: 6,
  resetStack: !0
}, null, {
  id: "callsubr",
  min: 1,
  undefStack: !0
}, {
  id: "return",
  min: 0,
  undefStack: !0
}, null, null, {
  id: "endchar",
  min: 0,
  stackClearing: !0
}, null, null, null, {
  id: "hstemhm",
  min: 2,
  stackClearing: !0,
  stem: !0
}, {
  id: "hintmask",
  min: 0,
  stackClearing: !0
}, {
  id: "cntrmask",
  min: 0,
  stackClearing: !0
}, {
  id: "rmoveto",
  min: 2,
  stackClearing: !0
}, {
  id: "hmoveto",
  min: 1,
  stackClearing: !0
}, {
  id: "vstemhm",
  min: 2,
  stackClearing: !0,
  stem: !0
}, {
  id: "rcurveline",
  min: 8,
  resetStack: !0
}, {
  id: "rlinecurve",
  min: 8,
  resetStack: !0
}, {
  id: "vvcurveto",
  min: 4,
  resetStack: !0
}, {
  id: "hhcurveto",
  min: 4,
  resetStack: !0
}, null, {
  id: "callgsubr",
  min: 1,
  undefStack: !0
}, {
  id: "vhcurveto",
  min: 4,
  resetStack: !0
}, {
  id: "hvcurveto",
  min: 4,
  resetStack: !0
}], od = [null, null, null, {
  id: "and",
  min: 2,
  stackDelta: -1
}, {
  id: "or",
  min: 2,
  stackDelta: -1
}, {
  id: "not",
  min: 1,
  stackDelta: 0
}, null, null, null, {
  id: "abs",
  min: 1,
  stackDelta: 0
}, {
  id: "add",
  min: 2,
  stackDelta: -1,
  stackFn(t, e) {
    t[e - 2] = t[e - 2] + t[e - 1];
  }
}, {
  id: "sub",
  min: 2,
  stackDelta: -1,
  stackFn(t, e) {
    t[e - 2] = t[e - 2] - t[e - 1];
  }
}, {
  id: "div",
  min: 2,
  stackDelta: -1,
  stackFn(t, e) {
    t[e - 2] = t[e - 2] / t[e - 1];
  }
}, null, {
  id: "neg",
  min: 1,
  stackDelta: 0,
  stackFn(t, e) {
    t[e - 1] = -t[e - 1];
  }
}, {
  id: "eq",
  min: 2,
  stackDelta: -1
}, null, null, {
  id: "drop",
  min: 1,
  stackDelta: -1
}, null, {
  id: "put",
  min: 2,
  stackDelta: -2
}, {
  id: "get",
  min: 1,
  stackDelta: 0
}, {
  id: "ifelse",
  min: 4,
  stackDelta: -3
}, {
  id: "random",
  min: 0,
  stackDelta: 1
}, {
  id: "mul",
  min: 2,
  stackDelta: -1,
  stackFn(t, e) {
    t[e - 2] = t[e - 2] * t[e - 1];
  }
}, null, {
  id: "sqrt",
  min: 1,
  stackDelta: 0
}, {
  id: "dup",
  min: 1,
  stackDelta: 1
}, {
  id: "exch",
  min: 2,
  stackDelta: 0
}, {
  id: "index",
  min: 2,
  stackDelta: 0
}, {
  id: "roll",
  min: 3,
  stackDelta: -2
}, null, null, null, {
  id: "hflex",
  min: 7,
  resetStack: !0
}, {
  id: "flex",
  min: 13,
  resetStack: !0
}, {
  id: "hflex1",
  min: 9,
  resetStack: !0
}, {
  id: "flex1",
  min: 11,
  resetStack: !0
}];
class Go {
  constructor(e, n, a) {
    this.bytes = e.getBytes(), this.properties = n, this.seacAnalysisEnabled = !!a;
  }
  parse() {
    const e = this.properties, n = new B1();
    this.cff = n;
    const a = this.parseHeader(), i = this.parseIndex(a.endPos), s = this.parseIndex(i.endPos), r = this.parseIndex(s.endPos), o = this.parseIndex(r.endPos), c = this.parseDict(s.obj.get(0)), l = this.createDict(Ps, c, n.strings);
    n.header = a.obj, n.names = this.parseNameIndex(i.obj), n.strings = this.parseStringIndex(r.obj), n.topDict = l, n.globalSubrIndex = o.obj, this.parsePrivateDict(n.topDict), n.isCIDFont = l.hasName("ROS");
    const h = l.getByName("CharStrings"), f = this.parseIndex(h).obj, d = l.getByName("FontMatrix");
    d && (e.fontMatrix = d);
    const u = l.getByName("FontBBox");
    u && (e.ascent = Math.max(u[3], u[1]), e.descent = Math.min(u[1], u[3]), e.ascentScaled = !0);
    let x, g;
    if (n.isCIDFont) {
      const m = this.parseIndex(l.getByName("FDArray")).obj;
      for (let b = 0, y = m.count; b < y; ++b) {
        const w = m.get(b), S = this.createDict(Ps, this.parseDict(w), n.strings);
        this.parsePrivateDict(S), n.fdArray.push(S);
      }
      g = null, x = this.parseCharsets(l.getByName("charset"), f.count, n.strings, !0), n.fdSelect = this.parseFDSelect(l.getByName("FDSelect"), f.count);
    } else
      x = this.parseCharsets(l.getByName("charset"), f.count, n.strings, !1), g = this.parseEncoding(l.getByName("Encoding"), e, n.strings, x.charset);
    n.charset = x, n.encoding = g;
    const p = this.parseCharStrings({
      charStrings: f,
      localSubrIndex: l.privateDict.subrsIndex,
      globalSubrIndex: o.obj,
      fdSelect: n.fdSelect,
      fdArray: n.fdArray,
      privateDict: l.privateDict
    });
    return n.charStrings = p.charStrings, n.seacs = p.seacs, n.widths = p.widths, n;
  }
  parseHeader() {
    let e = this.bytes;
    const n = e.length;
    let a = 0;
    for (; a < n && e[a] !== 1; )
      ++a;
    if (a >= n)
      throw new W("Invalid CFF header");
    a !== 0 && (Ue("cff data is shifted"), e = e.subarray(a), this.bytes = e);
    const i = e[0], s = e[1], r = e[2], o = e[3];
    return {
      obj: new M1(i, s, r, o),
      endPos: r
    };
  }
  parseDict(e) {
    let n = 0;
    function a() {
      let c = e[n++];
      return c === 30 ? i() : c === 28 ? (c = ha(e, n), n += 2, c) : c === 29 ? (c = e[n++], c = c << 8 | e[n++], c = c << 8 | e[n++], c = c << 8 | e[n++], c) : c >= 32 && c <= 246 ? c - 139 : c >= 247 && c <= 250 ? (c - 247) * 256 + e[n++] + 108 : c >= 251 && c <= 254 ? -((c - 251) * 256) - e[n++] - 108 : (F('CFFParser_parseDict: "' + c + '" is a reserved command.'), NaN);
    }
    function i() {
      let c = "";
      const h = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], f = e.length;
      for (; n < f; ) {
        const d = e[n++], u = d >> 4, x = d & 15;
        if (u === 15 || (c += h[u], x === 15))
          break;
        c += h[x];
      }
      return parseFloat(c);
    }
    let s = [];
    const r = [];
    n = 0;
    const o = e.length;
    for (; n < o; ) {
      let c = e[n];
      c <= 21 ? (c === 12 && (c = c << 8 | e[++n]), r.push([c, s]), s = [], ++n) : s.push(a());
    }
    return r;
  }
  parseIndex(e) {
    const n = new Ba(), a = this.bytes, i = a[e++] << 8 | a[e++], s = [];
    let r = e, o, c;
    if (i !== 0) {
      const l = a[e++], h = e + (i + 1) * l - 1;
      for (o = 0, c = i + 1; o < c; ++o) {
        let f = 0;
        for (let d = 0; d < l; ++d)
          f <<= 8, f += a[e++];
        s.push(h + f);
      }
      r = s[i];
    }
    for (o = 0, c = s.length - 1; o < c; ++o) {
      const l = s[o], h = s[o + 1];
      n.add(a.subarray(l, h));
    }
    return {
      obj: n,
      endPos: r
    };
  }
  parseNameIndex(e) {
    const n = [];
    for (let a = 0, i = e.count; a < i; ++a) {
      const s = e.get(a);
      n.push(xn(s));
    }
    return n;
  }
  parseStringIndex(e) {
    const n = new zo();
    for (let a = 0, i = e.count; a < i; ++a) {
      const s = e.get(a);
      n.add(xn(s));
    }
    return n;
  }
  createDict(e, n, a) {
    const i = new e(a);
    for (const [s, r] of n)
      i.setByKey(s, r);
    return i;
  }
  parseCharString(e, n, a, i) {
    if (!n || e.callDepth > rd)
      return !1;
    let s = e.stackSize;
    const r = e.stack;
    let o = n.length;
    for (let c = 0; c < o; ) {
      const l = n[c++];
      let h = null;
      if (l === 12) {
        const f = n[c++];
        f === 0 ? (n[c - 2] = 139, n[c - 1] = 22, s = 0) : h = od[f];
      } else if (l === 28)
        r[s] = ha(n, c), c += 2, s++;
      else if (l === 14) {
        if (s >= 4 && (s -= 4, this.seacAnalysisEnabled))
          return e.seac = r.slice(s, s + 4), !1;
        h = yi[l];
      } else if (l >= 32 && l <= 246)
        r[s] = l - 139, s++;
      else if (l >= 247 && l <= 254)
        r[s] = l < 251 ? (l - 247 << 8) + n[c] + 108 : -(l - 251 << 8) - n[c] - 108, c++, s++;
      else if (l === 255)
        r[s] = (n[c] << 24 | n[c + 1] << 16 | n[c + 2] << 8 | n[c + 3]) / 65536, c += 4, s++;
      else if (l === 19 || l === 20) {
        if (e.hints += s >> 1, e.hints === 0) {
          n.copyWithin(c - 1, c, -1), c -= 1, o -= 1;
          continue;
        }
        c += e.hints + 7 >> 3, s %= 2, h = yi[l];
      } else if (l === 10 || l === 29) {
        const f = l === 10 ? a : i;
        if (!f)
          return h = yi[l], F("Missing subrsIndex for " + h.id), !1;
        let d = 32768;
        f.count < 1240 ? d = 107 : f.count < 33900 && (d = 1131);
        const u = r[--s] + d;
        if (u < 0 || u >= f.count || isNaN(u))
          return h = yi[l], F("Out of bounds subrIndex for " + h.id), !1;
        if (e.stackSize = s, e.callDepth++, !this.parseCharString(e, f.get(u), a, i))
          return !1;
        e.callDepth--, s = e.stackSize;
        continue;
      } else {
        if (l === 11)
          return e.stackSize = s, !0;
        if (l === 0 && c === n.length)
          n[c - 1] = 14, h = yi[14];
        else if (l === 9) {
          n.copyWithin(c - 1, c, -1), c -= 1, o -= 1;
          continue;
        } else
          h = yi[l];
      }
      if (h) {
        if (h.stem && (e.hints += s >> 1, l === 3 || l === 23 ? e.hasVStems = !0 : e.hasVStems && (l === 1 || l === 18) && (F("CFF stem hints are in wrong order"), n[c - 1] = l === 1 ? 3 : 23)), "min" in h && !e.undefStack && s < h.min)
          return F("Not enough parameters for " + h.id + "; actual: " + s + ", expected: " + h.min), s === 0 ? (n[c - 1] = 14, !0) : !1;
        e.firstStackClearing && h.stackClearing && (e.firstStackClearing = !1, s -= h.min, s >= 2 && h.stem ? s %= 2 : s > 1 && F("Found too many parameters for stack-clearing command"), s > 0 && (e.width = r[s - 1])), "stackDelta" in h ? ("stackFn" in h && h.stackFn(r, s), s += h.stackDelta) : h.stackClearing ? s = 0 : h.resetStack ? (s = 0, e.undefStack = !1) : h.undefStack && (s = 0, e.undefStack = !0, e.firstStackClearing = !1);
      }
    }
    return o < n.length && n.fill(14, o), e.stackSize = s, !0;
  }
  parseCharStrings({
    charStrings: e,
    localSubrIndex: n,
    globalSubrIndex: a,
    fdSelect: i,
    fdArray: s,
    privateDict: r
  }) {
    const o = [], c = [], l = e.count;
    for (let h = 0; h < l; h++) {
      const f = e.get(h), d = {
        callDepth: 0,
        stackSize: 0,
        stack: [],
        undefStack: !0,
        hints: 0,
        firstStackClearing: !0,
        seac: null,
        width: null,
        hasVStems: !1
      };
      let u = !0, x = null, g = r;
      if (i && s.length) {
        const p = i.getFDIndex(h);
        p === -1 && (F("Glyph index is not in fd select."), u = !1), p >= s.length && (F("Invalid fd index for glyph index."), u = !1), u && (g = s[p].privateDict, x = g.subrsIndex);
      } else n && (x = n);
      if (u && (u = this.parseCharString(d, f, x, a)), d.width !== null) {
        const p = g.getByName("nominalWidthX");
        c[h] = p + d.width;
      } else {
        const p = g.getByName("defaultWidthX");
        c[h] = p;
      }
      d.seac !== null && (o[h] = d.seac), u || e.set(h, new Uint8Array([14]));
    }
    return {
      charStrings: e,
      seacs: o,
      widths: c
    };
  }
  emptyPrivateDictionary(e) {
    const n = this.createDict(Ns, [], e.strings);
    e.setByKey(18, [0, 0]), e.privateDict = n;
  }
  parsePrivateDict(e) {
    if (!e.hasName("Private")) {
      this.emptyPrivateDictionary(e);
      return;
    }
    const n = e.getByName("Private");
    if (!Array.isArray(n) || n.length !== 2) {
      e.removeByName("Private");
      return;
    }
    const a = n[0], i = n[1];
    if (a === 0 || i >= this.bytes.length) {
      this.emptyPrivateDictionary(e);
      return;
    }
    const s = i + a, r = this.bytes.subarray(i, s), o = this.parseDict(r), c = this.createDict(Ns, o, e.strings);
    if (e.privateDict = c, c.getByName("ExpansionFactor") === 0 && c.setByName("ExpansionFactor", 0.06), !c.getByName("Subrs"))
      return;
    const l = c.getByName("Subrs"), h = i + l;
    if (l === 0 || h >= this.bytes.length) {
      this.emptyPrivateDictionary(e);
      return;
    }
    const f = this.parseIndex(h);
    c.subrsIndex = f.obj;
  }
  parseCharsets(e, n, a, i) {
    if (e === 0)
      return new ds(!0, E0.ISO_ADOBE, ad);
    if (e === 1)
      return new ds(!0, E0.EXPERT, id);
    if (e === 2)
      return new ds(!0, E0.EXPERT_SUBSET, sd);
    const s = this.bytes, r = e, o = s[e++], c = [i ? 0 : ".notdef"];
    let l, h, f;
    switch (n -= 1, o) {
      case 0:
        for (f = 0; f < n; f++)
          l = s[e++] << 8 | s[e++], c.push(i ? l : a.get(l));
        break;
      case 1:
        for (; c.length <= n; )
          for (l = s[e++] << 8 | s[e++], h = s[e++], f = 0; f <= h; f++)
            c.push(i ? l++ : a.get(l++));
        break;
      case 2:
        for (; c.length <= n; )
          for (l = s[e++] << 8 | s[e++], h = s[e++] << 8 | s[e++], f = 0; f <= h; f++)
            c.push(i ? l++ : a.get(l++));
        break;
      default:
        throw new W("Unknown charset format");
    }
    const d = e, u = s.subarray(r, d);
    return new ds(!1, o, c, u);
  }
  parseEncoding(e, n, a, i) {
    const s = /* @__PURE__ */ Object.create(null), r = this.bytes;
    let o = !1, c, l, h, f = null;
    function d() {
      const u = r[e++];
      for (l = 0; l < u; l++) {
        const x = r[e++], g = (r[e++] << 8) + (r[e++] & 255);
        s[x] = i.indexOf(a.get(g));
      }
    }
    if (e === 0 || e === 1) {
      o = !0, c = e;
      const u = e ? F1 : xa;
      for (l = 0, h = i.length; l < h; l++) {
        const x = u.indexOf(i[l]);
        x !== -1 && (s[x] = l);
      }
    } else {
      const u = e;
      switch (c = r[e++], c & 127) {
        case 0:
          const g = r[e++];
          for (l = 1; l <= g; l++)
            s[r[e++]] = l;
          break;
        case 1:
          const p = r[e++];
          let m = 1;
          for (l = 0; l < p; l++) {
            const b = r[e++], y = r[e++];
            for (let w = b; w <= b + y; w++)
              s[w] = m++;
          }
          break;
        default:
          throw new W(`Unknown encoding format: ${c} in CFF`);
      }
      const x = e;
      c & 128 && (r[u] &= 127, d()), f = r.subarray(u, x);
    }
    return c &= 127, new hd(o, c, s, f);
  }
  parseFDSelect(e, n) {
    const a = this.bytes, i = a[e++], s = [];
    let r;
    switch (i) {
      case 0:
        for (r = 0; r < n; ++r) {
          const c = a[e++];
          s.push(c);
        }
        break;
      case 3:
        const o = a[e++] << 8 | a[e++];
        for (r = 0; r < o; ++r) {
          let c = a[e++] << 8 | a[e++];
          r === 0 && c !== 0 && (F("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), c = 0);
          const l = a[e++], h = a[e] << 8 | a[e + 1];
          for (let f = c; f < h; ++f)
            s.push(l);
        }
        e += 2;
        break;
      default:
        throw new W(`parseFDSelect: Unknown format "${i}".`);
    }
    if (s.length !== n)
      throw new W("parseFDSelect: Invalid font data.");
    return new fd(i, s);
  }
}
class B1 {
  constructor() {
    this.header = null, this.names = [], this.topDict = null, this.strings = new zo(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      F("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const e = this.charStrings.get(0);
    this.charStrings.add(e), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(e) {
    return e < 0 || e >= this.charStrings.count ? !1 : this.charStrings.get(e).length > 0;
  }
}
class M1 {
  constructor(e, n, a, i) {
    this.major = e, this.minor = n, this.hdrSize = a, this.offSize = i;
  }
}
class zo {
  constructor() {
    this.strings = [];
  }
  get(e) {
    return e >= 0 && e <= gr - 1 ? Rr[e] : e - gr <= this.strings.length ? this.strings[e - gr] : Rr[0];
  }
  getSID(e) {
    let n = Rr.indexOf(e);
    return n !== -1 ? n : (n = this.strings.indexOf(e), n !== -1 ? n + gr : -1);
  }
  add(e) {
    this.strings.push(e);
  }
  get count() {
    return this.strings.length;
  }
}
class Ba {
  constructor() {
    this.objects = [], this.length = 0;
  }
  add(e) {
    this.length += e.length, this.objects.push(e);
  }
  set(e, n) {
    this.length += n.length - this.objects[e].length, this.objects[e] = n;
  }
  get(e) {
    return this.objects[e];
  }
  get count() {
    return this.objects.length;
  }
}
class P1 {
  constructor(e, n) {
    this.keyToNameMap = e.keyToNameMap, this.nameToKeyMap = e.nameToKeyMap, this.defaults = e.defaults, this.types = e.types, this.opcodes = e.opcodes, this.order = e.order, this.strings = n, this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(e, n) {
    if (!(e in this.keyToNameMap))
      return !1;
    if (n.length === 0)
      return !0;
    for (const i of n)
      if (isNaN(i))
        return F(`Invalid CFFDict value: "${n}" for key "${e}".`), !0;
    const a = this.types[e];
    return (a === "num" || a === "sid" || a === "offset") && (n = n[0]), this.values[e] = n, !0;
  }
  setByName(e, n) {
    if (!(e in this.nameToKeyMap))
      throw new W(`Invalid dictionary name "${e}"`);
    this.values[this.nameToKeyMap[e]] = n;
  }
  hasName(e) {
    return this.nameToKeyMap[e] in this.values;
  }
  getByName(e) {
    if (!(e in this.nameToKeyMap))
      throw new W(`Invalid dictionary name ${e}"`);
    const n = this.nameToKeyMap[e];
    return n in this.values ? this.values[n] : this.defaults[n];
  }
  removeByName(e) {
    delete this.values[this.nameToKeyMap[e]];
  }
  static createTables(e) {
    const n = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };
    for (const a of e) {
      const i = Array.isArray(a[0]) ? (a[0][0] << 8) + a[0][1] : a[0];
      n.keyToNameMap[i] = a[1], n.nameToKeyMap[a[1]] = i, n.types[i] = a[2], n.defaults[i] = a[3], n.opcodes[i] = Array.isArray(a[0]) ? a[0] : [a[0]], n.order.push(i);
    }
    return n;
  }
}
const cd = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
class Ps extends P1 {
  static get tables() {
    return ae(this, "tables", this.createTables(cd));
  }
  constructor(e) {
    super(Ps.tables, e), this.privateDict = null;
  }
}
const ld = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
class Ns extends P1 {
  static get tables() {
    return ae(this, "tables", this.createTables(ld));
  }
  constructor(e) {
    super(Ns.tables, e), this.subrsIndex = null;
  }
}
const E0 = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};
class ds {
  constructor(e, n, a, i) {
    this.predefined = e, this.format = n, this.charset = a, this.raw = i;
  }
}
class hd {
  constructor(e, n, a, i) {
    this.predefined = e, this.format = n, this.encoding = a, this.raw = i;
  }
}
class fd {
  constructor(e, n) {
    this.format = e, this.fdSelect = n;
  }
  getFDIndex(e) {
    return e < 0 || e >= this.fdSelect.length ? -1 : this.fdSelect[e];
  }
}
class _c {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(e) {
    return e in this.offsets;
  }
  track(e, n) {
    if (e in this.offsets)
      throw new W(`Already tracking location of ${e}`);
    this.offsets[e] = n;
  }
  offset(e) {
    for (const n in this.offsets)
      this.offsets[n] += e;
  }
  setEntryLocation(e, n, a) {
    if (!(e in this.offsets))
      throw new W(`Not tracking location of ${e}`);
    const i = a.data, s = this.offsets[e], r = 5;
    for (let o = 0, c = n.length; o < c; ++o) {
      const l = o * r + s, h = l + 1, f = l + 2, d = l + 3, u = l + 4;
      if (i[l] !== 29 || i[h] !== 0 || i[f] !== 0 || i[d] !== 0 || i[u] !== 0)
        throw new W("writing to an offset that is not empty");
      const x = n[o];
      i[l] = 29, i[h] = x >> 24 & 255, i[f] = x >> 16 & 255, i[d] = x >> 8 & 255, i[u] = x & 255;
    }
  }
}
class Xs {
  constructor(e) {
    this.cff = e;
  }
  compile() {
    const e = this.cff, n = {
      data: [],
      length: 0,
      add(d) {
        try {
          this.data.push(...d);
        } catch {
          this.data = this.data.concat(d);
        }
        this.length = this.data.length;
      }
    }, a = this.compileHeader(e.header);
    n.add(a);
    const i = this.compileNameIndex(e.names);
    if (n.add(i), e.isCIDFont && e.topDict.hasName("FontMatrix")) {
      const d = e.topDict.getByName("FontMatrix");
      e.topDict.removeByName("FontMatrix");
      for (const u of e.fdArray) {
        let x = d.slice(0);
        u.hasName("FontMatrix") && (x = Je.transform(x, u.getByName("FontMatrix"))), u.setByName("FontMatrix", x);
      }
    }
    e.topDict.getByName("XUID")?.length > 16 && e.topDict.removeByName("XUID"), e.topDict.setByName("charset", 0);
    let r = this.compileTopDicts([e.topDict], n.length, e.isCIDFont);
    n.add(r.output);
    const o = r.trackers[0], c = this.compileStringIndex(e.strings.strings);
    n.add(c);
    const l = this.compileIndex(e.globalSubrIndex);
    if (n.add(l), e.encoding && e.topDict.hasName("Encoding"))
      if (e.encoding.predefined)
        o.setEntryLocation("Encoding", [e.encoding.format], n);
      else {
        const d = this.compileEncoding(e.encoding);
        o.setEntryLocation("Encoding", [n.length], n), n.add(d);
      }
    const h = this.compileCharset(e.charset, e.charStrings.count, e.strings, e.isCIDFont);
    o.setEntryLocation("charset", [n.length], n), n.add(h);
    const f = this.compileCharStrings(e.charStrings);
    if (o.setEntryLocation("CharStrings", [n.length], n), n.add(f), e.isCIDFont) {
      o.setEntryLocation("FDSelect", [n.length], n);
      const d = this.compileFDSelect(e.fdSelect);
      n.add(d), r = this.compileTopDicts(e.fdArray, n.length, !0), o.setEntryLocation("FDArray", [n.length], n), n.add(r.output);
      const u = r.trackers;
      this.compilePrivateDicts(e.fdArray, u, n);
    }
    return this.compilePrivateDicts([e.topDict], [o], n), n.add([0]), n.data;
  }
  encodeNumber(e) {
    return Number.isInteger(e) ? this.encodeInteger(e) : this.encodeFloat(e);
  }
  static get EncodeFloatRegExp() {
    return ae(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(e) {
    let n = e.toString();
    const a = Xs.EncodeFloatRegExp.exec(n);
    if (a) {
      const c = parseFloat("1e" + ((a[2] ? +a[2] : 0) + a[1].length));
      n = (Math.round(e * c) / c).toString();
    }
    let i = "", s, r;
    for (s = 0, r = n.length; s < r; ++s) {
      const c = n[s];
      c === "e" ? i += n[++s] === "-" ? "c" : "b" : c === "." ? i += "a" : c === "-" ? i += "e" : i += c;
    }
    i += i.length & 1 ? "f" : "ff";
    const o = [30];
    for (s = 0, r = i.length; s < r; s += 2)
      o.push(parseInt(i.substring(s, s + 2), 16));
    return o;
  }
  encodeInteger(e) {
    let n;
    return e >= -107 && e <= 107 ? n = [e + 139] : e >= 108 && e <= 1131 ? (e -= 108, n = [(e >> 8) + 247, e & 255]) : e >= -1131 && e <= -108 ? (e = -e - 108, n = [(e >> 8) + 251, e & 255]) : e >= -32768 && e <= 32767 ? n = [28, e >> 8 & 255, e & 255] : n = [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255], n;
  }
  compileHeader(e) {
    return [e.major, e.minor, 4, e.offSize];
  }
  compileNameIndex(e) {
    const n = new Ba();
    for (const a of e) {
      const i = Math.min(a.length, 127);
      let s = new Array(i);
      for (let r = 0; r < i; r++) {
        let o = a[r];
        (o < "!" || o > "~" || o === "[" || o === "]" || o === "(" || o === ")" || o === "{" || o === "}" || o === "<" || o === ">" || o === "/" || o === "%") && (o = "_"), s[r] = o;
      }
      s = s.join(""), s === "" && (s = "Bad_Font_Name"), n.add(Vt(s));
    }
    return this.compileIndex(n);
  }
  compileTopDicts(e, n, a) {
    const i = [];
    let s = new Ba();
    for (const r of e) {
      a && (r.removeByName("CIDFontVersion"), r.removeByName("CIDFontRevision"), r.removeByName("CIDFontType"), r.removeByName("CIDCount"), r.removeByName("UIDBase"));
      const o = new _c(), c = this.compileDict(r, o);
      i.push(o), s.add(c), o.offset(n);
    }
    return s = this.compileIndex(s, i), {
      trackers: i,
      output: s
    };
  }
  compilePrivateDicts(e, n, a) {
    for (let i = 0, s = e.length; i < s; ++i) {
      const r = e[i], o = r.privateDict;
      if (!o || !r.hasName("Private"))
        throw new W("There must be a private dictionary.");
      const c = new _c(), l = this.compileDict(o, c);
      let h = a.length;
      if (c.offset(h), l.length || (h = 0), n[i].setEntryLocation("Private", [l.length, h], a), a.add(l), o.subrsIndex && o.hasName("Subrs")) {
        const f = this.compileIndex(o.subrsIndex);
        c.setEntryLocation("Subrs", [l.length], a), a.add(f);
      }
    }
  }
  compileDict(e, n) {
    const a = [];
    for (const i of e.order) {
      if (!(i in e.values))
        continue;
      let s = e.values[i], r = e.types[i];
      if (Array.isArray(r) || (r = [r]), Array.isArray(s) || (s = [s]), s.length !== 0) {
        for (let o = 0, c = r.length; o < c; ++o) {
          const l = r[o], h = s[o];
          switch (l) {
            case "num":
            case "sid":
              a.push(...this.encodeNumber(h));
              break;
            case "offset":
              const f = e.keyToNameMap[i];
              n.isTracking(f) || n.track(f, a.length), a.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              a.push(...this.encodeNumber(h));
              for (let d = 1, u = s.length; d < u; ++d)
                a.push(...this.encodeNumber(s[d]));
              break;
            default:
              throw new W(`Unknown data type of ${l}`);
          }
        }
        a.push(...e.opcodes[i]);
      }
    }
    return a;
  }
  compileStringIndex(e) {
    const n = new Ba();
    for (const a of e)
      n.add(Vt(a));
    return this.compileIndex(n);
  }
  compileCharStrings(e) {
    const n = new Ba();
    for (let a = 0; a < e.count; a++) {
      const i = e.get(a);
      if (i.length === 0) {
        n.add(new Uint8Array([139, 14]));
        continue;
      }
      n.add(i);
    }
    return this.compileIndex(n);
  }
  compileCharset(e, n, a, i) {
    let s;
    const r = n - 1;
    if (i) {
      const o = r - 1;
      s = new Uint8Array([2, 0, 1, o >> 8 & 255, o & 255]);
    } else {
      const o = 1 + r * 2;
      s = new Uint8Array(o), s[0] = 0;
      let c = 0;
      const l = e.charset.length;
      let h = !1;
      for (let f = 1; f < s.length; f += 2) {
        let d = 0;
        if (c < l) {
          const u = e.charset[c++];
          d = a.getSID(u), d === -1 && (d = 0, h || (h = !0, F(`Couldn't find ${u} in CFF strings`)));
        }
        s[f] = d >> 8 & 255, s[f + 1] = d & 255;
      }
    }
    return this.compileTypedArray(s);
  }
  compileEncoding(e) {
    return this.compileTypedArray(e.raw);
  }
  compileFDSelect(e) {
    const n = e.format;
    let a, i;
    switch (n) {
      case 0:
        for (a = new Uint8Array(1 + e.fdSelect.length), a[0] = n, i = 0; i < e.fdSelect.length; i++)
          a[i + 1] = e.fdSelect[i];
        break;
      case 3:
        const s = 0;
        let r = e.fdSelect[0];
        const o = [n, 0, 0, s >> 8 & 255, s & 255, r];
        for (i = 1; i < e.fdSelect.length; i++) {
          const l = e.fdSelect[i];
          l !== r && (o.push(i >> 8 & 255, i & 255, l), r = l);
        }
        const c = (o.length - 3) / 3;
        o[1] = c >> 8 & 255, o[2] = c & 255, o.push(i >> 8 & 255, i & 255), a = new Uint8Array(o);
        break;
    }
    return this.compileTypedArray(a);
  }
  compileTypedArray(e) {
    return Array.from(e);
  }
  compileIndex(e, n = []) {
    const a = e.objects, i = a.length;
    if (i === 0)
      return [0, 0];
    const s = [i >> 8 & 255, i & 255];
    let r = 1, o;
    for (o = 0; o < i; ++o)
      r += a[o].length;
    let c;
    r < 256 ? c = 1 : r < 65536 ? c = 2 : r < 16777216 ? c = 3 : c = 4, s.push(c);
    let l = 1;
    for (o = 0; o < i + 1; o++)
      c === 1 ? s.push(l & 255) : c === 2 ? s.push(l >> 8 & 255, l & 255) : c === 3 ? s.push(l >> 16 & 255, l >> 8 & 255, l & 255) : s.push(l >>> 24 & 255, l >> 16 & 255, l >> 8 & 255, l & 255), a[o] && (l += a[o].length);
    for (o = 0; o < i; o++)
      n[o] && n[o].offset(s.length), s.push(...a[o]);
    return s;
  }
}
const Ds = ut(function(t) {
  t["Times-Roman"] = "Times-Roman", t.Helvetica = "Helvetica", t.Courier = "Courier", t.Symbol = "Symbol", t["Times-Bold"] = "Times-Bold", t["Helvetica-Bold"] = "Helvetica-Bold", t["Courier-Bold"] = "Courier-Bold", t.ZapfDingbats = "ZapfDingbats", t["Times-Italic"] = "Times-Italic", t["Helvetica-Oblique"] = "Helvetica-Oblique", t["Courier-Oblique"] = "Courier-Oblique", t["Times-BoldItalic"] = "Times-BoldItalic", t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", t["Courier-BoldOblique"] = "Courier-BoldOblique", t.ArialNarrow = "Helvetica", t["ArialNarrow-Bold"] = "Helvetica-Bold", t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", t["ArialNarrow-Italic"] = "Helvetica-Oblique", t.ArialBlack = "Helvetica", t["ArialBlack-Bold"] = "Helvetica-Bold", t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", t["ArialBlack-Italic"] = "Helvetica-Oblique", t["Arial-Black"] = "Helvetica", t["Arial-Black-Bold"] = "Helvetica-Bold", t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", t["Arial-Black-Italic"] = "Helvetica-Oblique", t.Arial = "Helvetica", t["Arial-Bold"] = "Helvetica-Bold", t["Arial-BoldItalic"] = "Helvetica-BoldOblique", t["Arial-Italic"] = "Helvetica-Oblique", t.ArialMT = "Helvetica", t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", t["Arial-BoldMT"] = "Helvetica-Bold", t["Arial-ItalicMT"] = "Helvetica-Oblique", t["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", t["Arial-BoldMT-Bold"] = "Helvetica-Bold", t["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", t.ArialUnicodeMS = "Helvetica", t["ArialUnicodeMS-Bold"] = "Helvetica-Bold", t["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", t["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", t["Courier-BoldItalic"] = "Courier-BoldOblique", t["Courier-Italic"] = "Courier-Oblique", t.CourierNew = "Courier", t["CourierNew-Bold"] = "Courier-Bold", t["CourierNew-BoldItalic"] = "Courier-BoldOblique", t["CourierNew-Italic"] = "Courier-Oblique", t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", t["CourierNewPS-BoldMT"] = "Courier-Bold", t["CourierNewPS-ItalicMT"] = "Courier-Oblique", t.CourierNewPSMT = "Courier", t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", t["Helvetica-Italic"] = "Helvetica-Oblique", t["HelveticaLTStd-Bold"] = "Helvetica-Bold", t["Symbol-Bold"] = "Symbol", t["Symbol-BoldItalic"] = "Symbol", t["Symbol-Italic"] = "Symbol", t.TimesNewRoman = "Times-Roman", t["TimesNewRoman-Bold"] = "Times-Bold", t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", t["TimesNewRoman-Italic"] = "Times-Italic", t.TimesNewRomanPS = "Times-Roman", t["TimesNewRomanPS-Bold"] = "Times-Bold", t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", t["TimesNewRomanPS-BoldMT"] = "Times-Bold", t["TimesNewRomanPS-Italic"] = "Times-Italic", t["TimesNewRomanPS-ItalicMT"] = "Times-Italic", t.TimesNewRomanPSMT = "Times-Roman", t["TimesNewRomanPSMT-Bold"] = "Times-Bold", t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), ud = ut(function(t) {
  t.Courier = "FoxitFixed.pfb", t["Courier-Bold"] = "FoxitFixedBold.pfb", t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", t["Courier-Oblique"] = "FoxitFixedItalic.pfb", t.Helvetica = "LiberationSans-Regular.ttf", t["Helvetica-Bold"] = "LiberationSans-Bold.ttf", t["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", t["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", t["Times-Roman"] = "FoxitSerif.pfb", t["Times-Bold"] = "FoxitSerifBold.pfb", t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", t["Times-Italic"] = "FoxitSerifItalic.pfb", t.Symbol = "FoxitSymbol.pfb", t.ZapfDingbats = "FoxitDingbats.pfb", t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), xo = ut(function(t) {
  t.Calibri = "Helvetica", t["Calibri-Bold"] = "Helvetica-Bold", t["Calibri-BoldItalic"] = "Helvetica-BoldOblique", t["Calibri-Italic"] = "Helvetica-Oblique", t.CenturyGothic = "Helvetica", t["CenturyGothic-Bold"] = "Helvetica-Bold", t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", t["CenturyGothic-Italic"] = "Helvetica-Oblique", t.ComicSansMS = "Comic Sans MS", t["ComicSansMS-Bold"] = "Comic Sans MS-Bold", t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", t["ComicSansMS-Italic"] = "Comic Sans MS-Italic", t.GillSansMT = "Helvetica", t["GillSansMT-Bold"] = "Helvetica-Bold", t["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique", t["GillSansMT-Italic"] = "Helvetica-Oblique", t.Impact = "Helvetica", t["ItcSymbol-Bold"] = "Helvetica-Bold", t["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", t["ItcSymbol-Book"] = "Helvetica", t["ItcSymbol-BookItalic"] = "Helvetica-Oblique", t["ItcSymbol-Medium"] = "Helvetica", t["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", t.LucidaConsole = "Courier", t["LucidaConsole-Bold"] = "Courier-Bold", t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", t["LucidaConsole-Italic"] = "Courier-Oblique", t["LucidaSans-Demi"] = "Helvetica-Bold", t["MS-Gothic"] = "MS Gothic", t["MS-Gothic-Bold"] = "MS Gothic-Bold", t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", t["MS-Gothic-Italic"] = "MS Gothic-Italic", t["MS-Mincho"] = "MS Mincho", t["MS-Mincho-Bold"] = "MS Mincho-Bold", t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", t["MS-Mincho-Italic"] = "MS Mincho-Italic", t["MS-PGothic"] = "MS PGothic", t["MS-PGothic-Bold"] = "MS PGothic-Bold", t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", t["MS-PGothic-Italic"] = "MS PGothic-Italic", t["MS-PMincho"] = "MS PMincho", t["MS-PMincho-Bold"] = "MS PMincho-Bold", t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", t["MS-PMincho-Italic"] = "MS PMincho-Italic", t.NuptialScript = "Times-Italic", t.SegoeUISymbol = "Helvetica";
}), _o = ut(function(t) {
  t["Adobe Jenson"] = !0, t["Adobe Text"] = !0, t.Albertus = !0, t.Aldus = !0, t.Alexandria = !0, t.Algerian = !0, t["American Typewriter"] = !0, t.Antiqua = !0, t.Apex = !0, t.Arno = !0, t.Aster = !0, t.Aurora = !0, t.Baskerville = !0, t.Bell = !0, t.Bembo = !0, t["Bembo Schoolbook"] = !0, t.Benguiat = !0, t["Berkeley Old Style"] = !0, t["Bernhard Modern"] = !0, t["Berthold City"] = !0, t.Bodoni = !0, t["Bauer Bodoni"] = !0, t["Book Antiqua"] = !0, t.Bookman = !0, t["Bordeaux Roman"] = !0, t["Californian FB"] = !0, t.Calisto = !0, t.Calvert = !0, t.Capitals = !0, t.Cambria = !0, t.Cartier = !0, t.Caslon = !0, t.Catull = !0, t.Centaur = !0, t["Century Old Style"] = !0, t["Century Schoolbook"] = !0, t.Chaparral = !0, t["Charis SIL"] = !0, t.Cheltenham = !0, t["Cholla Slab"] = !0, t.Clarendon = !0, t.Clearface = !0, t.Cochin = !0, t.Colonna = !0, t["Computer Modern"] = !0, t["Concrete Roman"] = !0, t.Constantia = !0, t["Cooper Black"] = !0, t.Corona = !0, t.Ecotype = !0, t.Egyptienne = !0, t.Elephant = !0, t.Excelsior = !0, t.Fairfield = !0, t["FF Scala"] = !0, t.Folkard = !0, t.Footlight = !0, t.FreeSerif = !0, t["Friz Quadrata"] = !0, t.Garamond = !0, t.Gentium = !0, t.Georgia = !0, t.Gloucester = !0, t["Goudy Old Style"] = !0, t["Goudy Schoolbook"] = !0, t["Goudy Pro Font"] = !0, t.Granjon = !0, t["Guardian Egyptian"] = !0, t.Heather = !0, t.Hercules = !0, t["High Tower Text"] = !0, t.Hiroshige = !0, t["Hoefler Text"] = !0, t["Humana Serif"] = !0, t.Imprint = !0, t["Ionic No. 5"] = !0, t.Janson = !0, t.Joanna = !0, t.Korinna = !0, t.Lexicon = !0, t.LiberationSerif = !0, t["Liberation Serif"] = !0, t["Linux Libertine"] = !0, t.Literaturnaya = !0, t.Lucida = !0, t["Lucida Bright"] = !0, t.Melior = !0, t.Memphis = !0, t.Miller = !0, t.Minion = !0, t.Modern = !0, t["Mona Lisa"] = !0, t["Mrs Eaves"] = !0, t["MS Serif"] = !0, t["Museo Slab"] = !0, t["New York"] = !0, t["Nimbus Roman"] = !0, t["NPS Rawlinson Roadway"] = !0, t.NuptialScript = !0, t.Palatino = !0, t.Perpetua = !0, t.Plantin = !0, t["Plantin Schoolbook"] = !0, t.Playbill = !0, t["Poor Richard"] = !0, t["Rawlinson Roadway"] = !0, t.Renault = !0, t.Requiem = !0, t.Rockwell = !0, t.Roman = !0, t["Rotis Serif"] = !0, t.Sabon = !0, t.Scala = !0, t.Seagull = !0, t.Sistina = !0, t.Souvenir = !0, t.STIX = !0, t["Stone Informal"] = !0, t["Stone Serif"] = !0, t.Sylfaen = !0, t.Times = !0, t.Trajan = !0, t.Trinit = !0, t["Trump Mediaeval"] = !0, t.Utopia = !0, t["Vale Type"] = !0, t["Bitstream Vera"] = !0, t["Vera Serif"] = !0, t.Versailles = !0, t.Wanted = !0, t.Weiss = !0, t["Wide Latin"] = !0, t.Windsor = !0, t.XITS = !0;
}), go = ut(function(t) {
  t.Dingbats = !0, t.Symbol = !0, t.ZapfDingbats = !0, t.Wingdings = !0, t["Wingdings-Bold"] = !0, t["Wingdings-Regular"] = !0;
}), Wc = ut(function(t) {
  t[2] = 10, t[3] = 32, t[4] = 33, t[5] = 34, t[6] = 35, t[7] = 36, t[8] = 37, t[9] = 38, t[10] = 39, t[11] = 40, t[12] = 41, t[13] = 42, t[14] = 43, t[15] = 44, t[16] = 45, t[17] = 46, t[18] = 47, t[19] = 48, t[20] = 49, t[21] = 50, t[22] = 51, t[23] = 52, t[24] = 53, t[25] = 54, t[26] = 55, t[27] = 56, t[28] = 57, t[29] = 58, t[30] = 894, t[31] = 60, t[32] = 61, t[33] = 62, t[34] = 63, t[35] = 64, t[36] = 65, t[37] = 66, t[38] = 67, t[39] = 68, t[40] = 69, t[41] = 70, t[42] = 71, t[43] = 72, t[44] = 73, t[45] = 74, t[46] = 75, t[47] = 76, t[48] = 77, t[49] = 78, t[50] = 79, t[51] = 80, t[52] = 81, t[53] = 82, t[54] = 83, t[55] = 84, t[56] = 85, t[57] = 86, t[58] = 87, t[59] = 88, t[60] = 89, t[61] = 90, t[62] = 91, t[63] = 92, t[64] = 93, t[65] = 94, t[66] = 95, t[67] = 96, t[68] = 97, t[69] = 98, t[70] = 99, t[71] = 100, t[72] = 101, t[73] = 102, t[74] = 103, t[75] = 104, t[76] = 105, t[77] = 106, t[78] = 107, t[79] = 108, t[80] = 109, t[81] = 110, t[82] = 111, t[83] = 112, t[84] = 113, t[85] = 114, t[86] = 115, t[87] = 116, t[88] = 117, t[89] = 118, t[90] = 119, t[91] = 120, t[92] = 121, t[93] = 122, t[94] = 123, t[95] = 124, t[96] = 125, t[97] = 126, t[98] = 196, t[99] = 197, t[100] = 199, t[101] = 201, t[102] = 209, t[103] = 214, t[104] = 220, t[105] = 225, t[106] = 224, t[107] = 226, t[108] = 228, t[109] = 227, t[110] = 229, t[111] = 231, t[112] = 233, t[113] = 232, t[114] = 234, t[115] = 235, t[116] = 237, t[117] = 236, t[118] = 238, t[119] = 239, t[120] = 241, t[121] = 243, t[122] = 242, t[123] = 244, t[124] = 246, t[125] = 245, t[126] = 250, t[127] = 249, t[128] = 251, t[129] = 252, t[130] = 8224, t[131] = 176, t[132] = 162, t[133] = 163, t[134] = 167, t[135] = 8226, t[136] = 182, t[137] = 223, t[138] = 174, t[139] = 169, t[140] = 8482, t[141] = 180, t[142] = 168, t[143] = 8800, t[144] = 198, t[145] = 216, t[146] = 8734, t[147] = 177, t[148] = 8804, t[149] = 8805, t[150] = 165, t[151] = 181, t[152] = 8706, t[153] = 8721, t[154] = 8719, t[156] = 8747, t[157] = 170, t[158] = 186, t[159] = 8486, t[160] = 230, t[161] = 248, t[162] = 191, t[163] = 161, t[164] = 172, t[165] = 8730, t[166] = 402, t[167] = 8776, t[168] = 8710, t[169] = 171, t[170] = 187, t[171] = 8230, t[179] = 8220, t[180] = 8221, t[181] = 8216, t[182] = 8217, t[200] = 193, t[203] = 205, t[207] = 211, t[210] = 218, t[223] = 711, t[224] = 321, t[225] = 322, t[226] = 352, t[227] = 353, t[228] = 381, t[229] = 382, t[233] = 221, t[234] = 253, t[252] = 263, t[253] = 268, t[254] = 269, t[258] = 258, t[260] = 260, t[261] = 261, t[265] = 280, t[266] = 281, t[267] = 282, t[268] = 283, t[269] = 313, t[275] = 323, t[276] = 324, t[278] = 328, t[283] = 344, t[284] = 345, t[285] = 346, t[286] = 347, t[292] = 367, t[295] = 377, t[296] = 378, t[298] = 380, t[305] = 963, t[306] = 964, t[307] = 966, t[308] = 8215, t[309] = 8252, t[310] = 8319, t[311] = 8359, t[312] = 8592, t[313] = 8593, t[337] = 9552, t[493] = 1039, t[494] = 1040, t[570] = 1040, t[571] = 1041, t[572] = 1042, t[573] = 1043, t[574] = 1044, t[575] = 1045, t[576] = 1046, t[577] = 1047, t[578] = 1048, t[579] = 1049, t[580] = 1050, t[581] = 1051, t[582] = 1052, t[583] = 1053, t[584] = 1054, t[585] = 1055, t[586] = 1056, t[587] = 1057, t[588] = 1058, t[589] = 1059, t[590] = 1060, t[591] = 1061, t[592] = 1062, t[593] = 1063, t[594] = 1064, t[595] = 1065, t[596] = 1066, t[597] = 1067, t[598] = 1068, t[599] = 1069, t[600] = 1070, t[672] = 1488, t[673] = 1489, t[674] = 1490, t[675] = 1491, t[676] = 1492, t[677] = 1493, t[678] = 1494, t[679] = 1495, t[680] = 1496, t[681] = 1497, t[682] = 1498, t[683] = 1499, t[684] = 1500, t[685] = 1501, t[686] = 1502, t[687] = 1503, t[688] = 1504, t[689] = 1505, t[690] = 1506, t[691] = 1507, t[692] = 1508, t[693] = 1509, t[694] = 1510, t[695] = 1511, t[696] = 1512, t[697] = 1513, t[698] = 1514, t[705] = 1524, t[706] = 8362, t[710] = 64288, t[711] = 64298, t[759] = 1617, t[761] = 1776, t[763] = 1778, t[775] = 1652, t[777] = 1764, t[778] = 1780, t[779] = 1781, t[780] = 1782, t[782] = 771, t[783] = 64726, t[786] = 8363, t[788] = 8532, t[790] = 768, t[791] = 769, t[792] = 768, t[795] = 803, t[797] = 64336, t[798] = 64337, t[799] = 64342, t[800] = 64343, t[801] = 64344, t[802] = 64345, t[803] = 64362, t[804] = 64363, t[805] = 64364, t[2424] = 7821, t[2425] = 7822, t[2426] = 7823, t[2427] = 7824, t[2428] = 7825, t[2429] = 7826, t[2430] = 7827, t[2433] = 7682, t[2678] = 8045, t[2679] = 8046, t[2830] = 1552, t[2838] = 686, t[2840] = 751, t[2842] = 753, t[2843] = 754, t[2844] = 755, t[2846] = 757, t[2856] = 767, t[2857] = 848, t[2858] = 849, t[2862] = 853, t[2863] = 854, t[2864] = 855, t[2865] = 861, t[2866] = 862, t[2906] = 7460, t[2908] = 7462, t[2909] = 7463, t[2910] = 7464, t[2912] = 7466, t[2913] = 7467, t[2914] = 7468, t[2916] = 7470, t[2917] = 7471, t[2918] = 7472, t[2920] = 7474, t[2921] = 7475, t[2922] = 7476, t[2924] = 7478, t[2925] = 7479, t[2926] = 7480, t[2928] = 7482, t[2929] = 7483, t[2930] = 7484, t[2932] = 7486, t[2933] = 7487, t[2934] = 7488, t[2936] = 7490, t[2937] = 7491, t[2938] = 7492, t[2940] = 7494, t[2941] = 7495, t[2942] = 7496, t[2944] = 7498, t[2946] = 7500, t[2948] = 7502, t[2950] = 7504, t[2951] = 7505, t[2952] = 7506, t[2954] = 7508, t[2955] = 7509, t[2956] = 7510, t[2958] = 7512, t[2959] = 7513, t[2960] = 7514, t[2962] = 7516, t[2963] = 7517, t[2964] = 7518, t[2966] = 7520, t[2967] = 7521, t[2968] = 7522, t[2970] = 7524, t[2971] = 7525, t[2972] = 7526, t[2974] = 7528, t[2975] = 7529, t[2976] = 7530, t[2978] = 1537, t[2979] = 1538, t[2980] = 1539, t[2982] = 1549, t[2983] = 1551, t[2984] = 1552, t[2986] = 1554, t[2987] = 1555, t[2988] = 1556, t[2990] = 1623, t[2991] = 1624, t[2995] = 1775, t[2999] = 1791, t[3002] = 64290, t[3003] = 64291, t[3004] = 64292, t[3006] = 64294, t[3007] = 64295, t[3008] = 64296, t[3011] = 1900, t[3014] = 8223, t[3015] = 8244, t[3017] = 7532, t[3018] = 7533, t[3019] = 7534, t[3075] = 7590, t[3076] = 7591, t[3079] = 7594, t[3080] = 7595, t[3083] = 7598, t[3084] = 7599, t[3087] = 7602, t[3088] = 7603, t[3091] = 7606, t[3092] = 7607, t[3095] = 7610, t[3096] = 7611, t[3099] = 7614, t[3100] = 7615, t[3103] = 7618, t[3104] = 7619, t[3107] = 8337, t[3108] = 8338, t[3116] = 1884, t[3119] = 1885, t[3120] = 1885, t[3123] = 1886, t[3124] = 1886, t[3127] = 1887, t[3128] = 1887, t[3131] = 1888, t[3132] = 1888, t[3135] = 1889, t[3136] = 1889, t[3139] = 1890, t[3140] = 1890, t[3143] = 1891, t[3144] = 1891, t[3147] = 1892, t[3148] = 1892, t[3153] = 580, t[3154] = 581, t[3157] = 584, t[3158] = 585, t[3161] = 588, t[3162] = 589, t[3165] = 891, t[3166] = 892, t[3169] = 1274, t[3170] = 1275, t[3173] = 1278, t[3174] = 1279, t[3181] = 7622, t[3182] = 7623, t[3282] = 11799, t[3316] = 578, t[3379] = 42785, t[3393] = 1159, t[3416] = 8377;
}), dd = ut(function(t) {
  t[227] = 322, t[264] = 261, t[291] = 346;
}), xd = ut(function(t) {
  t[1] = 32, t[4] = 65, t[5] = 192, t[6] = 193, t[9] = 196, t[17] = 66, t[18] = 67, t[21] = 268, t[24] = 68, t[28] = 69, t[29] = 200, t[30] = 201, t[32] = 282, t[38] = 70, t[39] = 71, t[44] = 72, t[47] = 73, t[48] = 204, t[49] = 205, t[58] = 74, t[60] = 75, t[62] = 76, t[68] = 77, t[69] = 78, t[75] = 79, t[76] = 210, t[80] = 214, t[87] = 80, t[89] = 81, t[90] = 82, t[92] = 344, t[94] = 83, t[97] = 352, t[100] = 84, t[104] = 85, t[109] = 220, t[115] = 86, t[116] = 87, t[121] = 88, t[122] = 89, t[124] = 221, t[127] = 90, t[129] = 381, t[258] = 97, t[259] = 224, t[260] = 225, t[263] = 228, t[268] = 261, t[271] = 98, t[272] = 99, t[273] = 263, t[275] = 269, t[282] = 100, t[286] = 101, t[287] = 232, t[288] = 233, t[290] = 283, t[295] = 281, t[296] = 102, t[336] = 103, t[346] = 104, t[349] = 105, t[350] = 236, t[351] = 237, t[361] = 106, t[364] = 107, t[367] = 108, t[371] = 322, t[373] = 109, t[374] = 110, t[381] = 111, t[382] = 242, t[383] = 243, t[386] = 246, t[393] = 112, t[395] = 113, t[396] = 114, t[398] = 345, t[400] = 115, t[401] = 347, t[403] = 353, t[410] = 116, t[437] = 117, t[442] = 252, t[448] = 118, t[449] = 119, t[454] = 120, t[455] = 121, t[457] = 253, t[460] = 122, t[462] = 382, t[463] = 380, t[853] = 44, t[855] = 58, t[856] = 46, t[876] = 47, t[878] = 45, t[882] = 45, t[894] = 40, t[895] = 41, t[896] = 91, t[897] = 93, t[923] = 64, t[940] = 163, t[1004] = 48, t[1005] = 49, t[1006] = 50, t[1007] = 51, t[1008] = 52, t[1009] = 53, t[1010] = 54, t[1011] = 55, t[1012] = 56, t[1013] = 57, t[1081] = 37, t[1085] = 43, t[1086] = 45;
});
function Vc(t) {
  const e = Vs(t);
  return Ds()[e];
}
function Xc(t) {
  const e = Vs(t);
  return !!(Ds()[e] || xo()[e] || _o()[e] || go()[e]);
}
class xs {
  constructor(e = []) {
    this._map = e;
  }
  get length() {
    return this._map.length;
  }
  forEach(e) {
    for (const n in this._map)
      e(n, this._map[n].codePointAt(0));
  }
  has(e) {
    return this._map[e] !== void 0;
  }
  get(e) {
    return this._map[e];
  }
  charCodeOf(e) {
    const n = this._map;
    if (n.length <= 65536)
      return n.indexOf(e);
    for (const a in n)
      if (n[a] === e)
        return a | 0;
    return -1;
  }
  amend(e) {
    for (const n in e)
      this._map[n] = e[n];
  }
}
class On {
  constructor(e, n) {
    this.firstChar = e, this.lastChar = n;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(e) {
    for (let n = this.firstChar, a = this.lastChar; n <= a; n++)
      e(n, n);
  }
  has(e) {
    return this.firstChar <= e && e <= this.lastChar;
  }
  get(e) {
    if (this.firstChar <= e && e <= this.lastChar)
      return String.fromCharCode(e);
  }
  charCodeOf(e) {
    return Number.isInteger(e) && e >= this.firstChar && e <= this.lastChar ? e : -1;
  }
  amend(e) {
    _e("Should not call amend()");
  }
}
class F0 {
  constructor(e, n) {
    this.properties = n;
    const a = new Go(e, n, Mi);
    this.cff = a.parse(), this.cff.duplicateFirstGlyph();
    const i = new Xs(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = i.compile();
    } catch {
      F("Failed to compile font " + n.loadedName), this.data = e;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const e = this.cff, n = this.properties, {
      cidToGidMap: a,
      cMap: i
    } = n, s = e.charset.charset;
    let r, o;
    if (n.composite) {
      let l;
      if (a?.length > 0) {
        l = /* @__PURE__ */ Object.create(null);
        for (let f = 0, d = a.length; f < d; f++) {
          const u = a[f];
          u !== void 0 && (l[u] = f);
        }
      }
      r = /* @__PURE__ */ Object.create(null);
      let h;
      if (e.isCIDFont)
        for (o = 0; o < s.length; o++) {
          const f = s[o];
          h = i.charCodeOf(f), l?.[h] !== void 0 && (h = l[h]), r[h] = o;
        }
      else
        for (o = 0; o < e.charStrings.count; o++)
          h = i.charCodeOf(o), r[h] = o;
      return r;
    }
    let c = e.encoding ? e.encoding.encoding : null;
    return n.isInternalFont && (c = n.defaultEncoding), r = O1(n, c, s), r;
  }
  hasGlyphId(e) {
    return this.cff.hasGlyphId(e);
  }
  _createBuiltInEncoding() {
    const {
      charset: e,
      encoding: n
    } = this.cff;
    if (!e || !n)
      return;
    const a = e.charset, i = n.encoding, s = [];
    for (const r in i) {
      const o = i[r];
      if (o >= 0) {
        const c = a[o];
        c && (s[r] = c);
      }
    }
    s.length > 0 && (this.properties.builtInEncoding = s);
  }
}
function za(t, e) {
  return ha(t, e) / 16384;
}
function po(t) {
  const e = t.length;
  let n = 32768;
  return e < 1240 ? n = 107 : e < 33900 && (n = 1131), n;
}
function gd(t, e, n) {
  const a = Ge(t, e + 2) === 1 ? nt(t, e + 8) : nt(t, e + 16), i = Ge(t, e + a);
  let s, r, o;
  if (i === 4) {
    Ge(t, e + a + 2);
    const c = Ge(t, e + a + 6) >> 1;
    for (r = e + a + 14, s = [], o = 0; o < c; o++, r += 2)
      s[o] = {
        end: Ge(t, r)
      };
    for (r += 2, o = 0; o < c; o++, r += 2)
      s[o].start = Ge(t, r);
    for (o = 0; o < c; o++, r += 2)
      s[o].idDelta = Ge(t, r);
    for (o = 0; o < c; o++, r += 2) {
      let l = Ge(t, r);
      if (l !== 0) {
        s[o].ids = [];
        for (let h = 0, f = s[o].end - s[o].start + 1; h < f; h++)
          s[o].ids[h] = Ge(t, r + l), l += 2;
      }
    }
    return s;
  } else if (i === 12) {
    const c = nt(t, e + a + 12);
    for (r = e + a + 16, s = [], o = 0; o < c; o++)
      e = nt(t, r), s.push({
        start: e,
        end: nt(t, r + 4),
        idDelta: nt(t, r + 8) - e
      }), r += 12;
    return s;
  }
  throw new W(`unsupported cmap: ${i}`);
}
function pd(t, e, n, a) {
  const i = {}, r = new Go(new pt(t, e, n - e), i, a).parse();
  return {
    glyphs: r.charStrings.objects,
    subrs: r.topDict.privateDict?.subrsIndex?.objects,
    gsubrs: r.globalSubrIndex?.objects,
    isCFFCIDFont: r.isCIDFont,
    fdSelect: r.fdSelect,
    fdArray: r.fdArray
  };
}
function md(t, e, n) {
  let a, i;
  n ? (a = 4, i = nt) : (a = 2, i = (o, c) => 2 * Ge(o, c));
  const s = [];
  let r = i(e, 0);
  for (let o = a; o < e.length; o += a) {
    const c = i(e, o);
    s.push(t.subarray(r, c)), r = c;
  }
  return s;
}
function $r(t, e) {
  const n = e.codePointAt(0);
  let a = 0, i = 0, s = t.length - 1;
  for (; i < s; ) {
    const r = i + s + 1 >> 1;
    n < t[r].start ? s = r - 1 : i = r;
  }
  return t[i].start <= n && n <= t[i].end && (a = t[i].idDelta + (t[i].ids ? t[i].ids[n - t[i].start] : n) & 65535), {
    charCode: n,
    glyphId: a
  };
}
function N1(t, e, n) {
  function a(d, u) {
    l && e.add("L", l), l = [d, u], e.add("M", [d, u]);
  }
  function i(d, u) {
    e.add("L", [d, u]);
  }
  function s(d, u, x, g) {
    e.add("Q", [d, u, x, g]);
  }
  let r = 0;
  const o = ha(t, r);
  let c, l = null, h = 0, f = 0;
  if (r += 10, o < 0)
    do {
      c = Ge(t, r);
      const d = Ge(t, r + 2);
      r += 4;
      let u, x;
      c & 1 ? (c & 2 ? (u = ha(t, r), x = ha(t, r + 2)) : (u = Ge(t, r), x = Ge(t, r + 2)), r += 4) : c & 2 ? (u = Kn(t, r++), x = Kn(t, r++)) : (u = t[r++], x = t[r++]), c & 2 ? (h = u, f = x) : (h = 0, f = 0);
      let g = 1, p = 1, m = 0, b = 0;
      c & 8 ? (g = p = za(t, r), r += 2) : c & 64 ? (g = za(t, r), p = za(t, r + 2), r += 4) : c & 128 && (g = za(t, r), m = za(t, r + 2), b = za(t, r + 4), p = za(t, r + 6), r += 8);
      const y = n.glyphs[d];
      y && (e.save(), e.transform([g, m, b, p, h, f]), N1(y, e, n), e.restore());
    } while (c & 32);
  else {
    const d = [];
    let u, x;
    for (u = 0; u < o; u++)
      d.push(Ge(t, r)), r += 2;
    const g = Ge(t, r);
    r += 2 + g;
    const p = d.at(-1) + 1, m = [];
    for (; m.length < p; ) {
      c = t[r++];
      let y = 1;
      for (c & 8 && (y += t[r++]); y-- > 0; )
        m.push({
          flags: c
        });
    }
    for (u = 0; u < p; u++) {
      switch (m[u].flags & 18) {
        case 0:
          h += ha(t, r), r += 2;
          break;
        case 2:
          h -= t[r++];
          break;
        case 18:
          h += t[r++];
          break;
      }
      m[u].x = h;
    }
    for (u = 0; u < p; u++) {
      switch (m[u].flags & 36) {
        case 0:
          f += ha(t, r), r += 2;
          break;
        case 4:
          f -= t[r++];
          break;
        case 36:
          f += t[r++];
          break;
      }
      m[u].y = f;
    }
    let b = 0;
    for (r = 0; r < o; r++) {
      const y = d[r], w = m.slice(b, y + 1);
      if (w[0].flags & 1)
        w.push(w[0]);
      else if (w.at(-1).flags & 1)
        w.unshift(w.at(-1));
      else {
        const S = {
          flags: 1,
          x: (w[0].x + w.at(-1).x) / 2,
          y: (w[0].y + w.at(-1).y) / 2
        };
        w.unshift(S), w.push(S);
      }
      for (a(w[0].x, w[0].y), u = 1, x = w.length; u < x; u++)
        w[u].flags & 1 ? i(w[u].x, w[u].y) : w[u + 1].flags & 1 ? (s(w[u].x, w[u].y, w[u + 1].x, w[u + 1].y), u++) : s(w[u].x, w[u].y, (w[u].x + w[u + 1].x) / 2, (w[u].y + w[u + 1].y) / 2);
      b = y + 1;
    }
  }
}
function mo(t, e, n, a) {
  function i(u, x) {
    f && e.add("L", f), f = [u, x], e.add("M", [u, x]);
  }
  function s(u, x) {
    e.add("L", [u, x]);
  }
  function r(u, x, g, p, m, b) {
    e.add("C", [u, x, g, p, m, b]);
  }
  const o = [];
  let c = 0, l = 0, h = 0, f = null;
  function d(u) {
    let x = 0;
    for (; x < u.length; ) {
      let g = !1, p = u[x++], m, b, y, w, S, v, k, A, C;
      switch (p) {
        case 1:
          h += o.length >> 1, g = !0;
          break;
        case 3:
          h += o.length >> 1, g = !0;
          break;
        case 4:
          l += o.pop(), i(c, l), g = !0;
          break;
        case 5:
          for (; o.length > 0; )
            c += o.shift(), l += o.shift(), s(c, l);
          break;
        case 6:
          for (; o.length > 0 && (c += o.shift(), s(c, l), o.length !== 0); )
            l += o.shift(), s(c, l);
          break;
        case 7:
          for (; o.length > 0 && (l += o.shift(), s(c, l), o.length !== 0); )
            c += o.shift(), s(c, l);
          break;
        case 8:
          for (; o.length > 0; )
            m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + o.shift(), r(m, y, b, w, c, l);
          break;
        case 10:
          if (A = o.pop(), C = null, n.isCFFCIDFont) {
            const T = n.fdSelect.getFDIndex(a);
            if (T >= 0 && T < n.fdArray.length) {
              const M = n.fdArray[T];
              let O;
              M.privateDict?.subrsIndex && (O = M.privateDict.subrsIndex.objects), O && (A += po(O), C = O[A]);
            } else
              F("Invalid fd index for glyph index.");
          } else
            C = n.subrs[A + n.subrsBias];
          C && d(C);
          break;
        case 11:
          return;
        case 12:
          switch (p = u[x++], p) {
            case 34:
              m = c + o.shift(), b = m + o.shift(), S = l + o.shift(), c = b + o.shift(), r(m, l, b, S, c, S), m = c + o.shift(), b = m + o.shift(), c = b + o.shift(), r(m, S, b, l, c, l);
              break;
            case 35:
              m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + o.shift(), r(m, y, b, w, c, l), m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + o.shift(), r(m, y, b, w, c, l), o.pop();
              break;
            case 36:
              m = c + o.shift(), S = l + o.shift(), b = m + o.shift(), v = S + o.shift(), c = b + o.shift(), r(m, S, b, v, c, v), m = c + o.shift(), b = m + o.shift(), k = v + o.shift(), c = b + o.shift(), r(m, v, b, k, c, l);
              break;
            case 37:
              const T = c, M = l;
              m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + o.shift(), r(m, y, b, w, c, l), m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b, l = w, Math.abs(c - T) > Math.abs(l - M) ? c += o.shift() : l += o.shift(), r(m, y, b, w, c, l);
              break;
            default:
              throw new W(`unknown operator: 12 ${p}`);
          }
          break;
        case 14:
          if (o.length >= 4) {
            const T = o.pop(), M = o.pop();
            l = o.pop(), c = o.pop(), e.save(), e.translate(c, l);
            let O = $r(n.cmap, String.fromCharCode(n.glyphNameMap[xa[T]]));
            mo(n.glyphs[O.glyphId], e, n, O.glyphId), e.restore(), O = $r(n.cmap, String.fromCharCode(n.glyphNameMap[xa[M]])), mo(n.glyphs[O.glyphId], e, n, O.glyphId);
          }
          return;
        case 18:
          h += o.length >> 1, g = !0;
          break;
        case 19:
          h += o.length >> 1, x += h + 7 >> 3, g = !0;
          break;
        case 20:
          h += o.length >> 1, x += h + 7 >> 3, g = !0;
          break;
        case 21:
          l += o.pop(), c += o.pop(), i(c, l), g = !0;
          break;
        case 22:
          c += o.pop(), i(c, l), g = !0;
          break;
        case 23:
          h += o.length >> 1, g = !0;
          break;
        case 24:
          for (; o.length > 2; )
            m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + o.shift(), r(m, y, b, w, c, l);
          c += o.shift(), l += o.shift(), s(c, l);
          break;
        case 25:
          for (; o.length > 6; )
            c += o.shift(), l += o.shift(), s(c, l);
          m = c + o.shift(), y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + o.shift(), r(m, y, b, w, c, l);
          break;
        case 26:
          for (o.length % 2 && (c += o.shift()); o.length > 0; )
            m = c, y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b, l = w + o.shift(), r(m, y, b, w, c, l);
          break;
        case 27:
          for (o.length % 2 && (l += o.shift()); o.length > 0; )
            m = c + o.shift(), y = l, b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w, r(m, y, b, w, c, l);
          break;
        case 28:
          o.push(ha(u, x)), x += 2;
          break;
        case 29:
          A = o.pop() + n.gsubrsBias, C = n.gsubrs[A], C && d(C);
          break;
        case 30:
          for (; o.length > 0 && (m = c, y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + (o.length === 1 ? o.shift() : 0), r(m, y, b, w, c, l), o.length !== 0); )
            m = c + o.shift(), y = l, b = m + o.shift(), w = y + o.shift(), l = w + o.shift(), c = b + (o.length === 1 ? o.shift() : 0), r(m, y, b, w, c, l);
          break;
        case 31:
          for (; o.length > 0 && (m = c + o.shift(), y = l, b = m + o.shift(), w = y + o.shift(), l = w + o.shift(), c = b + (o.length === 1 ? o.shift() : 0), r(m, y, b, w, c, l), o.length !== 0); )
            m = c, y = l + o.shift(), b = m + o.shift(), w = y + o.shift(), c = b + o.shift(), l = w + (o.length === 1 ? o.shift() : 0), r(m, y, b, w, c, l);
          break;
        default:
          if (p < 32)
            throw new W(`unknown operator: ${p}`);
          p < 247 ? o.push(p - 139) : p < 251 ? o.push((p - 247) * 256 + u[x++] + 108) : p < 255 ? o.push(-(p - 251) * 256 - u[x++] - 108) : (o.push((u[x] << 24 | u[x + 1] << 16 | u[x + 2] << 8 | u[x + 3]) / 65536), x += 4);
          break;
      }
      g && (o.length = 0);
    }
  }
  d(t);
}
const qc = "";
class bd {
  cmds = [];
  transformStack = [];
  currentTransform = [1, 0, 0, 1, 0, 0];
  add(e, n) {
    if (n) {
      const {
        currentTransform: a
      } = this;
      for (let i = 0, s = n.length; i < s; i += 2)
        Je.applyTransform(n, a, i);
      this.cmds.push(`${e}${n.join(" ")}`);
    } else
      this.cmds.push(e);
  }
  transform(e) {
    this.currentTransform = Je.transform(this.currentTransform, e);
  }
  translate(e, n) {
    this.transform([1, 0, 0, 1, e, n]);
  }
  save() {
    this.transformStack.push(this.currentTransform.slice());
  }
  restore() {
    this.currentTransform = this.transformStack.pop() || [1, 0, 0, 1, 0, 0];
  }
  getSVG() {
    return this.cmds.join("");
  }
}
class D1 {
  constructor(e) {
    this.fontMatrix = e, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(e) {
    const {
      charCode: n,
      glyphId: a
    } = $r(this.cmap, e);
    let i = this.compiledGlyphs[a], s;
    if (i === void 0) {
      try {
        i = this.compileGlyph(this.glyphs[a], a);
      } catch (r) {
        i = qc, s = r;
      }
      this.compiledGlyphs[a] = i;
    }
    if (this.compiledCharCodeToGlyphId[n] ??= a, s)
      throw s;
    return i;
  }
  compileGlyph(e, n) {
    if (!e?.length || e[0] === 14)
      return qc;
    let a = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const s = this.fdSelect.getFDIndex(n);
      s >= 0 && s < this.fdArray.length ? a = this.fdArray[s].getByName("FontMatrix") || ti : F("Invalid fd index for glyph index.");
    }
    at(an(a, 6), "Expected a valid fontMatrix.");
    const i = new bd();
    return i.transform(a.slice()), this.compileGlyphImpl(e, i, n), i.add("Z"), i.getSVG();
  }
  compileGlyphImpl() {
    _e("Children classes should implement this.");
  }
  hasBuiltPath(e) {
    const {
      charCode: n,
      glyphId: a
    } = $r(this.cmap, e);
    return this.compiledGlyphs[a] !== void 0 && this.compiledCharCodeToGlyphId[n] !== void 0;
  }
}
class yd extends D1 {
  constructor(e, n, a) {
    super(a || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = e, this.cmap = n;
  }
  compileGlyphImpl(e, n) {
    N1(e, n, this);
  }
}
class wd extends D1 {
  constructor(e, n, a) {
    super(a || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = e.glyphs, this.gsubrs = e.gsubrs || [], this.subrs = e.subrs || [], this.cmap = n, this.glyphNameMap = Qn(), this.gsubrsBias = po(this.gsubrs), this.subrsBias = po(this.subrs), this.isCFFCIDFont = e.isCFFCIDFont, this.fdSelect = e.fdSelect, this.fdArray = e.fdArray;
  }
  compileGlyphImpl(e, n, a) {
    mo(e, n, this, a);
  }
}
class vd {
  static create(e, n) {
    const a = new Uint8Array(e.data);
    let i, s, r, o, c, l;
    const h = Ge(a, 4);
    for (let f = 0, d = 12; f < h; f++, d += 16) {
      const u = xn(a.subarray(d, d + 4)), x = nt(a, d + 8), g = nt(a, d + 12);
      switch (u) {
        case "cmap":
          i = gd(a, x);
          break;
        case "glyf":
          s = a.subarray(x, x + g);
          break;
        case "loca":
          r = a.subarray(x, x + g);
          break;
        case "head":
          l = Ge(a, x + 18), c = Ge(a, x + 50);
          break;
        case "CFF ":
          o = pd(a, x, x + g, n);
          break;
      }
    }
    if (s) {
      const f = l ? [1 / l, 0, 0, 1 / l, 0, 0] : e.fontMatrix;
      return new yd(md(s, r, c), i, f);
    }
    return new wd(o, i, e.fontMatrix);
  }
}
const Sd = ut(function(t) {
  t.Courier = 600, t["Courier-Bold"] = 600, t["Courier-BoldOblique"] = 600, t["Courier-Oblique"] = 600, t.Helvetica = ut(function(e) {
    e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
  }), t["Helvetica-Bold"] = ut(function(e) {
    e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
  }), t["Helvetica-BoldOblique"] = ut(function(e) {
    e.space = 278, e.exclam = 333, e.quotedbl = 474, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 722, e.quoteright = 278, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 333, e.semicolon = 333, e.less = 584, e.equal = 584, e.greater = 584, e.question = 611, e.at = 975, e.A = 722, e.B = 722, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 556, e.K = 722, e.L = 611, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 584, e.underscore = 556, e.quoteleft = 278, e.a = 556, e.b = 611, e.c = 556, e.d = 611, e.e = 556, e.f = 333, e.g = 611, e.h = 611, e.i = 278, e.j = 278, e.k = 556, e.l = 278, e.m = 889, e.n = 611, e.o = 611, e.p = 611, e.q = 611, e.r = 389, e.s = 556, e.t = 333, e.u = 611, e.v = 556, e.w = 778, e.x = 556, e.y = 556, e.z = 500, e.braceleft = 389, e.bar = 280, e.braceright = 389, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 238, e.quotedblleft = 500, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 611, e.fl = 611, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 556, e.bullet = 350, e.quotesinglbase = 278, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 611, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 278, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 611, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 722, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 556, e.scommaaccent = 556, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 611, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 556, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 556, e.scedilla = 556, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 611, e.acircumflex = 556, e.Amacron = 722, e.rcaron = 389, e.ccedilla = 556, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 743, e.Umacron = 722, e.uring = 611, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 584, e.uacute = 611, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 556, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 556, e.nacute = 611, e.umacron = 611, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 280, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 611, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 389, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 556, e.zacute = 500, e.iogonek = 278, e.Oacute = 778, e.oacute = 611, e.amacron = 556, e.sacute = 556, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 611, e.twosuperior = 333, e.Odieresis = 778, e.mu = 611, e.igrave = 278, e.ohungarumlaut = 611, e.Eogonek = 667, e.dcroat = 611, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 400, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 611, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 611, e.ntilde = 611, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 611, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 611, e.Ccaron = 722, e.ugrave = 611, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 611, e.Rcommaaccent = 722, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 556, e.minus = 584, e.Icircumflex = 278, e.ncaron = 611, e.tcommaaccent = 333, e.logicalnot = 584, e.odieresis = 611, e.udieresis = 611, e.notequal = 549, e.gcommaaccent = 611, e.eth = 611, e.zcaron = 500, e.ncommaaccent = 611, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
  }), t["Helvetica-Oblique"] = ut(function(e) {
    e.space = 278, e.exclam = 278, e.quotedbl = 355, e.numbersign = 556, e.dollar = 556, e.percent = 889, e.ampersand = 667, e.quoteright = 222, e.parenleft = 333, e.parenright = 333, e.asterisk = 389, e.plus = 584, e.comma = 278, e.hyphen = 333, e.period = 278, e.slash = 278, e.zero = 556, e.one = 556, e.two = 556, e.three = 556, e.four = 556, e.five = 556, e.six = 556, e.seven = 556, e.eight = 556, e.nine = 556, e.colon = 278, e.semicolon = 278, e.less = 584, e.equal = 584, e.greater = 584, e.question = 556, e.at = 1015, e.A = 667, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 722, e.I = 278, e.J = 500, e.K = 667, e.L = 556, e.M = 833, e.N = 722, e.O = 778, e.P = 667, e.Q = 778, e.R = 722, e.S = 667, e.T = 611, e.U = 722, e.V = 667, e.W = 944, e.X = 667, e.Y = 667, e.Z = 611, e.bracketleft = 278, e.backslash = 278, e.bracketright = 278, e.asciicircum = 469, e.underscore = 556, e.quoteleft = 222, e.a = 556, e.b = 556, e.c = 500, e.d = 556, e.e = 556, e.f = 278, e.g = 556, e.h = 556, e.i = 222, e.j = 222, e.k = 500, e.l = 222, e.m = 833, e.n = 556, e.o = 556, e.p = 556, e.q = 556, e.r = 333, e.s = 500, e.t = 278, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 500, e.braceleft = 334, e.bar = 260, e.braceright = 334, e.asciitilde = 584, e.exclamdown = 333, e.cent = 556, e.sterling = 556, e.fraction = 167, e.yen = 556, e.florin = 556, e.section = 556, e.currency = 556, e.quotesingle = 191, e.quotedblleft = 333, e.guillemotleft = 556, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 556, e.dagger = 556, e.daggerdbl = 556, e.periodcentered = 278, e.paragraph = 537, e.bullet = 350, e.quotesinglbase = 222, e.quotedblbase = 333, e.quotedblright = 333, e.guillemotright = 556, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 611, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 370, e.Lslash = 556, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 365, e.ae = 889, e.dotlessi = 278, e.lslash = 222, e.oslash = 611, e.oe = 944, e.germandbls = 611, e.Idieresis = 278, e.eacute = 556, e.abreve = 556, e.uhungarumlaut = 556, e.ecaron = 556, e.Ydieresis = 667, e.divide = 584, e.Yacute = 667, e.Acircumflex = 667, e.aacute = 556, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 500, e.ecircumflex = 556, e.Uring = 722, e.Udieresis = 722, e.aogonek = 556, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 737, e.Emacron = 667, e.ccaron = 500, e.aring = 556, e.Ncommaaccent = 722, e.lacute = 222, e.agrave = 556, e.Tcommaaccent = 611, e.Cacute = 722, e.atilde = 556, e.Edotaccent = 667, e.scaron = 500, e.scedilla = 500, e.iacute = 278, e.lozenge = 471, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 556, e.Amacron = 667, e.rcaron = 333, e.ccedilla = 500, e.Zdotaccent = 611, e.Thorn = 667, e.Omacron = 778, e.Racute = 722, e.Sacute = 667, e.dcaron = 643, e.Umacron = 722, e.uring = 556, e.threesuperior = 333, e.Ograve = 778, e.Agrave = 667, e.Abreve = 667, e.multiply = 584, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 556, e.edieresis = 556, e.cacute = 500, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 278, e.plusminus = 584, e.brokenbar = 260, e.registered = 737, e.Gbreve = 778, e.Idotaccent = 278, e.summation = 600, e.Egrave = 667, e.racute = 333, e.omacron = 556, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 222, e.tcaron = 317, e.eogonek = 556, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 556, e.zacute = 500, e.iogonek = 222, e.Oacute = 778, e.oacute = 556, e.amacron = 556, e.sacute = 500, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 333, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 556, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 834, e.Scedilla = 667, e.lcaron = 299, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 1e3, e.edotaccent = 556, e.Igrave = 278, e.Imacron = 278, e.Lcaron = 556, e.onehalf = 834, e.lessequal = 549, e.ocircumflex = 556, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 556, e.gbreve = 556, e.onequarter = 834, e.Scaron = 667, e.Scommaaccent = 667, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 556, e.Ccaron = 722, e.ugrave = 556, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 556, e.Rcommaaccent = 722, e.Lcommaaccent = 556, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 778, e.zdotaccent = 500, e.Ecaron = 667, e.Iogonek = 278, e.kcommaaccent = 500, e.minus = 584, e.Icircumflex = 278, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 584, e.odieresis = 556, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 556, e.eth = 556, e.zcaron = 500, e.ncommaaccent = 556, e.onesuperior = 333, e.imacron = 278, e.Euro = 556;
  }), t.Symbol = ut(function(e) {
    e.space = 250, e.exclam = 333, e.universal = 713, e.numbersign = 500, e.existential = 549, e.percent = 833, e.ampersand = 778, e.suchthat = 439, e.parenleft = 333, e.parenright = 333, e.asteriskmath = 500, e.plus = 549, e.comma = 250, e.minus = 549, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 549, e.equal = 549, e.greater = 549, e.question = 444, e.congruent = 549, e.Alpha = 722, e.Beta = 667, e.Chi = 722, e.Delta = 612, e.Epsilon = 611, e.Phi = 763, e.Gamma = 603, e.Eta = 722, e.Iota = 333, e.theta1 = 631, e.Kappa = 722, e.Lambda = 686, e.Mu = 889, e.Nu = 722, e.Omicron = 722, e.Pi = 768, e.Theta = 741, e.Rho = 556, e.Sigma = 592, e.Tau = 611, e.Upsilon = 690, e.sigma1 = 439, e.Omega = 768, e.Xi = 645, e.Psi = 795, e.Zeta = 611, e.bracketleft = 333, e.therefore = 863, e.bracketright = 333, e.perpendicular = 658, e.underscore = 500, e.radicalex = 500, e.alpha = 631, e.beta = 549, e.chi = 549, e.delta = 494, e.epsilon = 439, e.phi = 521, e.gamma = 411, e.eta = 603, e.iota = 329, e.phi1 = 603, e.kappa = 549, e.lambda = 549, e.mu = 576, e.nu = 521, e.omicron = 549, e.pi = 549, e.theta = 521, e.rho = 549, e.sigma = 603, e.tau = 439, e.upsilon = 576, e.omega1 = 713, e.omega = 686, e.xi = 493, e.psi = 686, e.zeta = 494, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.similar = 549, e.Euro = 750, e.Upsilon1 = 620, e.minute = 247, e.lessequal = 549, e.fraction = 167, e.infinity = 713, e.florin = 500, e.club = 753, e.diamond = 753, e.heart = 753, e.spade = 753, e.arrowboth = 1042, e.arrowleft = 987, e.arrowup = 603, e.arrowright = 987, e.arrowdown = 603, e.degree = 400, e.plusminus = 549, e.second = 411, e.greaterequal = 549, e.multiply = 549, e.proportional = 713, e.partialdiff = 494, e.bullet = 460, e.divide = 549, e.notequal = 549, e.equivalence = 549, e.approxequal = 549, e.ellipsis = 1e3, e.arrowvertex = 603, e.arrowhorizex = 1e3, e.carriagereturn = 658, e.aleph = 823, e.Ifraktur = 686, e.Rfraktur = 795, e.weierstrass = 987, e.circlemultiply = 768, e.circleplus = 768, e.emptyset = 823, e.intersection = 768, e.union = 768, e.propersuperset = 713, e.reflexsuperset = 713, e.notsubset = 713, e.propersubset = 713, e.reflexsubset = 713, e.element = 713, e.notelement = 713, e.angle = 768, e.gradient = 713, e.registerserif = 790, e.copyrightserif = 790, e.trademarkserif = 890, e.product = 823, e.radical = 549, e.dotmath = 250, e.logicalnot = 713, e.logicaland = 603, e.logicalor = 603, e.arrowdblboth = 1042, e.arrowdblleft = 987, e.arrowdblup = 603, e.arrowdblright = 987, e.arrowdbldown = 603, e.lozenge = 494, e.angleleft = 329, e.registersans = 790, e.copyrightsans = 790, e.trademarksans = 786, e.summation = 713, e.parenlefttp = 384, e.parenleftex = 384, e.parenleftbt = 384, e.bracketlefttp = 384, e.bracketleftex = 384, e.bracketleftbt = 384, e.bracelefttp = 494, e.braceleftmid = 494, e.braceleftbt = 494, e.braceex = 494, e.angleright = 329, e.integral = 274, e.integraltp = 686, e.integralex = 686, e.integralbt = 686, e.parenrighttp = 384, e.parenrightex = 384, e.parenrightbt = 384, e.bracketrighttp = 384, e.bracketrightex = 384, e.bracketrightbt = 384, e.bracerighttp = 494, e.bracerightmid = 494, e.bracerightbt = 494, e.apple = 790;
  }), t["Times-Roman"] = ut(function(e) {
    e.space = 250, e.exclam = 333, e.quotedbl = 408, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 564, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 278, e.semicolon = 278, e.less = 564, e.equal = 564, e.greater = 564, e.question = 444, e.at = 921, e.A = 722, e.B = 667, e.C = 667, e.D = 722, e.E = 611, e.F = 556, e.G = 722, e.H = 722, e.I = 333, e.J = 389, e.K = 722, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 556, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 722, e.W = 944, e.X = 722, e.Y = 722, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 469, e.underscore = 500, e.quoteleft = 333, e.a = 444, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 333, e.s = 389, e.t = 278, e.u = 500, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 480, e.bar = 200, e.braceright = 480, e.asciitilde = 541, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 180, e.quotedblleft = 444, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 453, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 444, e.quotedblright = 444, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 444, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 889, e.ordfeminine = 276, e.Lslash = 611, e.Oslash = 722, e.OE = 889, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 444, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 722, e.divide = 564, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 444, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 444, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 444, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 444, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 444, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 444, e.Amacron = 722, e.rcaron = 333, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 556, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 588, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 722, e.Abreve = 722, e.multiply = 564, e.uacute = 500, e.Tcaron = 611, e.partialdiff = 476, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 444, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 722, e.Iacute = 333, e.plusminus = 564, e.brokenbar = 200, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 333, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 326, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 444, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 344, e.Kcommaaccent = 722, e.Lacute = 611, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 333, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 722, e.zdotaccent = 444, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 500, e.minus = 564, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 564, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
  }), t["Times-Bold"] = ut(function(e) {
    e.space = 250, e.exclam = 333, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 1e3, e.ampersand = 833, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 930, e.A = 722, e.B = 667, e.C = 722, e.D = 722, e.E = 667, e.F = 611, e.G = 778, e.H = 778, e.I = 389, e.J = 500, e.K = 778, e.L = 667, e.M = 944, e.N = 722, e.O = 778, e.P = 611, e.Q = 778, e.R = 722, e.S = 556, e.T = 667, e.U = 722, e.V = 722, e.W = 1e3, e.X = 722, e.Y = 722, e.Z = 667, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 581, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 556, e.c = 444, e.d = 556, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 333, e.k = 556, e.l = 278, e.m = 833, e.n = 556, e.o = 500, e.p = 556, e.q = 556, e.r = 444, e.s = 389, e.t = 333, e.u = 556, e.v = 500, e.w = 722, e.x = 500, e.y = 500, e.z = 444, e.braceleft = 394, e.bar = 220, e.braceright = 394, e.asciitilde = 520, e.exclamdown = 333, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 540, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 1e3, e.ordfeminine = 300, e.Lslash = 667, e.Oslash = 778, e.OE = 1e3, e.ordmasculine = 330, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 556, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 722, e.divide = 570, e.Yacute = 722, e.Acircumflex = 722, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 500, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 667, e.Cacute = 722, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 722, e.Gcommaaccent = 778, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 722, e.rcaron = 444, e.ccedilla = 444, e.Zdotaccent = 667, e.Thorn = 611, e.Omacron = 778, e.Racute = 722, e.Sacute = 556, e.dcaron = 672, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 778, e.Agrave = 722, e.Abreve = 722, e.multiply = 570, e.uacute = 556, e.Tcaron = 667, e.partialdiff = 494, e.ydieresis = 500, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 778, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 444, e.omacron = 500, e.Zacute = 667, e.Zcaron = 667, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 722, e.lcommaaccent = 278, e.tcaron = 416, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 722, e.Adieresis = 722, e.egrave = 444, e.zacute = 444, e.iogonek = 278, e.Oacute = 778, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 778, e.Ugrave = 722, e.Delta = 612, e.thorn = 556, e.twosuperior = 300, e.Odieresis = 778, e.mu = 556, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 556, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 394, e.Kcommaaccent = 778, e.Lacute = 667, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 667, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 778, e.degree = 400, e.ograve = 500, e.Ccaron = 722, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 444, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 722, e.Lcommaaccent = 667, e.Atilde = 722, e.Aogonek = 722, e.Aring = 722, e.Otilde = 778, e.zdotaccent = 444, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 556, e.minus = 570, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 333, e.logicalnot = 570, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 444, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
  }), t["Times-BoldItalic"] = ut(function(e) {
    e.space = 250, e.exclam = 389, e.quotedbl = 555, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 570, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 570, e.equal = 570, e.greater = 570, e.question = 500, e.at = 832, e.A = 667, e.B = 667, e.C = 667, e.D = 722, e.E = 667, e.F = 667, e.G = 722, e.H = 778, e.I = 389, e.J = 500, e.K = 667, e.L = 611, e.M = 889, e.N = 722, e.O = 722, e.P = 611, e.Q = 722, e.R = 667, e.S = 556, e.T = 611, e.U = 722, e.V = 667, e.W = 889, e.X = 667, e.Y = 611, e.Z = 611, e.bracketleft = 333, e.backslash = 278, e.bracketright = 333, e.asciicircum = 570, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 333, e.g = 500, e.h = 556, e.i = 278, e.j = 278, e.k = 500, e.l = 278, e.m = 778, e.n = 556, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 556, e.v = 444, e.w = 667, e.x = 500, e.y = 444, e.z = 389, e.braceleft = 348, e.bar = 220, e.braceright = 348, e.asciitilde = 570, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 278, e.quotedblleft = 500, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 556, e.fl = 556, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 500, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 500, e.quotedblright = 500, e.guillemotright = 500, e.ellipsis = 1e3, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 1e3, e.AE = 944, e.ordfeminine = 266, e.Lslash = 611, e.Oslash = 722, e.OE = 944, e.ordmasculine = 300, e.ae = 722, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 722, e.germandbls = 500, e.Idieresis = 389, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 556, e.ecaron = 444, e.Ydieresis = 611, e.divide = 570, e.Yacute = 611, e.Acircumflex = 667, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 556, e.Edieresis = 667, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 747, e.Emacron = 667, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 722, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 611, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 667, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 494, e.Rcaron = 667, e.Gcommaaccent = 722, e.ucircumflex = 556, e.acircumflex = 500, e.Amacron = 667, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 611, e.Thorn = 611, e.Omacron = 722, e.Racute = 667, e.Sacute = 556, e.dcaron = 608, e.Umacron = 722, e.uring = 556, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 667, e.Abreve = 667, e.multiply = 570, e.uacute = 556, e.Tcaron = 611, e.partialdiff = 494, e.ydieresis = 444, e.Nacute = 722, e.icircumflex = 278, e.Ecircumflex = 667, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 556, e.umacron = 556, e.Ncaron = 722, e.Iacute = 389, e.plusminus = 570, e.brokenbar = 220, e.registered = 747, e.Gbreve = 722, e.Idotaccent = 389, e.summation = 600, e.Egrave = 667, e.racute = 389, e.omacron = 500, e.Zacute = 611, e.Zcaron = 611, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 366, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 667, e.Adieresis = 667, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 576, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 667, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 556, e.lcaron = 382, e.Kcommaaccent = 667, e.Lacute = 611, e.trademark = 1e3, e.edotaccent = 444, e.Igrave = 389, e.Imacron = 389, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 556, e.Uhungarumlaut = 722, e.Eacute = 667, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 556, e.Scommaaccent = 556, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 556, e.radical = 549, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 722, e.otilde = 500, e.Rcommaaccent = 667, e.Lcommaaccent = 611, e.Atilde = 667, e.Aogonek = 667, e.Aring = 667, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 667, e.Iogonek = 389, e.kcommaaccent = 500, e.minus = 606, e.Icircumflex = 389, e.ncaron = 556, e.tcommaaccent = 278, e.logicalnot = 606, e.odieresis = 500, e.udieresis = 556, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 556, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
  }), t["Times-Italic"] = ut(function(e) {
    e.space = 250, e.exclam = 333, e.quotedbl = 420, e.numbersign = 500, e.dollar = 500, e.percent = 833, e.ampersand = 778, e.quoteright = 333, e.parenleft = 333, e.parenright = 333, e.asterisk = 500, e.plus = 675, e.comma = 250, e.hyphen = 333, e.period = 250, e.slash = 278, e.zero = 500, e.one = 500, e.two = 500, e.three = 500, e.four = 500, e.five = 500, e.six = 500, e.seven = 500, e.eight = 500, e.nine = 500, e.colon = 333, e.semicolon = 333, e.less = 675, e.equal = 675, e.greater = 675, e.question = 500, e.at = 920, e.A = 611, e.B = 611, e.C = 667, e.D = 722, e.E = 611, e.F = 611, e.G = 722, e.H = 722, e.I = 333, e.J = 444, e.K = 667, e.L = 556, e.M = 833, e.N = 667, e.O = 722, e.P = 611, e.Q = 722, e.R = 611, e.S = 500, e.T = 556, e.U = 722, e.V = 611, e.W = 833, e.X = 611, e.Y = 556, e.Z = 556, e.bracketleft = 389, e.backslash = 278, e.bracketright = 389, e.asciicircum = 422, e.underscore = 500, e.quoteleft = 333, e.a = 500, e.b = 500, e.c = 444, e.d = 500, e.e = 444, e.f = 278, e.g = 500, e.h = 500, e.i = 278, e.j = 278, e.k = 444, e.l = 278, e.m = 722, e.n = 500, e.o = 500, e.p = 500, e.q = 500, e.r = 389, e.s = 389, e.t = 278, e.u = 500, e.v = 444, e.w = 667, e.x = 444, e.y = 444, e.z = 389, e.braceleft = 400, e.bar = 275, e.braceright = 400, e.asciitilde = 541, e.exclamdown = 389, e.cent = 500, e.sterling = 500, e.fraction = 167, e.yen = 500, e.florin = 500, e.section = 500, e.currency = 500, e.quotesingle = 214, e.quotedblleft = 556, e.guillemotleft = 500, e.guilsinglleft = 333, e.guilsinglright = 333, e.fi = 500, e.fl = 500, e.endash = 500, e.dagger = 500, e.daggerdbl = 500, e.periodcentered = 250, e.paragraph = 523, e.bullet = 350, e.quotesinglbase = 333, e.quotedblbase = 556, e.quotedblright = 556, e.guillemotright = 500, e.ellipsis = 889, e.perthousand = 1e3, e.questiondown = 500, e.grave = 333, e.acute = 333, e.circumflex = 333, e.tilde = 333, e.macron = 333, e.breve = 333, e.dotaccent = 333, e.dieresis = 333, e.ring = 333, e.cedilla = 333, e.hungarumlaut = 333, e.ogonek = 333, e.caron = 333, e.emdash = 889, e.AE = 889, e.ordfeminine = 276, e.Lslash = 556, e.Oslash = 722, e.OE = 944, e.ordmasculine = 310, e.ae = 667, e.dotlessi = 278, e.lslash = 278, e.oslash = 500, e.oe = 667, e.germandbls = 500, e.Idieresis = 333, e.eacute = 444, e.abreve = 500, e.uhungarumlaut = 500, e.ecaron = 444, e.Ydieresis = 556, e.divide = 675, e.Yacute = 556, e.Acircumflex = 611, e.aacute = 500, e.Ucircumflex = 722, e.yacute = 444, e.scommaaccent = 389, e.ecircumflex = 444, e.Uring = 722, e.Udieresis = 722, e.aogonek = 500, e.Uacute = 722, e.uogonek = 500, e.Edieresis = 611, e.Dcroat = 722, e.commaaccent = 250, e.copyright = 760, e.Emacron = 611, e.ccaron = 444, e.aring = 500, e.Ncommaaccent = 667, e.lacute = 278, e.agrave = 500, e.Tcommaaccent = 556, e.Cacute = 667, e.atilde = 500, e.Edotaccent = 611, e.scaron = 389, e.scedilla = 389, e.iacute = 278, e.lozenge = 471, e.Rcaron = 611, e.Gcommaaccent = 722, e.ucircumflex = 500, e.acircumflex = 500, e.Amacron = 611, e.rcaron = 389, e.ccedilla = 444, e.Zdotaccent = 556, e.Thorn = 611, e.Omacron = 722, e.Racute = 611, e.Sacute = 500, e.dcaron = 544, e.Umacron = 722, e.uring = 500, e.threesuperior = 300, e.Ograve = 722, e.Agrave = 611, e.Abreve = 611, e.multiply = 675, e.uacute = 500, e.Tcaron = 556, e.partialdiff = 476, e.ydieresis = 444, e.Nacute = 667, e.icircumflex = 278, e.Ecircumflex = 611, e.adieresis = 500, e.edieresis = 444, e.cacute = 444, e.nacute = 500, e.umacron = 500, e.Ncaron = 667, e.Iacute = 333, e.plusminus = 675, e.brokenbar = 275, e.registered = 760, e.Gbreve = 722, e.Idotaccent = 333, e.summation = 600, e.Egrave = 611, e.racute = 389, e.omacron = 500, e.Zacute = 556, e.Zcaron = 556, e.greaterequal = 549, e.Eth = 722, e.Ccedilla = 667, e.lcommaaccent = 278, e.tcaron = 300, e.eogonek = 444, e.Uogonek = 722, e.Aacute = 611, e.Adieresis = 611, e.egrave = 444, e.zacute = 389, e.iogonek = 278, e.Oacute = 722, e.oacute = 500, e.amacron = 500, e.sacute = 389, e.idieresis = 278, e.Ocircumflex = 722, e.Ugrave = 722, e.Delta = 612, e.thorn = 500, e.twosuperior = 300, e.Odieresis = 722, e.mu = 500, e.igrave = 278, e.ohungarumlaut = 500, e.Eogonek = 611, e.dcroat = 500, e.threequarters = 750, e.Scedilla = 500, e.lcaron = 300, e.Kcommaaccent = 667, e.Lacute = 556, e.trademark = 980, e.edotaccent = 444, e.Igrave = 333, e.Imacron = 333, e.Lcaron = 611, e.onehalf = 750, e.lessequal = 549, e.ocircumflex = 500, e.ntilde = 500, e.Uhungarumlaut = 722, e.Eacute = 611, e.emacron = 444, e.gbreve = 500, e.onequarter = 750, e.Scaron = 500, e.Scommaaccent = 500, e.Ohungarumlaut = 722, e.degree = 400, e.ograve = 500, e.Ccaron = 667, e.ugrave = 500, e.radical = 453, e.Dcaron = 722, e.rcommaaccent = 389, e.Ntilde = 667, e.otilde = 500, e.Rcommaaccent = 611, e.Lcommaaccent = 556, e.Atilde = 611, e.Aogonek = 611, e.Aring = 611, e.Otilde = 722, e.zdotaccent = 389, e.Ecaron = 611, e.Iogonek = 333, e.kcommaaccent = 444, e.minus = 675, e.Icircumflex = 333, e.ncaron = 500, e.tcommaaccent = 278, e.logicalnot = 675, e.odieresis = 500, e.udieresis = 500, e.notequal = 549, e.gcommaaccent = 500, e.eth = 500, e.zcaron = 389, e.ncommaaccent = 500, e.onesuperior = 300, e.imacron = 278, e.Euro = 500;
  }), t.ZapfDingbats = ut(function(e) {
    e.space = 278, e.a1 = 974, e.a2 = 961, e.a202 = 974, e.a3 = 980, e.a4 = 719, e.a5 = 789, e.a119 = 790, e.a118 = 791, e.a117 = 690, e.a11 = 960, e.a12 = 939, e.a13 = 549, e.a14 = 855, e.a15 = 911, e.a16 = 933, e.a105 = 911, e.a17 = 945, e.a18 = 974, e.a19 = 755, e.a20 = 846, e.a21 = 762, e.a22 = 761, e.a23 = 571, e.a24 = 677, e.a25 = 763, e.a26 = 760, e.a27 = 759, e.a28 = 754, e.a6 = 494, e.a7 = 552, e.a8 = 537, e.a9 = 577, e.a10 = 692, e.a29 = 786, e.a30 = 788, e.a31 = 788, e.a32 = 790, e.a33 = 793, e.a34 = 794, e.a35 = 816, e.a36 = 823, e.a37 = 789, e.a38 = 841, e.a39 = 823, e.a40 = 833, e.a41 = 816, e.a42 = 831, e.a43 = 923, e.a44 = 744, e.a45 = 723, e.a46 = 749, e.a47 = 790, e.a48 = 792, e.a49 = 695, e.a50 = 776, e.a51 = 768, e.a52 = 792, e.a53 = 759, e.a54 = 707, e.a55 = 708, e.a56 = 682, e.a57 = 701, e.a58 = 826, e.a59 = 815, e.a60 = 789, e.a61 = 789, e.a62 = 707, e.a63 = 687, e.a64 = 696, e.a65 = 689, e.a66 = 786, e.a67 = 787, e.a68 = 713, e.a69 = 791, e.a70 = 785, e.a71 = 791, e.a72 = 873, e.a73 = 761, e.a74 = 762, e.a203 = 762, e.a75 = 759, e.a204 = 759, e.a76 = 892, e.a77 = 892, e.a78 = 788, e.a79 = 784, e.a81 = 438, e.a82 = 138, e.a83 = 277, e.a84 = 415, e.a97 = 392, e.a98 = 392, e.a99 = 668, e.a100 = 668, e.a89 = 390, e.a90 = 390, e.a93 = 317, e.a94 = 317, e.a91 = 276, e.a92 = 276, e.a205 = 509, e.a85 = 509, e.a206 = 410, e.a86 = 410, e.a87 = 234, e.a88 = 234, e.a95 = 334, e.a96 = 334, e.a101 = 732, e.a102 = 544, e.a103 = 544, e.a104 = 910, e.a106 = 667, e.a107 = 760, e.a108 = 760, e.a112 = 776, e.a111 = 595, e.a110 = 694, e.a109 = 626, e.a120 = 788, e.a121 = 788, e.a122 = 788, e.a123 = 788, e.a124 = 788, e.a125 = 788, e.a126 = 788, e.a127 = 788, e.a128 = 788, e.a129 = 788, e.a130 = 788, e.a131 = 788, e.a132 = 788, e.a133 = 788, e.a134 = 788, e.a135 = 788, e.a136 = 788, e.a137 = 788, e.a138 = 788, e.a139 = 788, e.a140 = 788, e.a141 = 788, e.a142 = 788, e.a143 = 788, e.a144 = 788, e.a145 = 788, e.a146 = 788, e.a147 = 788, e.a148 = 788, e.a149 = 788, e.a150 = 788, e.a151 = 788, e.a152 = 788, e.a153 = 788, e.a154 = 788, e.a155 = 788, e.a156 = 788, e.a157 = 788, e.a158 = 788, e.a159 = 788, e.a160 = 894, e.a161 = 838, e.a163 = 1016, e.a164 = 458, e.a196 = 748, e.a165 = 924, e.a192 = 748, e.a166 = 918, e.a167 = 927, e.a168 = 928, e.a169 = 928, e.a170 = 834, e.a171 = 873, e.a172 = 828, e.a173 = 924, e.a162 = 924, e.a174 = 917, e.a175 = 930, e.a176 = 931, e.a177 = 463, e.a178 = 883, e.a179 = 836, e.a193 = 836, e.a180 = 867, e.a199 = 867, e.a181 = 696, e.a200 = 696, e.a182 = 874, e.a201 = 874, e.a183 = 760, e.a184 = 946, e.a197 = 771, e.a185 = 865, e.a194 = 771, e.a198 = 888, e.a186 = 967, e.a195 = 888, e.a187 = 831, e.a188 = 873, e.a189 = 927, e.a190 = 970, e.a191 = 918;
  });
}), kd = ut(function(t) {
  t.Courier = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: -426
  }, t["Courier-Bold"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 439
  }, t["Courier-Oblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  }, t["Courier-BoldOblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  }, t.Helvetica = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  }, t["Helvetica-Bold"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  }, t["Helvetica-Oblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  }, t["Helvetica-BoldOblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  }, t["Times-Roman"] = {
    ascent: 683,
    descent: -217,
    capHeight: 662,
    xHeight: 450
  }, t["Times-Bold"] = {
    ascent: 683,
    descent: -217,
    capHeight: 676,
    xHeight: 461
  }, t["Times-Italic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 653,
    xHeight: 441
  }, t["Times-BoldItalic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 669,
    xHeight: 462
  }, t.Symbol = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  }, t.ZapfDingbats = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  };
}), Ad = 1, pr = 2, mr = 4, Kc = 8, Ji = 16, Zi = 32, Cd = 64, Qi = 1, br = 2, Id = 8, Td = 32, Ed = 64, Fd = 128, R0 = 256;
class Rd {
  constructor({
    glyfTable: e,
    isGlyphLocationsLong: n,
    locaTable: a,
    numGlyphs: i
  }) {
    this.glyphs = [];
    const s = new DataView(a.buffer, a.byteOffset, a.byteLength), r = new DataView(e.buffer, e.byteOffset, e.byteLength), o = n ? 4 : 2;
    let c = n ? s.getUint32(0) : 2 * s.getUint16(0), l = 0;
    for (let h = 0; h < i; h++) {
      l += o;
      const f = n ? s.getUint32(l) : 2 * s.getUint16(l);
      if (f === c) {
        this.glyphs.push(new Ls({}));
        continue;
      }
      const d = Ls.parse(c, r);
      this.glyphs.push(d), c = f;
    }
  }
  getSize() {
    return Math.sumPrecise(this.glyphs.map((e) => e.getSize() + 3 & -4));
  }
  write() {
    const e = this.getSize(), n = new DataView(new ArrayBuffer(e)), a = e > 131070, i = a ? 4 : 2, s = new DataView(new ArrayBuffer((this.glyphs.length + 1) * i));
    a ? s.setUint32(0, 0) : s.setUint16(0, 0);
    let r = 0, o = 0;
    for (const c of this.glyphs)
      r += c.write(r, n), r = r + 3 & -4, o += i, a ? s.setUint32(o, r) : s.setUint16(o, r >> 1);
    return {
      isLocationLong: a,
      loca: new Uint8Array(s.buffer),
      glyf: new Uint8Array(n.buffer)
    };
  }
  scale(e) {
    for (let n = 0, a = this.glyphs.length; n < a; n++)
      this.glyphs[n].scale(e[n]);
  }
}
class Ls {
  constructor({
    header: e = null,
    simple: n = null,
    composites: a = null
  }) {
    this.header = e, this.simple = n, this.composites = a;
  }
  static parse(e, n) {
    const [a, i] = Wo.parse(e, n);
    if (e += a, i.numberOfContours < 0) {
      const r = [];
      for (; ; ) {
        const [o, c] = Xo.parse(e, n);
        if (e += o, r.push(c), !(c.flags & Td))
          break;
      }
      return new Ls({
        header: i,
        composites: r
      });
    }
    const s = Vo.parse(e, n, i.numberOfContours);
    return new Ls({
      header: i,
      simple: s
    });
  }
  getSize() {
    if (!this.header)
      return 0;
    const e = this.simple ? this.simple.getSize() : Math.sumPrecise(this.composites.map((n) => n.getSize()));
    return this.header.getSize() + e;
  }
  write(e, n) {
    if (!this.header)
      return 0;
    const a = e;
    if (e += this.header.write(e, n), this.simple)
      e += this.simple.write(e, n);
    else
      for (const i of this.composites)
        e += i.write(e, n);
    return e - a;
  }
  scale(e) {
    if (!this.header)
      return;
    const n = (this.header.xMin + this.header.xMax) / 2;
    if (this.header.scale(n, e), this.simple)
      this.simple.scale(n, e);
    else
      for (const a of this.composites)
        a.scale(n, e);
  }
}
class Wo {
  constructor({
    numberOfContours: e,
    xMin: n,
    yMin: a,
    xMax: i,
    yMax: s
  }) {
    this.numberOfContours = e, this.xMin = n, this.yMin = a, this.xMax = i, this.yMax = s;
  }
  static parse(e, n) {
    return [10, new Wo({
      numberOfContours: n.getInt16(e),
      xMin: n.getInt16(e + 2),
      yMin: n.getInt16(e + 4),
      xMax: n.getInt16(e + 6),
      yMax: n.getInt16(e + 8)
    })];
  }
  getSize() {
    return 10;
  }
  write(e, n) {
    return n.setInt16(e, this.numberOfContours), n.setInt16(e + 2, this.xMin), n.setInt16(e + 4, this.yMin), n.setInt16(e + 6, this.xMax), n.setInt16(e + 8, this.yMax), 10;
  }
  scale(e, n) {
    this.xMin = Math.round(e + (this.xMin - e) * n), this.xMax = Math.round(e + (this.xMax - e) * n);
  }
}
class Od {
  constructor({
    flags: e,
    xCoordinates: n,
    yCoordinates: a
  }) {
    this.xCoordinates = n, this.yCoordinates = a, this.flags = e;
  }
}
class Vo {
  constructor({
    contours: e,
    instructions: n
  }) {
    this.contours = e, this.instructions = n;
  }
  static parse(e, n, a) {
    const i = [];
    for (let p = 0; p < a; p++) {
      const m = n.getUint16(e);
      e += 2, i.push(m);
    }
    const s = i[a - 1] + 1, r = n.getUint16(e);
    e += 2;
    const o = new Uint8Array(n).slice(e, e + r);
    e += r;
    const c = [];
    for (let p = 0; p < s; e++, p++) {
      let m = n.getUint8(e);
      if (c.push(m), m & Kc) {
        const b = n.getUint8(++e);
        m ^= Kc;
        for (let y = 0; y < b; y++)
          c.push(m);
        p += b;
      }
    }
    const l = [];
    let h = [], f = [], d = [];
    const u = [];
    let x = 0, g = 0;
    for (let p = 0; p < s; p++) {
      const m = c[p];
      if (m & pr) {
        const b = n.getUint8(e++);
        g += m & Ji ? b : -b, h.push(g);
      } else m & Ji || (g += n.getInt16(e), e += 2), h.push(g);
      i[x] === p && (x++, l.push(h), h = []);
    }
    g = 0, x = 0;
    for (let p = 0; p < s; p++) {
      const m = c[p];
      if (m & mr) {
        const b = n.getUint8(e++);
        g += m & Zi ? b : -b, f.push(g);
      } else m & Zi || (g += n.getInt16(e), e += 2), f.push(g);
      d.push(m & Ad | m & Cd), i[x] === p && (h = l[x], x++, u.push(new Od({
        flags: d,
        xCoordinates: h,
        yCoordinates: f
      })), f = [], d = []);
    }
    return new Vo({
      contours: u,
      instructions: o
    });
  }
  getSize() {
    let e = this.contours.length * 2 + 2 + this.instructions.length, n = 0, a = 0;
    for (const i of this.contours) {
      e += i.flags.length;
      for (let s = 0, r = i.xCoordinates.length; s < r; s++) {
        const o = i.xCoordinates[s], c = i.yCoordinates[s];
        let l = Math.abs(o - n);
        l > 255 ? e += 2 : l > 0 && (e += 1), n = o, l = Math.abs(c - a), l > 255 ? e += 2 : l > 0 && (e += 1), a = c;
      }
    }
    return e;
  }
  write(e, n) {
    const a = e, i = [], s = [], r = [];
    let o = 0, c = 0;
    for (const l of this.contours) {
      for (let h = 0, f = l.xCoordinates.length; h < f; h++) {
        let d = l.flags[h];
        const u = l.xCoordinates[h];
        let x = u - o;
        if (x === 0)
          d |= Ji, i.push(0);
        else {
          const p = Math.abs(x);
          p <= 255 ? (d |= x >= 0 ? pr | Ji : pr, i.push(p)) : i.push(x);
        }
        o = u;
        const g = l.yCoordinates[h];
        if (x = g - c, x === 0)
          d |= Zi, s.push(0);
        else {
          const p = Math.abs(x);
          p <= 255 ? (d |= x >= 0 ? mr | Zi : mr, s.push(p)) : s.push(x);
        }
        c = g, r.push(d);
      }
      n.setUint16(e, i.length - 1), e += 2;
    }
    n.setUint16(e, this.instructions.length), e += 2, this.instructions.length && (new Uint8Array(n.buffer, 0, n.buffer.byteLength).set(this.instructions, e), e += this.instructions.length);
    for (const l of r)
      n.setUint8(e++, l);
    for (let l = 0, h = i.length; l < h; l++) {
      const f = i[l], d = r[l];
      d & pr ? n.setUint8(e++, f) : d & Ji || (n.setInt16(e, f), e += 2);
    }
    for (let l = 0, h = s.length; l < h; l++) {
      const f = s[l], d = r[l];
      d & mr ? n.setUint8(e++, f) : d & Zi || (n.setInt16(e, f), e += 2);
    }
    return e - a;
  }
  scale(e, n) {
    for (const a of this.contours)
      if (a.xCoordinates.length !== 0)
        for (let i = 0, s = a.xCoordinates.length; i < s; i++)
          a.xCoordinates[i] = Math.round(e + (a.xCoordinates[i] - e) * n);
  }
}
class Xo {
  constructor({
    flags: e,
    glyphIndex: n,
    argument1: a,
    argument2: i,
    transf: s,
    instructions: r
  }) {
    this.flags = e, this.glyphIndex = n, this.argument1 = a, this.argument2 = i, this.transf = s, this.instructions = r;
  }
  static parse(e, n) {
    const a = e, i = [];
    let s = n.getUint16(e);
    const r = n.getUint16(e + 2);
    e += 4;
    let o, c;
    s & Qi ? (s & br ? (o = n.getInt16(e), c = n.getInt16(e + 2)) : (o = n.getUint16(e), c = n.getUint16(e + 2)), e += 4, s ^= Qi) : (s & br ? (o = n.getInt8(e), c = n.getInt8(e + 1)) : (o = n.getUint8(e), c = n.getUint8(e + 1)), e += 2), s & Id ? (i.push(n.getUint16(e)), e += 2) : s & Ed ? (i.push(n.getUint16(e), n.getUint16(e + 2)), e += 4) : s & Fd && (i.push(n.getUint16(e), n.getUint16(e + 2), n.getUint16(e + 4), n.getUint16(e + 6)), e += 8);
    let l = null;
    if (s & R0) {
      const h = n.getUint16(e);
      e += 2, l = new Uint8Array(n).slice(e, e + h), e += h;
    }
    return [e - a, new Xo({
      flags: s,
      glyphIndex: r,
      argument1: o,
      argument2: c,
      transf: i,
      instructions: l
    })];
  }
  getSize() {
    let e = 4 + this.transf.length * 2;
    return this.flags & R0 && (e += 2 + this.instructions.length), e += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e += 2), e;
  }
  write(e, n) {
    const a = e;
    return this.flags & br ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= Qi) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= Qi), n.setUint16(e, this.flags), n.setUint16(e + 2, this.glyphIndex), e += 4, this.flags & Qi ? (this.flags & br ? (n.setInt16(e, this.argument1), n.setInt16(e + 2, this.argument2)) : (n.setUint16(e, this.argument1), n.setUint16(e + 2, this.argument2)), e += 4) : (n.setUint8(e, this.argument1), n.setUint8(e + 1, this.argument2), e += 2), this.flags & R0 && (n.setUint16(e, this.instructions.length), e += 2, this.instructions.length && (new Uint8Array(n.buffer, 0, n.buffer.byteLength).set(this.instructions, e), e += this.instructions.length)), e - a;
  }
  scale(e, n) {
  }
}
function yr(t, e, n) {
  t[e] = n >> 8 & 255, t[e + 1] = n & 255;
}
function O0(t, e, n) {
  t[e] = n >> 24 & 255, t[e + 1] = n >> 16 & 255, t[e + 2] = n >> 8 & 255, t[e + 3] = n & 255;
}
function Bd(t, e, n) {
  if (n instanceof Uint8Array)
    t.set(n, e);
  else if (typeof n == "string")
    for (let a = 0, i = n.length; a < i; a++)
      t[e++] = n.charCodeAt(a) & 255;
  else
    for (const a of n)
      t[e++] = a & 255;
}
const Yc = 12, Jc = 16;
class Us {
  constructor(e) {
    this.sfnt = e, this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(e, n) {
    let a = 1, i = 0;
    for (; (a ^ e) > a; )
      a <<= 1, i++;
    const s = a * n;
    return {
      range: s,
      entry: i,
      rangeShift: n * e - s
    };
  }
  toArray() {
    let e = this.sfnt;
    const n = this.tables, a = Object.keys(n);
    a.sort();
    const i = a.length;
    let s, r, o, c, l, h = Yc + i * Jc;
    const f = [h];
    for (s = 0; s < i; s++) {
      c = n[a[s]];
      const x = (c.length + 3 & -4) >>> 0;
      h += x, f.push(h);
    }
    const d = new Uint8Array(h);
    for (s = 0; s < i; s++)
      c = n[a[s]], Bd(d, f[s], c);
    e === "true" && (e = Wt(65536)), d[0] = e.charCodeAt(0) & 255, d[1] = e.charCodeAt(1) & 255, d[2] = e.charCodeAt(2) & 255, d[3] = e.charCodeAt(3) & 255, yr(d, 4, i);
    const u = Us.getSearchParams(i, 16);
    for (yr(d, 6, u.range), yr(d, 8, u.entry), yr(d, 10, u.rangeShift), h = Yc, s = 0; s < i; s++) {
      l = a[s], d[h] = l.charCodeAt(0) & 255, d[h + 1] = l.charCodeAt(1) & 255, d[h + 2] = l.charCodeAt(2) & 255, d[h + 3] = l.charCodeAt(3) & 255;
      let x = 0;
      for (r = f[s], o = f[s + 1]; r < o; r += 4) {
        const g = nt(d, r);
        x = x + g >>> 0;
      }
      O0(d, h + 4, x), O0(d, h + 8, f[s]), O0(d, h + 12, n[l].length), h += Jc;
    }
    return d;
  }
  addTable(e, n) {
    if (e in this.tables)
      throw new Error("Table " + e + " already exists");
    this.tables[e] = n;
  }
}
const Md = !1, en = {
  vmoveto: [4],
  rlineto: [5],
  hlineto: [6],
  vlineto: [7],
  rrcurveto: [8],
  flex: [12, 35],
  endchar: [14],
  rmoveto: [21],
  hmoveto: [22],
  vhcurveto: [30],
  hvcurveto: [31]
};
class Pd {
  constructor() {
    this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
  }
  convert(e, n, a) {
    const i = e.length;
    let s = !1, r, o, c;
    for (let l = 0; l < i; l++) {
      let h = e[l];
      if (h < 32) {
        switch (h === 12 && (h = (h << 8) + e[++l]), h) {
          case 1: {
            this.stack = [];
            break;
          }
          case 3: {
            this.stack = [];
            break;
          }
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                s = !0;
                break;
              }
              const g = this.stack.pop();
              this.stack.push(0, g);
              break;
            }
            s = this.executeCommand(1, en.vmoveto);
            break;
          case 5:
            s = this.executeCommand(2, en.rlineto);
            break;
          case 6:
            s = this.executeCommand(1, en.hlineto);
            break;
          case 7:
            s = this.executeCommand(1, en.vlineto);
            break;
          case 8:
            s = this.executeCommand(6, en.rrcurveto);
            break;
          case 9:
            this.stack = [];
            break;
          case 10:
            if (this.stack.length < 1) {
              s = !0;
              break;
            }
            if (c = this.stack.pop(), !n[c]) {
              s = !0;
              break;
            }
            s = this.convert(n[c], n, a);
            break;
          case 11:
            return s;
          case 13:
            if (this.stack.length < 2) {
              s = !0;
              break;
            }
            r = this.stack.pop(), o = this.stack.pop(), this.lsb = o, this.width = r, this.stack.push(r, o), s = this.executeCommand(2, en.hmoveto);
            break;
          case 14:
            this.output.push(en.endchar[0]);
            break;
          case 21:
            if (this.flexing)
              break;
            s = this.executeCommand(2, en.rmoveto);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            s = this.executeCommand(1, en.hmoveto);
            break;
          case 30:
            s = this.executeCommand(4, en.vhcurveto);
            break;
          case 31:
            s = this.executeCommand(4, en.hvcurveto);
            break;
          case 3072:
            this.stack = [];
            break;
          case 3073: {
            this.stack = [];
            break;
          }
          case 3074: {
            this.stack = [];
            break;
          }
          case 3078:
            if (a) {
              const g = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - g, s = this.executeCommand(0, en.endchar);
            } else
              s = this.executeCommand(4, en.endchar);
            break;
          case 3079:
            if (this.stack.length < 4) {
              s = !0;
              break;
            }
            this.stack.pop(), r = this.stack.pop();
            const f = this.stack.pop();
            o = this.stack.pop(), this.lsb = o, this.width = r, this.stack.push(r, o, f), s = this.executeCommand(3, en.rmoveto);
            break;
          case 3084:
            if (this.stack.length < 2) {
              s = !0;
              break;
            }
            const d = this.stack.pop(), u = this.stack.pop();
            this.stack.push(u / d);
            break;
          case 3088:
            if (this.stack.length < 2) {
              s = !0;
              break;
            }
            c = this.stack.pop();
            const x = this.stack.pop();
            if (c === 0 && x === 3) {
              const g = this.stack.splice(-17, 17);
              this.stack.push(g[2] + g[0], g[3] + g[1], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14]), s = this.executeCommand(13, en.flex, !0), this.flexing = !1, this.stack.push(g[15], g[16]);
            } else c === 1 && x === 0 && (this.flexing = !0);
            break;
          case 3089:
            break;
          case 3105:
            this.stack = [];
            break;
          default:
            F('Unknown type 1 charstring command of "' + h + '"');
            break;
        }
        if (s)
          break;
        continue;
      } else h <= 246 ? h -= 139 : h <= 250 ? h = (h - 247) * 256 + e[++l] + 108 : h <= 254 ? h = -((h - 251) * 256) - e[++l] - 108 : h = (e[++l] & 255) << 24 | (e[++l] & 255) << 16 | (e[++l] & 255) << 8 | (e[++l] & 255) << 0;
      this.stack.push(h);
    }
    return s;
  }
  executeCommand(e, n, a) {
    const i = this.stack.length;
    if (e > i)
      return !0;
    const s = i - e;
    for (let r = s; r < i; r++) {
      let o = this.stack[r];
      Number.isInteger(o) ? this.output.push(28, o >> 8 & 255, o & 255) : (o = 65536 * o | 0, this.output.push(255, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, o & 255));
    }
    return this.output.push(...n), a ? this.stack.splice(s, e) : this.stack.length = 0, !1;
  }
}
const Zc = 55665, Nd = 4330;
function Yn(t) {
  return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
}
function Qc(t, e, n) {
  if (n >= t.length)
    return new Uint8Array(0);
  const a = 52845, i = 22719;
  let s = e | 0, r, o;
  for (r = 0; r < n; r++)
    s = (t[r] + s) * a + i & 65535;
  const c = t.length - n, l = new Uint8Array(c);
  for (r = n, o = 0; o < c; r++, o++) {
    const h = t[r];
    l[o] = h ^ s >> 8, s = (h + s) * a + i & 65535;
  }
  return l;
}
function Dd(t, e, n) {
  let s = e | 0;
  const r = t.length, o = r >>> 1, c = new Uint8Array(o);
  let l, h;
  for (l = 0, h = 0; l < r; l++) {
    const f = t[l];
    if (!Yn(f))
      continue;
    l++;
    let d;
    for (; l < r && !Yn(d = t[l]); )
      l++;
    if (l < r) {
      const u = parseInt(String.fromCharCode(f, d), 16);
      c[h++] = u ^ s >> 8, s = (u + s) * 52845 + 22719 & 65535;
    }
  }
  return c.slice(n, h);
}
function el(t) {
  return t === 47 || t === 91 || t === 93 || t === 123 || t === 125 || t === 40 || t === 41;
}
class tl {
  constructor(e, n, a) {
    if (n) {
      const i = e.getBytes(), s = !((Yn(i[0]) || An(i[0])) && Yn(i[1]) && Yn(i[2]) && Yn(i[3]) && Yn(i[4]) && Yn(i[5]) && Yn(i[6]) && Yn(i[7]));
      e = new pt(s ? Qc(i, Zc, 4) : Dd(i, Zc, 4));
    }
    this.seacAnalysisEnabled = !!a, this.stream = e, this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const e = [];
    for (; ; ) {
      const n = this.getToken();
      if (n === null || n === "]" || n === "}")
        break;
      e.push(parseFloat(n || 0));
    }
    return e;
  }
  readNumber() {
    const e = this.getToken();
    return parseFloat(e || 0);
  }
  readInt() {
    const e = this.getToken();
    return parseInt(e || 0, 10) | 0;
  }
  readBoolean() {
    return this.getToken() === "true" ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    return this.stream.skip(-2), this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e = !1, n = this.currentChar;
    for (; ; ) {
      if (n === -1)
        return null;
      if (e)
        (n === 10 || n === 13) && (e = !1);
      else if (n === 37)
        e = !0;
      else if (!An(n))
        break;
      n = this.nextChar();
    }
    if (el(n))
      return this.nextChar(), String.fromCharCode(n);
    let a = "";
    do
      a += String.fromCharCode(n), n = this.nextChar();
    while (n >= 0 && !An(n) && !el(n));
    return a;
  }
  readCharStrings(e, n) {
    return n === -1 ? e : Qc(e, Nd, n);
  }
  extractFontProgram(e) {
    const n = this.stream, a = [], i = [], s = /* @__PURE__ */ Object.create(null);
    s.lenIV = 4;
    const r = {
      subrs: [],
      charstrings: [],
      properties: {
        privateData: s
      }
    };
    let o, c, l, h;
    for (; (o = this.getToken()) !== null; )
      if (o === "/")
        switch (o = this.getToken(), o) {
          case "CharStrings":
            for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); o = this.getToken(), !(o === null || o === "end"); ) {
              if (o !== "/")
                continue;
              const d = this.getToken();
              c = this.readInt(), this.getToken(), l = c > 0 ? n.getBytes(c) : new Uint8Array(0), h = r.properties.privateData.lenIV;
              const u = this.readCharStrings(l, h);
              this.nextChar(), o = this.getToken(), o === "noaccess" ? this.getToken() : o === "/" && this.prevChar(), i.push({
                glyph: d,
                encoded: u
              });
            }
            break;
          case "Subrs":
            for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
              const d = this.readInt();
              c = this.readInt(), this.getToken(), l = c > 0 ? n.getBytes(c) : new Uint8Array(0), h = r.properties.privateData.lenIV;
              const u = this.readCharStrings(l, h);
              this.nextChar(), o = this.getToken(), o === "noaccess" && this.getToken(), a[d] = u;
            }
            break;
          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const f = this.readNumberArray();
            f.length > 0 && f.length % 2;
            break;
          case "StemSnapH":
          case "StemSnapV":
            r.properties.privateData[o] = this.readNumberArray();
            break;
          case "StdHW":
          case "StdVW":
            r.properties.privateData[o] = this.readNumberArray()[0];
            break;
          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
            r.properties.privateData[o] = this.readNumber();
            break;
          case "ExpansionFactor":
            r.properties.privateData[o] = this.readNumber() || 0.06;
            break;
          case "ForceBold":
            r.properties.privateData[o] = this.readBoolean();
            break;
        }
    for (const {
      encoded: f,
      glyph: d
    } of i) {
      const u = new Pd(), x = u.convert(f, a, this.seacAnalysisEnabled);
      let g = u.output;
      x && (g = [14]);
      const p = {
        glyphName: d,
        charstring: g,
        width: u.width,
        lsb: u.lsb,
        seac: u.seac
      };
      if (d === ".notdef" ? r.charstrings.unshift(p) : r.charstrings.push(p), e.builtInEncoding) {
        const m = e.builtInEncoding.indexOf(d);
        m > -1 && e.widths[m] === void 0 && m >= e.firstChar && m <= e.lastChar && (e.widths[m] = u.width);
      }
    }
    return r;
  }
  extractFontHeader(e) {
    let n;
    for (; (n = this.getToken()) !== null; )
      if (n === "/")
        switch (n = this.getToken(), n) {
          case "FontMatrix":
            const a = this.readNumberArray();
            e.fontMatrix = a;
            break;
          case "Encoding":
            const i = this.getToken();
            let s;
            if (!/^\d+$/.test(i))
              s = Ms(i);
            else {
              s = [];
              const o = parseInt(i, 10) | 0;
              this.getToken();
              for (let c = 0; c < o; c++) {
                for (n = this.getToken(); n !== "dup" && n !== "def"; )
                  if (n = this.getToken(), n === null)
                    return;
                if (n === "def")
                  break;
                const l = this.readInt();
                this.getToken();
                const h = this.getToken();
                s[l] = h, this.getToken();
              }
            }
            e.builtInEncoding = s;
            break;
          case "FontBBox":
            const r = this.readNumberArray();
            e.ascent = Math.max(r[3], r[1]), e.descent = Math.min(r[1], r[3]), e.ascentScaled = !0;
            break;
        }
  }
}
function nl(t, e, n) {
  const a = t.length, i = e.length, s = a - i;
  let r = n, o = !1;
  for (; r < s; ) {
    let c = 0;
    for (; c < i && t[r + c] === e[c]; )
      c++;
    if (c >= i) {
      for (r += c; r < a && An(t[r]); )
        r++;
      o = !0;
      break;
    }
    r++;
  }
  return {
    found: o,
    length: r
  };
}
function Ld(t, e) {
  const n = [101, 101, 120, 101, 99], a = t.pos;
  let i, s, r;
  try {
    i = t.getBytes(e), s = i.length;
  } catch {
  }
  if (s === e && (r = nl(i, n, e - 2 * n.length), r.found && r.length === e))
    return {
      stream: new pt(i),
      length: e
    };
  F('Invalid "Length1" property in Type1 font -- trying to recover.'), t.pos = a;
  const o = 2048;
  let c;
  for (; ; ) {
    const l = t.peekBytes(o);
    if (r = nl(l, n, 0), r.length === 0)
      break;
    if (t.pos += r.length, r.found) {
      c = t.pos - a;
      break;
    }
  }
  return t.pos = a, c ? {
    stream: new pt(t.getBytes(c)),
    length: c
  } : (F('Unable to recover "Length1" property in Type1 font -- using as is.'), {
    stream: new pt(t.getBytes(e)),
    length: e
  });
}
function Ud(t, e) {
  const n = t.getBytes();
  if (n.length === 0)
    throw new W("getEexecBlock - no font program found.");
  return {
    stream: new pt(n),
    length: n.length
  };
}
class jd {
  constructor(e, n, a) {
    let s = a.length1;
    a.length2;
    let r = n.peekBytes(6);
    const o = r[0] === 128 && r[1] === 1;
    o && (n.skip(6), s = r[5] << 24 | r[4] << 16 | r[3] << 8 | r[2]);
    const c = Ld(n, s);
    new tl(c.stream, !1, Mi).extractFontHeader(a), o && (r = n.getBytes(6), r[5] << 24 | r[4] << 16 | r[3] << 8 | r[2]);
    const h = Ud(n), d = new tl(h.stream, !0, Mi).extractFontProgram(a);
    for (const p in d.properties)
      a[p] = d.properties[p];
    const u = d.charstrings, x = this.getType2Charstrings(u), g = this.getType2Subrs(d.subrs);
    this.charstrings = u, this.data = this.wrap(e, x, this.charstrings, g, a), this.seacs = this.getSeacs(d.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const e = [".notdef"];
    for (const {
      glyphName: n
    } of this.charstrings)
      e.push(n);
    return e;
  }
  getGlyphMapping(e) {
    const n = this.charstrings;
    if (e.composite) {
      const o = /* @__PURE__ */ Object.create(null);
      for (let c = 0, l = n.length; c < l; c++) {
        const h = e.cMap.charCodeOf(c);
        o[h] = c + 1;
      }
      return o;
    }
    const a = [".notdef"];
    let i, s;
    for (s = 0; s < n.length; s++)
      a.push(n[s].glyphName);
    const r = e.builtInEncoding;
    if (r) {
      i = /* @__PURE__ */ Object.create(null);
      for (const o in r)
        s = a.indexOf(r[o]), s >= 0 && (i[o] = s);
    }
    return O1(e, i, a);
  }
  hasGlyphId(e) {
    return e < 0 || e >= this.numGlyphs ? !1 : e === 0 ? !0 : this.charstrings[e - 1].charstring.length > 0;
  }
  getSeacs(e) {
    const n = [];
    for (let a = 0, i = e.length; a < i; a++) {
      const s = e[a];
      s.seac && (n[a + 1] = s.seac);
    }
    return n;
  }
  getType2Charstrings(e) {
    const n = [];
    for (const a of e)
      n.push(a.charstring);
    return n;
  }
  getType2Subrs(e) {
    let n = 0;
    const a = e.length;
    a < 1133 ? n = 107 : a < 33769 ? n = 1131 : n = 32768;
    const i = [];
    let s;
    for (s = 0; s < n; s++)
      i.push([11]);
    for (s = 0; s < a; s++)
      i.push(e[s]);
    return i;
  }
  wrap(e, n, a, i, s) {
    const r = new B1();
    r.header = new M1(1, 0, 4, 4), r.names = [e];
    const o = new Ps();
    o.setByName("version", 391), o.setByName("Notice", 392), o.setByName("FullName", 393), o.setByName("FamilyName", 394), o.setByName("Weight", 395), o.setByName("Encoding", null), o.setByName("FontMatrix", s.fontMatrix), o.setByName("FontBBox", s.bbox), o.setByName("charset", null), o.setByName("CharStrings", null), o.setByName("Private", null), r.topDict = o;
    const c = new zo();
    c.add("Version 0.11"), c.add("See original notice"), c.add(e), c.add(e), c.add("Medium"), r.strings = c, r.globalSubrIndex = new Ba();
    const l = n.length, h = [".notdef"];
    let f, d;
    for (f = 0; f < l; f++) {
      const b = a[f].glyphName;
      Rr.indexOf(b) === -1 && c.add(b), h.push(b);
    }
    r.charset = new ds(!1, 0, h);
    const u = new Ba();
    for (u.add([139, 14]), f = 0; f < l; f++)
      u.add(n[f]);
    r.charStrings = u;
    const x = new Ns();
    x.setByName("Subrs", null);
    const g = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (f = 0, d = g.length; f < d; f++) {
      const b = g[f];
      if (!(b in s.privateData))
        continue;
      const y = s.privateData[b];
      if (Array.isArray(y))
        for (let w = y.length - 1; w > 0; w--)
          y[w] -= y[w - 1];
      x.setByName(b, y);
    }
    r.topDict.privateDict = x;
    const p = new Ba();
    for (f = 0, d = i.length; f < d; f++)
      p.add(i[f]);
    return x.subrsIndex = p, new Xs(r).compile();
  }
}
const ra = [[57344, 63743], [1048576, 1114109]], qa = 1e3, Hd = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "disableFontFace", "fallbackName", "fontExtraProperties", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "systemFontInfo", "vertical"], $d = ["cMap", "composite", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "subtype", "toFontChar", "toUnicode", "type", "vmetrics", "widths"];
function al(t) {
  if (!t.fontMatrix || t.fontMatrix[0] === ti[0])
    return;
  const e = 1e-3 / t.fontMatrix[0], n = t.widths;
  for (const a in n)
    n[a] *= e;
  t.defaultWidth *= e;
}
function Gd(t, e, n) {
  if (t.isInternalFont || t.hasIncludedToUnicodeMap || t.hasEncoding || t.toUnicode instanceof On || !e || n.length === 0 || t.defaultEncoding === Bs)
    return;
  for (const r of n)
    if (!U1(r))
      return;
  const a = Bs, i = [], s = Qn();
  for (const r in a) {
    const o = a[r];
    if (o === "")
      continue;
    const c = s[o];
    c !== void 0 && (i[r] = String.fromCharCode(c));
  }
  i.length > 0 && t.toUnicode.amend(i);
}
function zd(t, e) {
  if (t.isInternalFont || t.hasIncludedToUnicodeMap || e === t.defaultEncoding || t.toUnicode instanceof On)
    return;
  const n = [], a = Qn();
  for (const i in e) {
    if (t.hasEncoding && (t.baseEncodingName || t.differences[i] !== void 0))
      continue;
    const s = e[i], r = Li(s, a);
    r !== -1 && (n[i] = String.fromCharCode(r));
  }
  n.length > 0 && t.toUnicode.amend(n);
}
function il(t) {
  if (!t.fallbackToUnicode || t.toUnicode instanceof On)
    return;
  const e = [];
  for (const n in t.fallbackToUnicode)
    t.toUnicode.has(n) || (e[n] = t.fallbackToUnicode[n]);
  e.length > 0 && t.toUnicode.amend(e);
}
class _d {
  constructor(e, n, a, i, s, r, o, c, l) {
    this.originalCharCode = e, this.fontChar = n, this.unicode = a, this.accent = i, this.width = s, this.vmetric = r, this.operatorListId = o, this.isSpace = c, this.isInFont = l;
  }
  get category() {
    return ae(this, "category", Qu(this.unicode), !0);
  }
}
function _a(t, e) {
  return (t << 8) + e;
}
function es(t, e, n) {
  t[e + 1] = n, t[e] = n >>> 8;
}
function yn(t, e) {
  const n = (t << 8) + e;
  return n & 32768 ? n - 65536 : n;
}
function Wd(t, e, n) {
  t[e + 3] = n & 255, t[e + 2] = n >>> 8, t[e + 1] = n >>> 16, t[e] = n >>> 24;
}
function Vd(t, e, n, a) {
  return (t << 24) + (e << 16) + (n << 8) + a;
}
function Qe(t) {
  return String.fromCharCode(t >> 8 & 255, t & 255);
}
function Wa(t) {
  return t > 32767 ? t = 32767 : t < -32768 && (t = -32768), String.fromCharCode(t >> 8 & 255, t & 255);
}
function Xd(t) {
  const e = t.peekBytes(4);
  return nt(e, 0) === 65536 || xn(e) === "true";
}
function L1(t) {
  const e = t.peekBytes(4);
  return xn(e) === "ttcf";
}
function qd(t) {
  const e = t.peekBytes(4);
  return xn(e) === "OTTO";
}
function Kd(t) {
  const e = t.peekBytes(2);
  return e[0] === 37 && e[1] === 33 || e[0] === 128 && e[1] === 1;
}
function Yd(t) {
  const e = t.peekBytes(4);
  return e[0] >= 1 && e[3] >= 1 && e[3] <= 4;
}
function Jd(t, {
  type: e,
  subtype: n,
  composite: a
}) {
  let i, s;
  return Xd(t) || L1(t) ? i = a ? "CIDFontType2" : "TrueType" : qd(t) ? i = a ? "CIDFontType2" : "OpenType" : Kd(t) ? a ? i = "CIDFontType0" : i = e === "MMType1" ? "MMType1" : "Type1" : Yd(t) ? a ? (i = "CIDFontType0", s = "CIDFontType0C") : (i = e === "MMType1" ? "MMType1" : "Type1", s = "Type1C") : (F("getFontFileType: Unable to detect correct font file Type/Subtype."), i = e, s = n), [i, s];
}
function wr(t, e) {
  for (const n in e)
    t[+n] = e[n];
}
function B0(t, e, n) {
  const a = [];
  let i;
  for (let s = 0, r = t.length; s < r; s++)
    i = Li(t[s], e), i !== -1 && (a[s] = i);
  for (const s in n)
    i = Li(n[s], e), i !== -1 && (a[+s] = i);
  return a;
}
function Zd(t) {
  return t.platform === 1 && t.encoding === 0 && t.language === 0;
}
function U1(t) {
  return t.platform === 3 && t.encoding === 1 && t.language === 1033;
}
function M0(t, e, n = !1) {
  switch (e.length) {
    case 1:
      return e.charCodeAt(0);
    case 2:
      return e.charCodeAt(0) << 8 | e.charCodeAt(1);
  }
  const a = `Unsupported CID string (charCode ${t}): "${e}".`;
  if (n)
    throw new W(a);
  return F(a), e;
}
function sl(t, e, n, a) {
  const i = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map(), r = [], o = /* @__PURE__ */ new Set();
  let c = 0, h = ra[c][0], f = ra[c][1];
  const d = (x) => ra[0][0] <= x && x <= ra[0][1] || ra[1][0] <= x && x <= ra[1][1];
  let u = null;
  for (const x in t) {
    let g = t[x];
    if (!e(g))
      continue;
    if (h > f) {
      if (c++, c >= ra.length) {
        F("Ran out of space in font private use area.");
        break;
      }
      h = ra[c][0], f = ra[c][1];
    }
    const p = h++;
    g === 0 && (g = n);
    let m = a.get(x);
    if (typeof m == "string")
      if (m.length === 1)
        m = m.codePointAt(0);
      else {
        if (!u) {
          u = /* @__PURE__ */ new Map();
          for (let b = 64256; b <= 64335; b++) {
            const y = String.fromCharCode(b).normalize("NFKD");
            y.length > 1 && u.set(y, b);
          }
        }
        m = u.get(m) || m.codePointAt(0);
      }
    m && !d(m) && !o.has(g) && (s.set(m, g), o.add(g)), i[p] = g, r[x] = p;
  }
  return {
    toFontChar: r,
    charCodeToGlyphId: i,
    toUnicodeExtraMap: s,
    nextAvailableFontCharCode: h
  };
}
function Qd(t, e, n) {
  const a = [];
  for (const r in t)
    t[r] >= n || a.push({
      fontCharCode: r | 0,
      glyphId: t[r]
    });
  if (e)
    for (const [r, o] of e)
      o >= n || a.push({
        fontCharCode: r,
        glyphId: o
      });
  a.length === 0 && a.push({
    fontCharCode: 0,
    glyphId: 0
  }), a.sort((r, o) => r.fontCharCode - o.fontCharCode);
  const i = [], s = a.length;
  for (let r = 0; r < s; ) {
    const o = a[r].fontCharCode, c = [a[r].glyphId];
    ++r;
    let l = o;
    for (; r < s && l + 1 === a[r].fontCharCode && (c.push(a[r].glyphId), ++l, ++r, l !== 65535); )
      ;
    i.push([o, l, c]);
  }
  return i;
}
function rl(t, e, n) {
  const a = Qd(t, e, n), i = a.at(-1)[1] > 65535 ? 2 : 1;
  let s = "\0\0" + Qe(i) + "\0\0" + Wt(4 + i * 8), r, o, c, l;
  for (r = a.length - 1; r >= 0 && !(a[r][0] <= 65535); --r)
    ;
  const h = r + 1;
  a[r][0] < 65535 && a[r][1] === 65535 && (a[r][1] = 65534);
  const f = a[r][1] < 65535 ? 1 : 0, d = h + f, u = Us.getSearchParams(d, 2);
  let x = "", g = "", p = "", m = "", b = "", y = 0, w, S, v, k;
  for (r = 0, o = h; r < o; r++) {
    w = a[r], S = w[0], v = w[1], x += Qe(S), g += Qe(v), k = w[2];
    let M = !0;
    for (c = 1, l = k.length; c < l; ++c)
      if (k[c] !== k[c - 1] + 1) {
        M = !1;
        break;
      }
    if (M) {
      const O = k[0];
      p += Qe(O - S & 65535), m += Qe(0);
    } else {
      const O = (d - r) * 2 + y * 2;
      for (y += v - S + 1, p += Qe(0), m += Qe(O), c = 0, l = k.length; c < l; ++c)
        b += Qe(k[c]);
    }
  }
  f > 0 && (g += "", x += "", p += "\0", m += "\0\0");
  const A = "\0\0" + Qe(2 * d) + Qe(u.range) + Qe(u.entry) + Qe(u.rangeShift) + g + "\0\0" + x + p + m + b;
  let C = "", T = "";
  if (i > 1) {
    for (s += `\0\0
` + Wt(4 + i * 8 + 4 + A.length), C = "", r = 0, o = a.length; r < o; r++) {
      w = a[r], S = w[0], k = w[2];
      let M = k[0];
      for (c = 1, l = k.length; c < l; ++c)
        k[c] !== k[c - 1] + 1 && (v = w[0] + c - 1, C += Wt(S) + Wt(v) + Wt(M), S = v + 1, M = k[c]);
      C += Wt(S) + Wt(w[1]) + Wt(M);
    }
    T = "\0\f\0\0" + Wt(C.length + 16) + "\0\0\0\0" + Wt(C.length / 12);
  }
  return s + "\0" + Qe(A.length + 4) + A + T + C;
}
function e2(t, e) {
  e.pos = (e.start || 0) + t.offset;
  const n = e.getUint16();
  e.skip(60);
  const a = e.getUint16();
  if (n < 4 && a & 768)
    return !1;
  const i = e.getUint16(), s = e.getUint16();
  return i > s || (e.skip(6), e.getUint16() === 0) ? !1 : (t.data[8] = t.data[9] = 0, !0);
}
function ol(t, e, n) {
  n ||= {
    unitsPerEm: 0,
    yMax: 0,
    yMin: 0,
    ascent: 0,
    descent: 0
  };
  let a = 0, i = 0, s = 0, r = 0, o = null, c = 0, l = -1;
  if (e) {
    for (let m in e)
      if (m |= 0, (o > m || !o) && (o = m), c < m && (c = m), l = Ju(m, l), l < 32)
        a |= 1 << l;
      else if (l < 64)
        i |= 1 << l - 32;
      else if (l < 96)
        s |= 1 << l - 64;
      else if (l < 123)
        r |= 1 << l - 96;
      else
        throw new W("Unicode ranges Bits > 123 are reserved for internal usage");
    c > 65535 && (c = 65535);
  } else
    o = 0, c = 255;
  const h = t.bbox || [0, 0, 0, 0], f = n.unitsPerEm || (t.fontMatrix ? 1 / Math.max(...t.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), d = t.ascentScaled ? 1 : f / qa, u = n.ascent || Math.round(d * (t.ascent || h[3]));
  let x = n.descent || Math.round(d * (t.descent || h[1]));
  x > 0 && t.descent > 0 && h[1] < 0 && (x = -x);
  const g = n.yMax || u, p = -n.yMin || -x;
  return "\0$\0\0\0\0\0\0\0\0\x001\0\0\0\0" + String.fromCharCode(t.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + Wt(a) + Wt(i) + Wt(s) + Wt(r) + "*21*" + Qe(t.italicAngle ? 1 : 0) + Qe(o || t.firstChar) + Qe(c || t.lastChar) + Qe(u) + Qe(x) + "\0d" + Qe(g) + Qe(p) + "\0\0\0\0\0\0\0\0" + Qe(t.xHeight) + Qe(t.capHeight) + Qe(0) + Qe(o || t.firstChar) + "\0";
}
function cl(t) {
  const e = Math.floor(t.italicAngle * 65536);
  return "\0\0\0" + Wt(e) + "\0\0\0\0" + Wt(t.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function t2(t) {
  return t.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function P0(t, e) {
  e || (e = [[], []]);
  const n = [e[0][0] || "Original licence", e[0][1] || t, e[0][2] || "Unknown", e[0][3] || "uniqueID", e[0][4] || t, e[0][5] || "Version 0.11", e[0][6] || t2(t), e[0][7] || "Unknown", e[0][8] || "Unknown", e[0][9] || "Unknown"], a = [];
  let i, s, r, o, c;
  for (i = 0, s = n.length; i < s; i++) {
    c = e[1][i] || n[i];
    const p = [];
    for (r = 0, o = c.length; r < o; r++)
      p.push(Qe(c.charCodeAt(r)));
    a.push(p.join(""));
  }
  const l = [n, a], h = ["\0", "\0"], f = ["\0\0", "\0"], d = ["\0\0", "	"], u = n.length * h.length;
  let x = "\0\0" + Qe(u) + Qe(u * 12 + 6), g = 0;
  for (i = 0, s = h.length; i < s; i++) {
    const p = l[i];
    for (r = 0, o = p.length; r < o; r++) {
      c = p[r];
      const m = h[i] + f[i] + d[i] + Qe(r) + Qe(c.length) + Qe(g);
      x += m, g += c.length;
    }
  }
  return x += n.join("") + a.join(""), x;
}
class ll {
  constructor(e, n, a, i) {
    this.name = e, this.psName = null, this.mimetype = null, this.disableFontFace = i.disableFontFace, this.fontExtraProperties = i.fontExtraProperties, this.loadedName = a.loadedName, this.isType3Font = a.isType3Font, this.missingFile = !1, this.cssFontInfo = a.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
    let s = !!(a.flags & Dn.Serif);
    if (!s && !a.isSimulatedFlags) {
      const h = Ds(), f = xo(), d = _o();
      for (const u of e.split("+")) {
        let x = u.replaceAll(/[,_]/g, "-");
        if (x = h[x] || f[x] || x, x = x.split("-", 1)[0], d[x]) {
          s = !0;
          break;
        }
      }
    }
    this.isSerifFont = s, this.isSymbolicFont = !!(a.flags & Dn.Symbolic), this.isMonospace = !!(a.flags & Dn.FixedPitch);
    let {
      type: r,
      subtype: o
    } = a;
    this.type = r, this.subtype = o, this.systemFontInfo = a.systemFontInfo;
    const c = e.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    if (this.isInvalidPDFjsFont = !!c, this.isInvalidPDFjsFont ? this.fallbackName = c[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", this.systemFontInfo?.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = a.differences, this.widths = a.widths, this.defaultWidth = a.defaultWidth, this.composite = a.composite, this.cMap = a.cMap, this.capHeight = a.capHeight / qa, this.ascent = a.ascent / qa, this.descent = a.descent / qa, this.lineHeight = this.ascent - this.descent, this.fontMatrix = a.fontMatrix, this.bbox = a.bbox, this.defaultEncoding = a.defaultEncoding, this.toUnicode = a.toUnicode, this.toFontChar = [], a.type === "Type3") {
      for (let h = 0; h < 256; h++)
        this.toFontChar[h] = this.differences[h] || a.defaultEncoding[h];
      return;
    }
    if (this.cidEncoding = a.cidEncoding || "", this.vertical = !!a.vertical, this.vertical && (this.vmetrics = a.vmetrics, this.defaultVMetrics = a.defaultVMetrics), !n || n.isEmpty) {
      n && F('Font file is empty in "' + e + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(a);
      return;
    }
    [r, o] = Jd(n, a), (r !== this.type || o !== this.subtype) && Ue(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${r}/${o}.`);
    let l;
    try {
      switch (r) {
        case "MMType1":
          Ue("MMType1 font (" + e + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const h = o === "Type1C" || o === "CIDFontType0C" ? new F0(n, a) : new jd(e, n, a);
          al(a), l = this.convert(e, h, a);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype", l = this.checkAndRepair(e, n, a), al(a), this.isOpenType && (r = "OpenType");
          break;
        default:
          throw new W(`Font ${r} is not supported`);
      }
    } catch (h) {
      F(h), this.fallbackToSystemFont(a);
      return;
    }
    il(a), this.data = l, this.type = r, this.subtype = o, this.fontMatrix = a.fontMatrix, this.widths = a.widths, this.defaultWidth = a.defaultWidth, this.toUnicode = a.toUnicode, this.seacMap = a.seacMap;
  }
  get renderer() {
    const e = vd.create(this, Mi);
    return ae(this, "renderer", e);
  }
  exportData() {
    const e = /* @__PURE__ */ Object.create(null);
    for (const a of Hd) {
      const i = this[a];
      i !== void 0 && (e[a] = i);
    }
    if (!this.fontExtraProperties)
      return {
        data: e
      };
    const n = /* @__PURE__ */ Object.create(null);
    for (const a of $d) {
      const i = this[a];
      i !== void 0 && (n[a] = i);
    }
    return {
      data: e,
      extra: n
    };
  }
  fallbackToSystemFont(e) {
    this.missingFile = !0;
    const {
      name: n,
      type: a
    } = this;
    let i = Vs(n);
    const s = Ds(), r = xo(), o = !!s[i], c = !!(r[i] && s[r[i]]);
    i = s[i] || r[i] || i;
    const h = kd()[i];
    h && (isNaN(this.ascent) && (this.ascent = h.ascent / qa), isNaN(this.descent) && (this.descent = h.descent / qa), isNaN(this.capHeight) && (this.capHeight = h.capHeight / qa)), this.bold = /bold/gi.test(i), this.italic = /oblique|italic/gi.test(i), this.black = /Black/g.test(n);
    const f = /Narrow/g.test(n);
    if (this.remeasure = (!o || f) && Object.keys(this.widths).length > 0, (o || c) && a === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const d = e.cidToGidMap, u = [];
      if (wr(u, Wc()), /Arial-?Black/i.test(n) ? wr(u, dd()) : /Calibri/i.test(n) && wr(u, xd()), d) {
        for (const x in u) {
          const g = u[x];
          d[g] !== void 0 && (u[+x] = d[g]);
        }
        d.length !== this.toUnicode.length && e.hasIncludedToUnicodeMap && this.toUnicode instanceof On && this.toUnicode.forEach(function(x, g) {
          const p = u[x];
          d[p] === void 0 && (u[+x] = g);
        });
      }
      this.toUnicode instanceof On || this.toUnicode.forEach(function(x, g) {
        u[+x] = g;
      }), this.toFontChar = u, this.toUnicode = new xs(u);
    } else if (/Symbol/i.test(i))
      this.toFontChar = B0(Ho, Qn(), this.differences);
    else if (/Dingbats/i.test(i))
      this.toFontChar = B0($o, qu(), this.differences);
    else if (o || c) {
      const d = B0(this.defaultEncoding, Qn(), this.differences);
      a === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof On) && this.toUnicode.forEach(function(u, x) {
        d[+u] = x;
      }), this.toFontChar = d;
    } else {
      const d = Qn(), u = [];
      this.toUnicode.forEach((x, g) => {
        if (!this.composite) {
          const p = this.differences[x] || this.defaultEncoding[x], m = Li(p, d);
          m !== -1 && (g = m);
        }
        u[+x] = g;
      }), this.composite && this.toUnicode instanceof On && /Tahoma|Verdana/i.test(n) && wr(u, Wc()), this.toFontChar = u;
    }
    il(e), this.loadedName = i.split("-", 1)[0];
  }
  checkAndRepair(e, n, a) {
    const i = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function s(D, G) {
      const R = /* @__PURE__ */ Object.create(null);
      R["OS/2"] = null, R.cmap = null, R.head = null, R.hhea = null, R.hmtx = null, R.maxp = null, R.name = null, R.post = null;
      for (let L = 0; L < G; L++) {
        const V = r(D);
        i.includes(V.tag) && V.length !== 0 && (R[V.tag] = V);
      }
      return R;
    }
    function r(D) {
      const G = D.getString(4), R = D.getInt32() >>> 0, L = D.getInt32() >>> 0, V = D.getInt32() >>> 0, he = D.pos;
      D.pos = D.start || 0, D.skip(L);
      const te = D.getBytes(V);
      return D.pos = he, G === "head" && (te[8] = te[9] = te[10] = te[11] = 0, te[17] |= 32), {
        tag: G,
        checksum: R,
        length: V,
        offset: L,
        data: te
      };
    }
    function o(D) {
      return {
        version: D.getString(4),
        numTables: D.getUint16(),
        searchRange: D.getUint16(),
        entrySelector: D.getUint16(),
        rangeShift: D.getUint16()
      };
    }
    function c(D) {
      const G = D.getString(4);
      at(G === "ttcf", "Must be a TrueType Collection font.");
      const R = D.getUint16(), L = D.getUint16(), V = D.getInt32() >>> 0, he = [];
      for (let _ = 0; _ < V; _++)
        he.push(D.getInt32() >>> 0);
      const te = {
        ttcTag: G,
        majorVersion: R,
        minorVersion: L,
        numFonts: V,
        offsetTable: he
      };
      switch (R) {
        case 1:
          return te;
        case 2:
          return te.dsigTag = D.getInt32() >>> 0, te.dsigLength = D.getInt32() >>> 0, te.dsigOffset = D.getInt32() >>> 0, te;
      }
      throw new W(`Invalid TrueType Collection majorVersion: ${R}.`);
    }
    function l(D, G) {
      const {
        numFonts: R,
        offsetTable: L
      } = c(D), V = G.split("+");
      let he;
      for (let te = 0; te < R; te++) {
        D.pos = (D.start || 0) + L[te];
        const _ = o(D), de = s(D, _.numTables);
        if (!de.name)
          throw new W('TrueType Collection font must contain a "name" table.');
        const [fe] = p(de.name);
        for (let Ee = 0, Ae = fe.length; Ee < Ae; Ee++)
          for (let ie = 0, ue = fe[Ee].length; ie < ue; ie++) {
            const ce = fe[Ee][ie]?.replaceAll(/\s/g, "");
            if (ce) {
              if (ce === G)
                return {
                  header: _,
                  tables: de
                };
              if (!(V.length < 2))
                for (const ke of V)
                  ce === ke && (he = {
                    name: ke,
                    header: _,
                    tables: de
                  });
            }
          }
      }
      if (he)
        return F(`TrueType Collection does not contain "${G}" font, falling back to "${he.name}" font instead.`), {
          header: he.header,
          tables: he.tables
        };
      throw new W(`TrueType Collection does not contain "${G}" font.`);
    }
    function h(D, G, R, L) {
      if (!D)
        return F("No cmap table available."), {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: !1
        };
      let V, he = (G.start || 0) + D.offset;
      G.pos = he, G.skip(2);
      const te = G.getUint16();
      let _, de = !1;
      for (let me = 0; me < te; me++) {
        const ge = G.getUint16(), ve = G.getUint16(), Re = G.getInt32() >>> 0;
        let ne = !1;
        if (!(_?.platformId === ge && _?.encodingId === ve)) {
          if (ge === 0 && (ve === 0 || ve === 1 || ve === 3))
            ne = !0;
          else if (ge === 1 && ve === 0)
            ne = !0;
          else if (ge === 3 && ve === 1 && (L || !_))
            ne = !0, R || (de = !0);
          else if (R && ge === 3 && ve === 0) {
            ne = !0;
            let Fe = !0;
            if (me < te - 1) {
              const Te = G.peekBytes(2);
              _a(Te[0], Te[1]) < ge && (Fe = !1);
            }
            Fe && (de = !0);
          }
          if (ne && (_ = {
            platformId: ge,
            encodingId: ve,
            offset: Re
          }), de)
            break;
        }
      }
      if (_ && (G.pos = he + _.offset), !_ || G.peekByte() === -1)
        return F("Could not find a preferred cmap table."), {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: !1
        };
      const fe = G.getUint16();
      let Ee = !1;
      const Ae = [];
      let ie, ue;
      if (fe === 0) {
        for (G.skip(4), ie = 0; ie < 256; ie++) {
          const me = G.getByte();
          me && Ae.push({
            charCode: ie,
            glyphId: me
          });
        }
        Ee = !0;
      } else if (fe === 2) {
        G.skip(4);
        const me = [];
        let ge = 0;
        for (let Re = 0; Re < 256; Re++) {
          const ne = G.getUint16() >> 3;
          me.push(ne), ge = Math.max(ne, ge);
        }
        const ve = [];
        for (let Re = 0; Re <= ge; Re++)
          ve.push({
            firstCode: G.getUint16(),
            entryCount: G.getUint16(),
            idDelta: yn(G.getByte(), G.getByte()),
            idRangePos: G.pos + G.getUint16()
          });
        for (let Re = 0; Re < 256; Re++)
          if (me[Re] === 0)
            G.pos = ve[0].idRangePos + 2 * Re, ue = G.getUint16(), Ae.push({
              charCode: Re,
              glyphId: ue
            });
          else {
            const ne = ve[me[Re]];
            for (ie = 0; ie < ne.entryCount; ie++) {
              const Fe = (Re << 8) + ie + ne.firstCode;
              G.pos = ne.idRangePos + 2 * ie, ue = G.getUint16(), ue !== 0 && (ue = (ue + ne.idDelta) % 65536), Ae.push({
                charCode: Fe,
                glyphId: ue
              });
            }
          }
      } else if (fe === 4) {
        G.skip(4);
        const me = G.getUint16() >> 1;
        G.skip(6);
        const ge = [];
        let ve;
        for (ve = 0; ve < me; ve++)
          ge.push({
            end: G.getUint16()
          });
        for (G.skip(2), ve = 0; ve < me; ve++)
          ge[ve].start = G.getUint16();
        for (ve = 0; ve < me; ve++)
          ge[ve].delta = G.getUint16();
        let Re = 0, ne;
        for (ve = 0; ve < me; ve++) {
          V = ge[ve];
          const Te = G.getUint16();
          if (!Te) {
            V.offsetIndex = -1;
            continue;
          }
          ne = (Te >> 1) - (me - ve), V.offsetIndex = ne, Re = Math.max(Re, ne + V.end - V.start + 1);
        }
        const Fe = [];
        for (ie = 0; ie < Re; ie++)
          Fe.push(G.getUint16());
        for (ve = 0; ve < me; ve++) {
          V = ge[ve], he = V.start;
          const Te = V.end, je = V.delta;
          for (ne = V.offsetIndex, ie = he; ie <= Te; ie++)
            ie !== 65535 && (ue = ne < 0 ? ie : Fe[ne + ie - he], ue = ue + je & 65535, Ae.push({
              charCode: ie,
              glyphId: ue
            }));
        }
      } else if (fe === 6) {
        G.skip(4);
        const me = G.getUint16(), ge = G.getUint16();
        for (ie = 0; ie < ge; ie++) {
          ue = G.getUint16();
          const ve = me + ie;
          Ae.push({
            charCode: ve,
            glyphId: ue
          });
        }
      } else if (fe === 12) {
        G.skip(10);
        const me = G.getInt32() >>> 0;
        for (ie = 0; ie < me; ie++) {
          const ge = G.getInt32() >>> 0, ve = G.getInt32() >>> 0;
          let Re = G.getInt32() >>> 0;
          for (let ne = ge; ne <= ve; ne++)
            Ae.push({
              charCode: ne,
              glyphId: Re++
            });
        }
      } else
        return F("cmap table has unsupported format: " + fe), {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: !1
        };
      Ae.sort((me, ge) => me.charCode - ge.charCode);
      const ce = [], ke = /* @__PURE__ */ new Set();
      for (const me of Ae) {
        const {
          charCode: ge
        } = me;
        ke.has(ge) || (ke.add(ge), ce.push(me));
      }
      return {
        platformId: _.platformId,
        encodingId: _.encodingId,
        mappings: ce,
        hasShortCmap: Ee
      };
    }
    function f(D, G, R, L, V, he) {
      if (!G) {
        R && (R.data = null);
        return;
      }
      D.pos = (D.start || 0) + G.offset, D.pos += 4, D.pos += 2, D.pos += 2, D.pos += 2, D.pos += 2, D.pos += 2, D.pos += 2, D.pos += 2, D.pos += 2, D.pos += 2;
      const te = D.getUint16();
      D.pos += 8, D.pos += 2;
      let _ = D.getUint16();
      te !== 0 && (_a(L.data[44], L.data[45]) & 2 || (G.data[22] = 0, G.data[23] = 0)), _ > V && (Ue(`The numOfMetrics (${_}) should not be greater than the numGlyphs (${V}).`), _ = V, G.data[34] = (_ & 65280) >> 8, G.data[35] = _ & 255);
      const fe = V - _ - (R.length - _ * 4 >> 1);
      if (fe > 0) {
        const Ee = new Uint8Array(R.length + fe * 2);
        Ee.set(R.data), he && (Ee[R.length] = R.data[2], Ee[R.length + 1] = R.data[3]), R.data = Ee;
      }
    }
    function d(D, G, R, L, V, he) {
      const te = {
        length: 0,
        sizeOfInstructions: 0
      };
      if (G < 0 || G >= D.length || R > D.length || R - G <= 12)
        return te;
      const _ = D.subarray(G, R), de = yn(_[2], _[3]), fe = yn(_[4], _[5]), Ee = yn(_[6], _[7]), Ae = yn(_[8], _[9]);
      de > Ee && (es(_, 2, Ee), es(_, 6, de)), fe > Ae && (es(_, 4, Ae), es(_, 8, fe));
      const ie = yn(_[0], _[1]);
      if (ie < 0)
        return ie < -1 || (L.set(_, V), te.length = _.length), te;
      let ue, ce = 10, ke = 0;
      for (ue = 0; ue < ie; ue++)
        ke = (_[ce] << 8 | _[ce + 1]) + 1, ce += 2;
      const me = ce, ge = _[ce] << 8 | _[ce + 1];
      te.sizeOfInstructions = ge, ce += 2 + ge;
      const ve = ce;
      let Re = 0;
      for (ue = 0; ue < ke; ue++) {
        const Fe = _[ce++];
        Fe & 192 && (_[ce - 1] = Fe & 63);
        let Te = 2;
        Fe & 2 ? Te = 1 : Fe & 16 && (Te = 0);
        let je = 2;
        Fe & 4 ? je = 1 : Fe & 32 && (je = 0);
        const De = Te + je;
        if (Re += De, Fe & 8) {
          const yt = _[ce++];
          yt === 0 && (_[ce - 1] ^= 8), ue += yt, Re += yt * De;
        }
      }
      if (Re === 0)
        return te;
      let ne = ce + Re;
      return ne > _.length ? te : !he && ge > 0 ? (L.set(_.subarray(0, me), V), L.set([0, 0], V + me), L.set(_.subarray(ve, ne), V + me + 2), ne -= ge, _.length - ne > 3 && (ne = ne + 3 & -4), te.length = ne, te) : _.length - ne > 3 ? (ne = ne + 3 & -4, L.set(_.subarray(0, ne), V), te.length = ne, te) : (L.set(_, V), te.length = _.length, te);
    }
    function u(D, G, R) {
      const L = D.data, V = Vd(L[0], L[1], L[2], L[3]);
      V >> 16 !== 1 && (Ue("Attempting to fix invalid version in head table: " + V), L[0] = 0, L[1] = 1, L[2] = 0, L[3] = 0);
      const he = _a(L[50], L[51]);
      if (he < 0 || he > 1) {
        Ue("Attempting to fix invalid indexToLocFormat in head table: " + he);
        const te = G + 1;
        if (R === te << 1)
          L[50] = 0, L[51] = 0;
        else if (R === te << 2)
          L[50] = 0, L[51] = 1;
        else
          throw new W("Could not fix indexToLocFormat: " + he);
      }
    }
    function x(D, G, R, L, V, he, te) {
      let _, de, fe;
      L ? (_ = 4, de = function(je, De) {
        return je[De] << 24 | je[De + 1] << 16 | je[De + 2] << 8 | je[De + 3];
      }, fe = function(je, De, yt) {
        je[De] = yt >>> 24 & 255, je[De + 1] = yt >> 16 & 255, je[De + 2] = yt >> 8 & 255, je[De + 3] = yt & 255;
      }) : (_ = 2, de = function(je, De) {
        return je[De] << 9 | je[De + 1] << 1;
      }, fe = function(je, De, yt) {
        je[De] = yt >> 9 & 255, je[De + 1] = yt >> 1 & 255;
      });
      const Ee = he ? R + 1 : R, Ae = _ * (1 + Ee), ie = new Uint8Array(Ae);
      ie.set(D.data.subarray(0, Ae)), D.data = ie;
      const ue = G.data, ce = ue.length, ke = new Uint8Array(ce);
      let me, ge;
      const ve = [];
      for (me = 0, ge = 0; me < R + 1; me++, ge += _) {
        let Te = de(ie, ge);
        Te > ce && (Te = ce), ve.push({
          index: me,
          offset: Te,
          endOffset: 0
        });
      }
      for (ve.sort((Te, je) => Te.offset - je.offset), me = 0; me < R; me++)
        ve[me].endOffset = ve[me + 1].offset;
      for (ve.sort((Te, je) => Te.index - je.index), me = 0; me < R; me++) {
        const {
          offset: Te,
          endOffset: je
        } = ve[me];
        if (Te !== 0 || je !== 0)
          break;
        const De = ve[me + 1].offset;
        if (De !== 0) {
          ve[me].endOffset = De;
          break;
        }
      }
      const Re = ve.at(-2);
      Re.offset !== 0 && Re.endOffset === 0 && (Re.endOffset = ce);
      const ne = /* @__PURE__ */ Object.create(null);
      let Fe = 0;
      for (fe(ie, 0, Fe), me = 0, ge = _; me < R; me++, ge += _) {
        const Te = d(ue, ve[me].offset, ve[me].endOffset, ke, Fe, V), je = Te.length;
        je === 0 && (ne[me] = !0), Te.sizeOfInstructions > te && (te = Te.sizeOfInstructions), Fe += je, fe(ie, ge, Fe);
      }
      if (Fe === 0) {
        const Te = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
        for (me = 0, ge = _; me < Ee; me++, ge += _)
          fe(ie, ge, Te.length);
        G.data = Te;
      } else if (he) {
        const Te = de(ie, _);
        ke.length > Te + Fe ? G.data = ke.subarray(0, Te + Fe) : (G.data = new Uint8Array(Te + Fe), G.data.set(ke.subarray(0, Fe))), G.data.set(ke.subarray(0, Te), Fe), fe(D.data, ie.length - _, Fe + Te);
      } else
        G.data = ke.subarray(0, Fe);
      return {
        missingGlyphs: ne,
        maxSizeOfInstructions: te
      };
    }
    function g(D, G, R) {
      const L = (n.start || 0) + D.offset;
      n.pos = L;
      const V = D.length, he = L + V, te = n.getInt32();
      n.skip(28);
      let _, de = !0, fe;
      switch (te) {
        case 65536:
          _ = Gc;
          break;
        case 131072:
          const Ee = n.getUint16();
          if (Ee !== R) {
            de = !1;
            break;
          }
          const Ae = [];
          for (fe = 0; fe < Ee; ++fe) {
            const ce = n.getUint16();
            if (ce >= 32768) {
              de = !1;
              break;
            }
            Ae.push(ce);
          }
          if (!de)
            break;
          const ie = [], ue = [];
          for (; n.pos < he; ) {
            const ce = n.getByte();
            for (ue.length = ce, fe = 0; fe < ce; ++fe)
              ue[fe] = String.fromCharCode(n.getByte());
            ie.push(ue.join(""));
          }
          for (_ = [], fe = 0; fe < Ee; ++fe) {
            const ce = Ae[fe];
            if (ce < 258) {
              _.push(Gc[ce]);
              continue;
            }
            _.push(ie[ce - 258]);
          }
          break;
        case 196608:
          break;
        default:
          F("Unknown/unsupported post table version " + te), de = !1, G.defaultEncoding && (_ = G.defaultEncoding);
          break;
      }
      return G.glyphNames = _, de;
    }
    function p(D) {
      const G = (n.start || 0) + D.offset;
      n.pos = G;
      const R = [[], []], L = [], V = D.length, he = G + V;
      if (n.getUint16() !== 0 || V < 6)
        return [R, L];
      const de = n.getUint16(), fe = n.getUint16(), Ee = 12;
      let Ae, ie;
      for (Ae = 0; Ae < de && n.pos + Ee <= he; Ae++) {
        const ue = {
          platform: n.getUint16(),
          encoding: n.getUint16(),
          language: n.getUint16(),
          name: n.getUint16(),
          length: n.getUint16(),
          offset: n.getUint16()
        };
        (Zd(ue) || U1(ue)) && L.push(ue);
      }
      for (Ae = 0, ie = L.length; Ae < ie; Ae++) {
        const ue = L[Ae];
        if (ue.length <= 0)
          continue;
        const ce = G + fe + ue.offset;
        if (ce + ue.length > he)
          continue;
        n.pos = ce;
        const ke = ue.name;
        if (ue.encoding) {
          let me = "";
          for (let ge = 0, ve = ue.length; ge < ve; ge += 2)
            me += String.fromCharCode(n.getUint16());
          R[1][ke] = me;
        } else
          R[0][ke] = n.getString(ue.length);
      }
      return [R, L];
    }
    const m = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function b(D, G) {
      let R = D.data, L = 0, V, he, te, _, de, fe = 0, Ee = 0;
      const Ae = [], ie = [], ue = [];
      let ce = G.tooComplexToFollowFunctions, ke = !1, me = 0, ge = 0;
      for (let Re = R.length; L < Re; ) {
        const ne = R[L++];
        if (ne === 64)
          if (he = R[L++], ke || ge)
            L += he;
          else
            for (V = 0; V < he; V++)
              Ae.push(R[L++]);
        else if (ne === 65)
          if (he = R[L++], ke || ge)
            L += he * 2;
          else
            for (V = 0; V < he; V++)
              te = R[L++], Ae.push(te << 8 | R[L++]);
        else if ((ne & 248) === 176)
          if (he = ne - 176 + 1, ke || ge)
            L += he;
          else
            for (V = 0; V < he; V++)
              Ae.push(R[L++]);
        else if ((ne & 248) === 184)
          if (he = ne - 184 + 1, ke || ge)
            L += he * 2;
          else
            for (V = 0; V < he; V++)
              te = R[L++], Ae.push(yn(te, R[L++]));
        else if (ne === 43 && !ce) {
          if (!ke && !ge) {
            if (_ = Ae.at(-1), isNaN(_))
              Ue("TT: CALL empty stack (or invalid entry).");
            else if (G.functionsUsed[_] = !0, _ in G.functionsStackDeltas) {
              const Fe = Ae.length + G.functionsStackDeltas[_];
              if (Fe < 0) {
                F("TT: CALL invalid functions stack delta."), G.hintsValid = !1;
                return;
              }
              Ae.length = Fe;
            } else if (_ in G.functionsDefined && !ue.includes(_)) {
              if (ie.push({
                data: R,
                i: L,
                stackTop: Ae.length - 1
              }), ue.push(_), de = G.functionsDefined[_], !de) {
                F("TT: CALL non-existent function"), G.hintsValid = !1;
                return;
              }
              R = de.data, L = de.i;
            }
          }
        } else if (ne === 44 && !ce)
          (ke || ge) && (F("TT: nested FDEFs not allowed"), ce = !0), ke = !0, Ee = L, _ = Ae.pop(), G.functionsDefined[_] = {
            data: R,
            i: L
          };
        else if (ne === 45)
          if (ke)
            ke = !1, fe = L;
          else {
            if (de = ie.pop(), !de) {
              F("TT: ENDF bad stack"), G.hintsValid = !1;
              return;
            }
            _ = ue.pop(), R = de.data, L = de.i, G.functionsStackDeltas[_] = Ae.length - de.stackTop;
          }
        else if (ne === 137)
          (ke || ge) && (F("TT: nested IDEFs not allowed"), ce = !0), ke = !0, Ee = L;
        else if (ne === 88)
          ++me;
        else if (ne === 27)
          ge = me;
        else if (ne === 89)
          ge === me && (ge = 0), --me;
        else if (ne === 28 && !ke && !ge) {
          const Fe = Ae.at(-1);
          Fe > 0 && (L += Fe - 1);
        }
        if (!ke && !ge) {
          let Fe = 0;
          for (ne <= 142 ? Fe = m[ne] : ne >= 192 && ne <= 223 ? Fe = -1 : ne >= 224 && (Fe = -2), ne >= 113 && ne <= 117 && (he = Ae.pop(), isNaN(he) || (Fe = -he * 2)); Fe < 0 && Ae.length > 0; )
            Ae.pop(), Fe++;
          for (; Fe > 0; )
            Ae.push(NaN), Fe--;
        }
      }
      G.tooComplexToFollowFunctions = ce;
      const ve = [R];
      L > R.length && ve.push(new Uint8Array(L - R.length)), Ee > fe && (F("TT: complementing a missing function tail"), ve.push(new Uint8Array([34, 45]))), w(D, ve);
    }
    function y(D, G) {
      if (!D.tooComplexToFollowFunctions) {
        if (D.functionsDefined.length > G) {
          F("TT: more functions defined than expected"), D.hintsValid = !1;
          return;
        }
        for (let R = 0, L = D.functionsUsed.length; R < L; R++) {
          if (R > G) {
            F("TT: invalid function id: " + R), D.hintsValid = !1;
            return;
          }
          if (D.functionsUsed[R] && !D.functionsDefined[R]) {
            F("TT: undefined function: " + R), D.hintsValid = !1;
            return;
          }
        }
      }
    }
    function w(D, G) {
      if (G.length > 1) {
        let R = 0, L, V;
        for (L = 0, V = G.length; L < V; L++)
          R += G[L].length;
        R = R + 3 & -4;
        const he = new Uint8Array(R);
        let te = 0;
        for (L = 0, V = G.length; L < V; L++)
          he.set(G[L], te), te += G[L].length;
        D.data = he, D.length = R;
      }
    }
    function S(D, G, R, L) {
      const V = {
        functionsDefined: [],
        functionsUsed: [],
        functionsStackDeltas: [],
        tooComplexToFollowFunctions: !1,
        hintsValid: !0
      };
      if (D && b(D, V), G && b(G, V), D && y(V, L), R && R.length & 1) {
        const he = new Uint8Array(R.length + 1);
        he.set(R.data), R.data = he;
      }
      return V.hintsValid;
    }
    n = new pt(new Uint8Array(n.getBytes()));
    let v, k;
    if (L1(n)) {
      const D = l(n, this.name);
      v = D.header, k = D.tables;
    } else
      v = o(n), k = s(n, v.numTables);
    let A, C;
    const T = !k["CFF "];
    if (T) {
      if (!k.loca)
        throw new W('Required "loca" table is not found');
      k.glyf || (F('Required "glyf" table is not found -- trying to recover.'), k.glyf = {
        tag: "glyf",
        data: new Uint8Array(0)
      }), this.isOpenType = !1;
    } else {
      const D = a.composite && (a.cidToGidMap?.length > 0 || !(a.cMap instanceof Bi));
      if (v.version === "OTTO" && !D || !k.head || !k.hhea || !k.maxp || !k.post)
        return C = new pt(k["CFF "].data), A = new F0(C, a), this.convert(e, A, a);
      delete k.glyf, delete k.loca, delete k.fpgm, delete k.prep, delete k["cvt "], this.isOpenType = !0;
    }
    if (!k.maxp)
      throw new W('Required "maxp" table is not found');
    n.pos = (n.start || 0) + k.maxp.offset;
    let M = n.getInt32();
    const O = n.getUint16();
    if (M !== 65536 && M !== 20480) {
      if (k.maxp.length === 6)
        M = 20480;
      else if (k.maxp.length >= 32)
        M = 65536;
      else
        throw new W('"maxp" table has a wrong version number');
      Wd(k.maxp.data, 0, M);
    }
    if (a.scaleFactors?.length === O && T) {
      const {
        scaleFactors: D
      } = a, G = _a(k.head.data[50], k.head.data[51]), R = new Rd({
        glyfTable: k.glyf.data,
        isGlyphLocationsLong: G,
        locaTable: k.loca.data,
        numGlyphs: O
      });
      R.scale(D);
      const {
        glyf: L,
        loca: V,
        isLocationLong: he
      } = R.write();
      k.glyf.data = L, k.loca.data = V, he !== !!G && (k.head.data[50] = 0, k.head.data[51] = he ? 1 : 0);
      const te = k.hmtx.data;
      for (let _ = 0; _ < O; _++) {
        const de = 4 * _, fe = Math.round(D[_] * _a(te[de], te[de + 1]));
        te[de] = fe >> 8 & 255, te[de + 1] = fe & 255;
        const Ee = Math.round(D[_] * yn(te[de + 2], te[de + 3]));
        es(te, de + 2, Ee);
      }
    }
    let N = O + 1, H = !0;
    N > 65535 && (H = !1, N = O, F("Not enough space in glyfs to duplicate first glyph."));
    let J = 0, U = 0;
    M >= 65536 && k.maxp.length >= 32 && (n.pos += 8, n.getUint16() > 2 && (k.maxp.data[14] = 0, k.maxp.data[15] = 2), n.pos += 4, J = n.getUint16(), n.pos += 4, U = n.getUint16()), k.maxp.data[4] = N >> 8, k.maxp.data[5] = N & 255;
    const j = S(k.fpgm, k.prep, k["cvt "], J);
    if (j || (delete k.fpgm, delete k.prep, delete k["cvt "]), f(n, k.hhea, k.hmtx, k.head, N, H), !k.head)
      throw new W('Required "head" table is not found');
    u(k.head, O, T ? k.loca.length : 0);
    let P = /* @__PURE__ */ Object.create(null);
    if (T) {
      const D = _a(k.head.data[50], k.head.data[51]), G = x(k.loca, k.glyf, O, D, j, H, U);
      P = G.missingGlyphs, M >= 65536 && k.maxp.length >= 32 && (k.maxp.data[26] = G.maxSizeOfInstructions >> 8, k.maxp.data[27] = G.maxSizeOfInstructions & 255);
    }
    if (!k.hhea)
      throw new W('Required "hhea" table is not found');
    k.hhea.data[10] === 0 && k.hhea.data[11] === 0 && (k.hhea.data[10] = 255, k.hhea.data[11] = 255);
    const K = {
      unitsPerEm: _a(k.head.data[18], k.head.data[19]),
      yMax: yn(k.head.data[42], k.head.data[43]),
      yMin: yn(k.head.data[38], k.head.data[39]),
      ascent: yn(k.hhea.data[4], k.hhea.data[5]),
      descent: yn(k.hhea.data[6], k.hhea.data[7]),
      lineGap: yn(k.hhea.data[8], k.hhea.data[9])
    };
    this.ascent = K.ascent / K.unitsPerEm, this.descent = K.descent / K.unitsPerEm, this.lineGap = K.lineGap / K.unitsPerEm, this.cssFontInfo?.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, k.post && g(k.post, a, O), k.post = {
      tag: "post",
      data: cl(a)
    };
    const xe = /* @__PURE__ */ Object.create(null);
    function X(D) {
      return !P[D];
    }
    if (a.composite) {
      const D = a.cidToGidMap || [], G = D.length === 0;
      a.cMap.forEach(function(R, L) {
        if (typeof L == "string" && (L = M0(R, L, !0)), L > 65535)
          throw new W("Max size of CID is 65,535");
        let V = -1;
        G ? V = L : D[L] !== void 0 && (V = D[L]), V >= 0 && V < O && X(V) && (xe[R] = V);
      });
    } else {
      const D = h(k.cmap, n, this.isSymbolicFont, a.hasEncoding), G = D.platformId, R = D.encodingId, L = D.mappings;
      let V = [], he = !1;
      if (a.hasEncoding && (a.baseEncodingName === "MacRomanEncoding" || a.baseEncodingName === "WinAnsiEncoding") && (V = Ms(a.baseEncodingName)), a.hasEncoding && !this.isSymbolicFont && (G === 3 && R === 1 || G === 1 && R === 0)) {
        const te = Qn();
        for (let _ = 0; _ < 256; _++) {
          let de;
          if (this.differences[_] !== void 0 ? de = this.differences[_] : V.length && V[_] !== "" ? de = V[_] : de = xa[_], !de)
            continue;
          const fe = R1(de, te);
          let Ee;
          if (G === 3 && R === 1 ? Ee = te[fe] : G === 1 && R === 0 && (Ee = jo.indexOf(fe)), Ee === void 0) {
            if (!a.glyphNames && a.hasIncludedToUnicodeMap && !(this.toUnicode instanceof On)) {
              const Ae = this.toUnicode.get(_);
              Ae && (Ee = Ae.codePointAt(0));
            }
            if (Ee === void 0)
              continue;
          }
          for (const Ae of L)
            if (Ae.charCode === Ee) {
              xe[_] = Ae.glyphId;
              break;
            }
        }
      } else if (G === 0) {
        for (const te of L)
          xe[te.charCode] = te.glyphId;
        he = !0;
      } else if (G === 3 && R === 0)
        for (const te of L) {
          let _ = te.charCode;
          _ >= 61440 && _ <= 61695 && (_ &= 255), xe[_] = te.glyphId;
        }
      else
        for (const te of L)
          xe[te.charCode] = te.glyphId;
      if (a.glyphNames && (V.length || this.differences.length))
        for (let te = 0; te < 256; ++te) {
          if (!he && xe[te] !== void 0)
            continue;
          const _ = this.differences[te] || V[te];
          if (!_)
            continue;
          const de = a.glyphNames.indexOf(_);
          de > 0 && X(de) && (xe[te] = de);
        }
    }
    xe.length === 0 && (xe[0] = 0);
    let ye = N - 1;
    if (H || (ye = 0), !a.cssFontInfo) {
      const D = sl(xe, X, ye, this.toUnicode);
      this.toFontChar = D.toFontChar, k.cmap = {
        tag: "cmap",
        data: rl(D.charCodeToGlyphId, D.toUnicodeExtraMap, N)
      }, (!k["OS/2"] || !e2(k["OS/2"], n)) && (k["OS/2"] = {
        tag: "OS/2",
        data: ol(a, D.charCodeToGlyphId, K)
      });
    }
    if (!T)
      try {
        C = new pt(k["CFF "].data), A = new Go(C, a, Mi).parse(), A.duplicateFirstGlyph();
        const G = new Xs(A);
        k["CFF "].data = G.compile();
      } catch {
        F("Failed to compile font " + a.loadedName);
      }
    if (!k.name)
      k.name = {
        tag: "name",
        data: P0(this.name)
      };
    else {
      const [D, G] = p(k.name);
      k.name.data = P0(e, D), this.psName = D[0][6] || null, a.composite || Gd(a, this.isSymbolicFont, G);
    }
    const we = new Us(v.version);
    for (const D in k)
      we.addTable(D, k[D].data);
    return we.toArray();
  }
  convert(e, n, a) {
    a.fixedPitch = !1, a.builtInEncoding && zd(a, a.builtInEncoding);
    let i = 1;
    n instanceof F0 && (i = n.numGlyphs - 1);
    const s = n.getGlyphMapping(a);
    let r = null, o = s, c = null;
    a.cssFontInfo || (r = sl(s, n.hasGlyphId.bind(n), i, this.toUnicode), this.toFontChar = r.toFontChar, o = r.charCodeToGlyphId, c = r.toUnicodeExtraMap);
    const l = n.numGlyphs;
    function h(g, p) {
      let m = null;
      for (const b in g)
        p === g[b] && (m ||= []).push(b | 0);
      return m;
    }
    function f(g, p) {
      for (const m in g)
        if (p === g[m])
          return m | 0;
      return r.charCodeToGlyphId[r.nextAvailableFontCharCode] = p, r.nextAvailableFontCharCode++;
    }
    const d = n.seacs;
    if (r && Mi && d?.length) {
      const g = a.fontMatrix || ti, p = n.getCharset(), m = /* @__PURE__ */ Object.create(null);
      for (let b in d) {
        b |= 0;
        const y = d[b], w = xa[y[2]], S = xa[y[3]], v = p.indexOf(w), k = p.indexOf(S);
        if (v < 0 || k < 0)
          continue;
        const A = {
          x: y[0] * g[0] + y[1] * g[2] + g[4],
          y: y[0] * g[1] + y[1] * g[3] + g[5]
        }, C = h(s, b);
        if (C)
          for (const T of C) {
            const M = r.charCodeToGlyphId, O = f(M, v), N = f(M, k);
            m[T] = {
              baseFontCharCode: O,
              accentFontCharCode: N,
              accentOffset: A
            };
          }
      }
      a.seacMap = m;
    }
    const u = a.fontMatrix ? 1 / Math.max(...a.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, x = new Us("OTTO");
    return x.addTable("CFF ", n.data), x.addTable("OS/2", ol(a, o)), x.addTable("cmap", rl(o, c, l)), x.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\0\0" + Wa(u) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + Wa(a.descent) + "" + Wa(a.ascent) + Qe(a.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), x.addTable("hhea", "\0\0\0" + Wa(a.ascent) + Wa(a.descent) + "\0\0\0\0\0\0\0\0" + Wa(a.capHeight) + Wa(Math.tan(a.italicAngle) * a.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + Qe(l)), x.addTable("hmtx", (function() {
      const p = n.charstrings, m = n.cff ? n.cff.widths : null;
      let b = "\0\0\0\0";
      for (let y = 1, w = l; y < w; y++) {
        let S = 0;
        if (p) {
          const v = p[y - 1];
          S = "width" in v ? v.width : 0;
        } else m && (S = Math.ceil(m[y] || 0));
        b += Qe(S) + Qe(0);
      }
      return b;
    })()), x.addTable("maxp", "\0\0P\0" + Qe(l)), x.addTable("name", P0(e)), x.addTable("post", cl(a)), x.toArray();
  }
  get _spaceWidth() {
    const e = ["space", "minus", "one", "i", "I"];
    let n;
    for (const a of e) {
      if (a in this.widths) {
        n = this.widths[a];
        break;
      }
      const s = Qn()[a];
      let r = 0;
      if (this.composite && this.cMap.contains(s) && (r = this.cMap.lookup(s), typeof r == "string" && (r = M0(s, r))), !r && this.toUnicode && (r = this.toUnicode.charCodeOf(s)), r <= 0 && (r = s), n = this.widths[r], n)
        break;
    }
    return ae(this, "_spaceWidth", n || this.defaultWidth);
  }
  _charToGlyph(e, n = !1) {
    let a = this._glyphCache[e];
    if (a?.isSpace === n)
      return a;
    let i, s, r, o = e;
    this.cMap?.contains(e) && (o = this.cMap.lookup(e), typeof o == "string" && (o = M0(e, o))), s = this.widths[o], typeof s != "number" && (s = this.defaultWidth);
    const c = this.vmetrics?.[o];
    let l = this.toUnicode.get(e) || e;
    typeof l == "number" && (l = String.fromCharCode(l));
    let h = this.toFontChar[e] !== void 0;
    if (i = this.toFontChar[e] || e, this.missingFile) {
      const u = this.differences[e] || this.defaultEncoding[e];
      (u === ".notdef" || u === "") && this.type === "Type1" && (i = 32, u === "" && (s ||= this._spaceWidth, l = String.fromCharCode(i))), i = Yu(i);
    }
    this.isType3Font && (r = i);
    let f = null;
    if (this.seacMap?.[e]) {
      h = !0;
      const u = this.seacMap[e];
      i = u.baseFontCharCode, f = {
        fontChar: String.fromCodePoint(u.accentFontCharCode),
        offset: u.accentOffset
      };
    }
    let d = "";
    if (typeof i == "number" && (i <= 1114111 ? d = String.fromCodePoint(i) : F(`charToGlyph - invalid fontCharCode: ${i}`)), this.missingFile && this.vertical && d.length === 1) {
      const u = td()[d.charCodeAt(0)];
      u && (d = l = String.fromCharCode(u));
    }
    return a = new _d(e, d, l, f, s, c, r, n, h), this._glyphCache[e] = a;
  }
  charsToGlyphs(e) {
    let n = this._charsCache[e];
    if (n)
      return n;
    if (n = [], this.cMap) {
      const a = /* @__PURE__ */ Object.create(null), i = e.length;
      let s = 0;
      for (; s < i; ) {
        this.cMap.readCharCode(e, s, a);
        const {
          charcode: r,
          length: o
        } = a;
        s += o;
        const c = this._charToGlyph(r, o === 1 && e.charCodeAt(s - 1) === 32);
        n.push(c);
      }
    } else
      for (let a = 0, i = e.length; a < i; ++a) {
        const s = e.charCodeAt(a), r = this._charToGlyph(s, s === 32);
        n.push(r);
      }
    return this._charsCache[e] = n;
  }
  getCharPositions(e) {
    const n = [];
    if (this.cMap) {
      const a = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < e.length; ) {
        this.cMap.readCharCode(e, i, a);
        const s = a.length;
        n.push([i, i + s]), i += s;
      }
    } else
      for (let a = 0, i = e.length; a < i; ++a)
        n.push([a, a + 1]);
    return n;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(e) {
    const n = [], a = [], i = () => n.length % 2 === 1, s = this.toUnicode instanceof On ? (r) => this.toUnicode.charCodeOf(r) : (r) => this.toUnicode.charCodeOf(String.fromCodePoint(r));
    for (let r = 0, o = e.length; r < o; r++) {
      const c = e.codePointAt(r);
      if (c > 55295 && (c < 57344 || c > 65533) && r++, this.toUnicode) {
        const l = s(c);
        if (l !== -1) {
          i() && (n.push(a.join("")), a.length = 0);
          const h = this.cMap ? this.cMap.getCharCodeLength(l) : 1;
          for (let f = h - 1; f >= 0; f--)
            a.push(String.fromCharCode(l >> 8 * f & 255));
          continue;
        }
      }
      i() || (n.push(a.join("")), a.length = 0), a.push(String.fromCodePoint(c));
    }
    return n.push(a.join("")), n;
  }
}
class hl {
  constructor(e) {
    this.error = e, this.loadedName = "g_font_error", this.missingFile = !0;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(e) {
    return [e];
  }
  exportData() {
    return {
      error: this.error
    };
  }
}
const nn = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};
class n2 {
  constructor() {
    _e("Cannot initialize Pattern.");
  }
  static parseShading(e, n, a, i, s, r) {
    const o = e instanceof Ne ? e.dict : e, c = o.get("ShadingType");
    try {
      switch (c) {
        case nn.AXIAL:
        case nn.RADIAL:
          return new a2(o, n, a, i, s, r);
        case nn.FREE_FORM_MESH:
        case nn.LATTICE_FORM_MESH:
        case nn.COONS_PATCH_MESH:
        case nn.TENSOR_PATCH_MESH:
          return new Aa(e, n, a, i, s, r);
        default:
          throw new W("Unsupported ShadingType: " + c);
      }
    } catch (l) {
      if (l instanceof ht)
        throw l;
      return F(l), new o2();
    }
  }
}
class bs {
  static SMALL_NUMBER = 1e-6;
  getIR() {
    _e("Abstract method `getIR` called.");
  }
}
class a2 extends bs {
  constructor(e, n, a, i, s, r) {
    super(), this.shadingType = e.get("ShadingType");
    let o = 0;
    if (this.shadingType === nn.AXIAL ? o = 4 : this.shadingType === nn.RADIAL && (o = 6), this.coordsArr = e.getArray("Coords"), !an(this.coordsArr, o))
      throw new W("RadialAxialShading: Invalid /Coords array.");
    const c = Ye.parse({
      cs: e.getRaw("CS") || e.getRaw("ColorSpace"),
      xref: n,
      resources: a,
      pdfFunctionFactory: i,
      globalColorSpaceCache: s,
      localColorSpaceCache: r
    });
    this.bbox = ma(e.getArray("BBox"), null);
    let l = 0, h = 1;
    const f = e.getArray("Domain");
    an(f, 2) && ([l, h] = f);
    let d = !1, u = !1;
    const x = e.getArray("Extend");
    if (ff(x, 2) && ([d, u] = x), this.shadingType === nn.RADIAL && (!d || !u)) {
      const [ye, we, D, G, R, L] = this.coordsArr, V = Math.hypot(ye - G, we - R);
      D <= L + V && L <= D + V && F("Unsupported radial gradient.");
    }
    this.extendStart = d, this.extendEnd = u;
    const g = e.getRaw("Function"), p = i.create(g, !0), m = 840, b = (h - l) / m, y = this.colorStops = [];
    if (l >= h || b <= 0) {
      Ue("Bad shading domain.");
      return;
    }
    const w = new Float32Array(c.numComps), S = new Float32Array(1);
    let v = 0;
    S[0] = l, p(S, 0, w, 0);
    const k = new Uint8ClampedArray(3);
    c.getRgb(w, 0, k);
    let [A, C, T] = k;
    y.push([0, Je.makeHexColor(A, C, T)]);
    let M = 1;
    S[0] = l + b, p(S, 0, w, 0), c.getRgb(w, 0, k);
    let [O, N, H] = k, J = O - A + 1, U = N - C + 1, j = H - T + 1, P = O - A - 1, K = N - C - 1, xe = H - T - 1;
    for (let ye = 2; ye < m; ye++) {
      S[0] = l + ye * b, p(S, 0, w, 0), c.getRgb(w, 0, k);
      const [we, D, G] = k, R = ye - v;
      if (J = Math.min(J, (we - A + 1) / R), U = Math.min(U, (D - C + 1) / R), j = Math.min(j, (G - T + 1) / R), P = Math.max(P, (we - A - 1) / R), K = Math.max(K, (D - C - 1) / R), xe = Math.max(xe, (G - T - 1) / R), !(P <= J && K <= U && xe <= j)) {
        const V = Je.makeHexColor(O, N, H);
        y.push([M / m, V]), J = we - O + 1, U = D - N + 1, j = G - H + 1, P = we - O - 1, K = D - N - 1, xe = G - H - 1, v = M, A = O, C = N, T = H;
      }
      M = ye, O = we, N = D, H = G;
    }
    y.push([1, Je.makeHexColor(O, N, H)]);
    let X = "transparent";
    e.has("Background") && (X = c.getRgbHex(e.get("Background"), 0)), d || (y.unshift([0, X]), y[1][0] += bs.SMALL_NUMBER), u || (y.at(-1)[0] -= bs.SMALL_NUMBER, y.push([1, X])), this.colorStops = y;
  }
  getIR() {
    const {
      coordsArr: e,
      shadingType: n
    } = this;
    let a, i, s, r, o;
    return n === nn.AXIAL ? (i = [e[0], e[1]], s = [e[2], e[3]], r = null, o = null, a = "axial") : n === nn.RADIAL ? (i = [e[0], e[1]], s = [e[3], e[4]], r = e[2], o = e[5], a = "radial") : _e(`getPattern type unknown: ${n}`), ["RadialAxial", a, this.bbox, this.colorStops, i, s, r, o];
  }
}
class i2 {
  constructor(e, n) {
    this.stream = e, this.context = n, this.buffer = 0, this.bufferLength = 0;
    const a = n.numComps;
    this.tmpCompsBuf = new Float32Array(a);
    const i = n.colorSpace.numComps;
    this.tmpCsCompsBuf = n.colorFn ? new Float32Array(i) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end)
      return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0)
      return !0;
    const e = this.stream.getByte();
    return e < 0 ? !1 : (this.buffer = e, this.bufferLength = 8, !0);
  }
  readBits(e) {
    const {
      stream: n
    } = this;
    let {
      buffer: a,
      bufferLength: i
    } = this;
    if (e === 32) {
      if (i === 0)
        return n.getInt32() >>> 0;
      a = a << 24 | n.getByte() << 16 | n.getByte() << 8 | n.getByte();
      const s = n.getByte();
      return this.buffer = s & (1 << i) - 1, (a << 8 - i | (s & 255) >> i) >>> 0;
    }
    if (e === 8 && i === 0)
      return n.getByte();
    for (; i < e; )
      a = a << 8 | n.getByte(), i += 8;
    return i -= e, this.bufferLength = i, this.buffer = a & (1 << i) - 1, a >> i;
  }
  align() {
    this.buffer = 0, this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const {
      bitsPerCoordinate: e,
      decode: n
    } = this.context, a = this.readBits(e), i = this.readBits(e), s = e < 32 ? 1 / ((1 << e) - 1) : 23283064365386963e-26;
    return [a * s * (n[1] - n[0]) + n[0], i * s * (n[3] - n[2]) + n[2]];
  }
  readComponents() {
    const {
      bitsPerComponent: e,
      colorFn: n,
      colorSpace: a,
      decode: i,
      numComps: s
    } = this.context, r = e < 32 ? 1 / ((1 << e) - 1) : 23283064365386963e-26, o = this.tmpCompsBuf;
    for (let l = 0, h = 4; l < s; l++, h += 2) {
      const f = this.readBits(e);
      o[l] = f * r * (i[h + 1] - i[h]) + i[h];
    }
    const c = this.tmpCsCompsBuf;
    return n?.(o, 0, c, 0), a.getRgb(c, 0);
  }
}
let j1 = /* @__PURE__ */ Object.create(null);
function s2(t) {
  const e = [];
  for (let n = 0; n <= t; n++) {
    const a = n / t, i = 1 - a;
    e.push(new Float32Array([i ** 3, 3 * a * i ** 2, 3 * a ** 2 * i, a ** 3]));
  }
  return e;
}
function fl(t) {
  return j1[t] ||= s2(t);
}
function r2() {
  j1 = /* @__PURE__ */ Object.create(null);
}
class Aa extends bs {
  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  static TRIANGLE_DENSITY = 20;
  constructor(e, n, a, i, s, r) {
    if (super(), !(e instanceof Ne))
      throw new W("Mesh data is not a stream");
    const o = e.dict;
    this.shadingType = o.get("ShadingType"), this.bbox = ma(o.getArray("BBox"), null);
    const c = Ye.parse({
      cs: o.getRaw("CS") || o.getRaw("ColorSpace"),
      xref: n,
      resources: a,
      pdfFunctionFactory: i,
      globalColorSpaceCache: s,
      localColorSpaceCache: r
    });
    this.background = o.has("Background") ? c.getRgb(o.get("Background"), 0) : null;
    const l = o.getRaw("Function"), h = l ? i.create(l, !0) : null;
    this.coords = [], this.colors = [], this.figures = [];
    const f = {
      bitsPerCoordinate: o.get("BitsPerCoordinate"),
      bitsPerComponent: o.get("BitsPerComponent"),
      bitsPerFlag: o.get("BitsPerFlag"),
      decode: o.getArray("Decode"),
      colorFn: h,
      colorSpace: c,
      numComps: h ? 1 : c.numComps
    }, d = new i2(e, f);
    let u = !1;
    switch (this.shadingType) {
      case nn.FREE_FORM_MESH:
        this._decodeType4Shading(d);
        break;
      case nn.LATTICE_FORM_MESH:
        const x = o.get("VerticesPerRow") | 0;
        if (x < 2)
          throw new W("Invalid VerticesPerRow");
        this._decodeType5Shading(d, x);
        break;
      case nn.COONS_PATCH_MESH:
        this._decodeType6Shading(d), u = !0;
        break;
      case nn.TENSOR_PATCH_MESH:
        this._decodeType7Shading(d), u = !0;
        break;
      default:
        _e("Unsupported mesh type.");
        break;
    }
    if (u) {
      this._updateBounds();
      for (let x = 0, g = this.figures.length; x < g; x++)
        this._buildFigureFromPatch(x);
    }
    this._updateBounds(), this._packData();
  }
  _decodeType4Shading(e) {
    const n = this.coords, a = this.colors, i = [];
    let s = 0;
    for (; e.hasData; ) {
      const r = e.readFlag(), o = e.readCoordinate(), c = e.readComponents();
      if (s === 0) {
        if (!(0 <= r && r <= 2))
          throw new W("Unknown type4 flag");
        switch (r) {
          case 0:
            s = 3;
            break;
          case 1:
            i.push(i.at(-2), i.at(-1)), s = 1;
            break;
          case 2:
            i.push(i.at(-3), i.at(-1)), s = 1;
            break;
        }
      }
      i.push(n.length), n.push(o), a.push(c), s--, e.align();
    }
    this.figures.push({
      type: "triangles",
      coords: new Int32Array(i),
      colors: new Int32Array(i)
    });
  }
  _decodeType5Shading(e, n) {
    const a = this.coords, i = this.colors, s = [];
    for (; e.hasData; ) {
      const r = e.readCoordinate(), o = e.readComponents();
      s.push(a.length), a.push(r), i.push(o);
    }
    this.figures.push({
      type: "lattice",
      coords: new Int32Array(s),
      colors: new Int32Array(s),
      verticesPerRow: n
    });
  }
  _decodeType6Shading(e) {
    const n = this.coords, a = this.colors, i = new Int32Array(16), s = new Int32Array(4);
    for (; e.hasData; ) {
      const r = e.readFlag();
      if (!(0 <= r && r <= 3))
        throw new W("Unknown type6 flag");
      const o = n.length;
      for (let u = 0, x = r !== 0 ? 8 : 12; u < x; u++)
        n.push(e.readCoordinate());
      const c = a.length;
      for (let u = 0, x = r !== 0 ? 2 : 4; u < x; u++)
        a.push(e.readComponents());
      let l, h, f, d;
      switch (r) {
        case 0:
          i[12] = o + 3, i[13] = o + 4, i[14] = o + 5, i[15] = o + 6, i[8] = o + 2, i[11] = o + 7, i[4] = o + 1, i[7] = o + 8, i[0] = o, i[1] = o + 11, i[2] = o + 10, i[3] = o + 9, s[2] = c + 1, s[3] = c + 2, s[0] = c, s[1] = c + 3;
          break;
        case 1:
          l = i[12], h = i[13], f = i[14], d = i[15], i[12] = d, i[13] = o + 0, i[14] = o + 1, i[15] = o + 2, i[8] = f, i[11] = o + 3, i[4] = h, i[7] = o + 4, i[0] = l, i[1] = o + 7, i[2] = o + 6, i[3] = o + 5, l = s[2], h = s[3], s[2] = h, s[3] = c, s[0] = l, s[1] = c + 1;
          break;
        case 2:
          l = i[15], h = i[11], i[12] = i[3], i[13] = o + 0, i[14] = o + 1, i[15] = o + 2, i[8] = i[7], i[11] = o + 3, i[4] = h, i[7] = o + 4, i[0] = l, i[1] = o + 7, i[2] = o + 6, i[3] = o + 5, l = s[3], s[2] = s[1], s[3] = c, s[0] = l, s[1] = c + 1;
          break;
        case 3:
          i[12] = i[0], i[13] = o + 0, i[14] = o + 1, i[15] = o + 2, i[8] = i[1], i[11] = o + 3, i[4] = i[2], i[7] = o + 4, i[0] = i[3], i[1] = o + 7, i[2] = o + 6, i[3] = o + 5, s[2] = s[0], s[3] = c, s[0] = s[1], s[1] = c + 1;
          break;
      }
      i[5] = n.length, n.push([(-4 * n[i[0]][0] - n[i[15]][0] + 6 * (n[i[4]][0] + n[i[1]][0]) - 2 * (n[i[12]][0] + n[i[3]][0]) + 3 * (n[i[13]][0] + n[i[7]][0])) / 9, (-4 * n[i[0]][1] - n[i[15]][1] + 6 * (n[i[4]][1] + n[i[1]][1]) - 2 * (n[i[12]][1] + n[i[3]][1]) + 3 * (n[i[13]][1] + n[i[7]][1])) / 9]), i[6] = n.length, n.push([(-4 * n[i[3]][0] - n[i[12]][0] + 6 * (n[i[2]][0] + n[i[7]][0]) - 2 * (n[i[0]][0] + n[i[15]][0]) + 3 * (n[i[4]][0] + n[i[14]][0])) / 9, (-4 * n[i[3]][1] - n[i[12]][1] + 6 * (n[i[2]][1] + n[i[7]][1]) - 2 * (n[i[0]][1] + n[i[15]][1]) + 3 * (n[i[4]][1] + n[i[14]][1])) / 9]), i[9] = n.length, n.push([(-4 * n[i[12]][0] - n[i[3]][0] + 6 * (n[i[8]][0] + n[i[13]][0]) - 2 * (n[i[0]][0] + n[i[15]][0]) + 3 * (n[i[11]][0] + n[i[1]][0])) / 9, (-4 * n[i[12]][1] - n[i[3]][1] + 6 * (n[i[8]][1] + n[i[13]][1]) - 2 * (n[i[0]][1] + n[i[15]][1]) + 3 * (n[i[11]][1] + n[i[1]][1])) / 9]), i[10] = n.length, n.push([(-4 * n[i[15]][0] - n[i[0]][0] + 6 * (n[i[11]][0] + n[i[14]][0]) - 2 * (n[i[12]][0] + n[i[3]][0]) + 3 * (n[i[2]][0] + n[i[8]][0])) / 9, (-4 * n[i[15]][1] - n[i[0]][1] + 6 * (n[i[11]][1] + n[i[14]][1]) - 2 * (n[i[12]][1] + n[i[3]][1]) + 3 * (n[i[2]][1] + n[i[8]][1])) / 9]), this.figures.push({
        type: "patch",
        coords: new Int32Array(i),
        colors: new Int32Array(s)
      });
    }
  }
  _decodeType7Shading(e) {
    const n = this.coords, a = this.colors, i = new Int32Array(16), s = new Int32Array(4);
    for (; e.hasData; ) {
      const r = e.readFlag();
      if (!(0 <= r && r <= 3))
        throw new W("Unknown type7 flag");
      const o = n.length;
      for (let u = 0, x = r !== 0 ? 12 : 16; u < x; u++)
        n.push(e.readCoordinate());
      const c = a.length;
      for (let u = 0, x = r !== 0 ? 2 : 4; u < x; u++)
        a.push(e.readComponents());
      let l, h, f, d;
      switch (r) {
        case 0:
          i[12] = o + 3, i[13] = o + 4, i[14] = o + 5, i[15] = o + 6, i[8] = o + 2, i[9] = o + 13, i[10] = o + 14, i[11] = o + 7, i[4] = o + 1, i[5] = o + 12, i[6] = o + 15, i[7] = o + 8, i[0] = o, i[1] = o + 11, i[2] = o + 10, i[3] = o + 9, s[2] = c + 1, s[3] = c + 2, s[0] = c, s[1] = c + 3;
          break;
        case 1:
          l = i[12], h = i[13], f = i[14], d = i[15], i[12] = d, i[13] = o + 0, i[14] = o + 1, i[15] = o + 2, i[8] = f, i[9] = o + 9, i[10] = o + 10, i[11] = o + 3, i[4] = h, i[5] = o + 8, i[6] = o + 11, i[7] = o + 4, i[0] = l, i[1] = o + 7, i[2] = o + 6, i[3] = o + 5, l = s[2], h = s[3], s[2] = h, s[3] = c, s[0] = l, s[1] = c + 1;
          break;
        case 2:
          l = i[15], h = i[11], i[12] = i[3], i[13] = o + 0, i[14] = o + 1, i[15] = o + 2, i[8] = i[7], i[9] = o + 9, i[10] = o + 10, i[11] = o + 3, i[4] = h, i[5] = o + 8, i[6] = o + 11, i[7] = o + 4, i[0] = l, i[1] = o + 7, i[2] = o + 6, i[3] = o + 5, l = s[3], s[2] = s[1], s[3] = c, s[0] = l, s[1] = c + 1;
          break;
        case 3:
          i[12] = i[0], i[13] = o + 0, i[14] = o + 1, i[15] = o + 2, i[8] = i[1], i[9] = o + 9, i[10] = o + 10, i[11] = o + 3, i[4] = i[2], i[5] = o + 8, i[6] = o + 11, i[7] = o + 4, i[0] = i[3], i[1] = o + 7, i[2] = o + 6, i[3] = o + 5, s[2] = s[0], s[3] = c, s[0] = s[1], s[1] = c + 1;
          break;
      }
      this.figures.push({
        type: "patch",
        coords: new Int32Array(i),
        colors: new Int32Array(s)
      });
    }
  }
  _buildFigureFromPatch(e) {
    const n = this.figures[e];
    at(n.type === "patch", "Unexpected patch mesh figure");
    const a = this.coords, i = this.colors, s = n.coords, r = n.colors, o = Math.min(a[s[0]][0], a[s[3]][0], a[s[12]][0], a[s[15]][0]), c = Math.min(a[s[0]][1], a[s[3]][1], a[s[12]][1], a[s[15]][1]), l = Math.max(a[s[0]][0], a[s[3]][0], a[s[12]][0], a[s[15]][0]), h = Math.max(a[s[0]][1], a[s[3]][1], a[s[12]][1], a[s[15]][1]);
    let f = Math.ceil((l - o) * Aa.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    f = Lt(f, Aa.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Aa.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
    let d = Math.ceil((h - c) * Aa.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    d = Lt(d, Aa.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Aa.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
    const u = f + 1, x = new Int32Array((d + 1) * u), g = new Int32Array((d + 1) * u);
    let p = 0;
    const m = new Uint8Array(3), b = new Uint8Array(3), y = i[r[0]], w = i[r[1]], S = i[r[2]], v = i[r[3]], k = fl(d), A = fl(f);
    for (let C = 0; C <= d; C++) {
      m[0] = (y[0] * (d - C) + S[0] * C) / d | 0, m[1] = (y[1] * (d - C) + S[1] * C) / d | 0, m[2] = (y[2] * (d - C) + S[2] * C) / d | 0, b[0] = (w[0] * (d - C) + v[0] * C) / d | 0, b[1] = (w[1] * (d - C) + v[1] * C) / d | 0, b[2] = (w[2] * (d - C) + v[2] * C) / d | 0;
      for (let T = 0; T <= f; T++, p++) {
        if ((C === 0 || C === d) && (T === 0 || T === f))
          continue;
        let M = 0, O = 0, N = 0;
        for (let J = 0; J <= 3; J++)
          for (let U = 0; U <= 3; U++, N++) {
            const j = k[C][J] * A[T][U];
            M += a[s[N]][0] * j, O += a[s[N]][1] * j;
          }
        x[p] = a.length, a.push([M, O]), g[p] = i.length;
        const H = new Uint8Array(3);
        H[0] = (m[0] * (f - T) + b[0] * T) / f | 0, H[1] = (m[1] * (f - T) + b[1] * T) / f | 0, H[2] = (m[2] * (f - T) + b[2] * T) / f | 0, i.push(H);
      }
    }
    x[0] = s[0], g[0] = r[0], x[f] = s[3], g[f] = r[1], x[u * d] = s[12], g[u * d] = r[2], x[u * d + f] = s[15], g[u * d + f] = r[3], this.figures[e] = {
      type: "lattice",
      coords: x,
      colors: g,
      verticesPerRow: u
    };
  }
  _updateBounds() {
    let e = this.coords[0][0], n = this.coords[0][1], a = e, i = n;
    for (let s = 1, r = this.coords.length; s < r; s++) {
      const o = this.coords[s][0], c = this.coords[s][1];
      e = e > o ? o : e, n = n > c ? c : n, a = a < o ? o : a, i = i < c ? c : i;
    }
    this.bounds = [e, n, a, i];
  }
  _packData() {
    let e, n, a, i;
    const s = this.coords, r = new Float32Array(s.length * 2);
    for (e = 0, a = 0, n = s.length; e < n; e++) {
      const h = s[e];
      r[a++] = h[0], r[a++] = h[1];
    }
    this.coords = r;
    const o = this.colors, c = new Uint8Array(o.length * 3);
    for (e = 0, a = 0, n = o.length; e < n; e++) {
      const h = o[e];
      c[a++] = h[0], c[a++] = h[1], c[a++] = h[2];
    }
    this.colors = c;
    const l = this.figures;
    for (e = 0, n = l.length; e < n; e++) {
      const h = l[e], f = h.coords, d = h.colors;
      for (a = 0, i = f.length; a < i; a++)
        f[a] *= 2, d[a] *= 3;
    }
  }
  getIR() {
    const {
      bounds: e
    } = this;
    if (e[2] - e[0] === 0 || e[3] - e[1] === 0)
      throw new W(`Invalid MeshShading bounds: [${e}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e, this.bbox, this.background];
  }
}
class o2 extends bs {
  getIR() {
    return ["Dummy"];
  }
}
function ul(t, e, n) {
  const a = Fa(e.getArray("Matrix"), $n), i = ma(e.getArray("BBox"), null);
  if (!i || i[2] - i[0] === 0 || i[3] - i[1] === 0)
    throw new W("Invalid getTilingPatternIR /BBox array.");
  const s = e.get("XStep");
  if (typeof s != "number")
    throw new W("Invalid getTilingPatternIR /XStep value.");
  const r = e.get("YStep");
  if (typeof r != "number")
    throw new W("Invalid getTilingPatternIR /YStep value.");
  const o = e.get("PaintType");
  if (!Number.isInteger(o))
    throw new W("Invalid getTilingPatternIR /PaintType value.");
  const c = e.get("TilingType");
  if (!Number.isInteger(c))
    throw new W("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", n, t, a, i, s, r, o, c];
}
const c2 = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], l2 = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, h2 = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], f2 = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, u2 = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], d2 = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, x2 = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], g2 = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, p2 = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], m2 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, b2 = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], y2 = {
  lineHeight: 1.35,
  lineGap: 0.2
}, w2 = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], v2 = {
  lineHeight: 1.35,
  lineGap: 0.2
}, S2 = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], k2 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, ts = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], ns = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], as = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], is = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], ss = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], rs = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], os = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], cs = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], A2 = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], C2 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, I2 = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], T2 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, E2 = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], F2 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, R2 = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], O2 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, B2 = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], M2 = {
  lineHeight: 1.33008,
  lineGap: 0
}, P2 = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], N2 = {
  lineHeight: 1.33008,
  lineGap: 0
}, D2 = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], L2 = {
  lineHeight: 1.33008,
  lineGap: 0
}, U2 = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], j2 = {
  lineHeight: 1.33008,
  lineGap: 0
}, H2 = ut(function(t) {
  t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = {
    name: "LiberationSans-Regular",
    factors: R2,
    baseWidths: os,
    baseMapping: cs,
    metrics: O2
  }, t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = {
    name: "LiberationSans-Bold",
    factors: A2,
    baseWidths: ts,
    baseMapping: ns,
    metrics: C2
  }, t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = {
    name: "LiberationSans-Italic",
    factors: E2,
    baseWidths: ss,
    baseMapping: rs,
    metrics: F2
  }, t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: I2,
    baseWidths: as,
    baseMapping: is,
    metrics: T2
  }, t.ArialMT = t.Arial = t["Arial-Regular"] = {
    name: "LiberationSans-Regular",
    baseWidths: os,
    baseMapping: cs
  }, t["Arial-BoldMT"] = t["Arial-Bold"] = {
    name: "LiberationSans-Bold",
    baseWidths: ts,
    baseMapping: ns
  }, t["Arial-ItalicMT"] = t["Arial-Italic"] = {
    name: "LiberationSans-Italic",
    baseWidths: ss,
    baseMapping: rs
  }, t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    baseWidths: as,
    baseMapping: is
  }, t["Calibri-Regular"] = {
    name: "LiberationSans-Regular",
    factors: x2,
    baseWidths: os,
    baseMapping: cs,
    metrics: g2
  }, t["Calibri-Bold"] = {
    name: "LiberationSans-Bold",
    factors: c2,
    baseWidths: ts,
    baseMapping: ns,
    metrics: l2
  }, t["Calibri-Italic"] = {
    name: "LiberationSans-Italic",
    factors: u2,
    baseWidths: ss,
    baseMapping: rs,
    metrics: d2
  }, t["Calibri-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: h2,
    baseWidths: as,
    baseMapping: is,
    metrics: f2
  }, t["Segoeui-Regular"] = {
    name: "LiberationSans-Regular",
    factors: U2,
    baseWidths: os,
    baseMapping: cs,
    metrics: j2
  }, t["Segoeui-Bold"] = {
    name: "LiberationSans-Bold",
    factors: B2,
    baseWidths: ts,
    baseMapping: ns,
    metrics: M2
  }, t["Segoeui-Italic"] = {
    name: "LiberationSans-Italic",
    factors: D2,
    baseWidths: ss,
    baseMapping: rs,
    metrics: L2
  }, t["Segoeui-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: P2,
    baseWidths: as,
    baseMapping: is,
    metrics: N2
  }, t["Helvetica-Regular"] = t.Helvetica = {
    name: "LiberationSans-Regular",
    factors: S2,
    baseWidths: os,
    baseMapping: cs,
    metrics: k2
  }, t["Helvetica-Bold"] = {
    name: "LiberationSans-Bold",
    factors: p2,
    baseWidths: ts,
    baseMapping: ns,
    metrics: m2
  }, t["Helvetica-Italic"] = {
    name: "LiberationSans-Italic",
    factors: w2,
    baseWidths: ss,
    baseMapping: rs,
    metrics: v2
  }, t["Helvetica-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: b2,
    baseWidths: as,
    baseMapping: is,
    metrics: y2
  };
});
function qo(t) {
  const e = Vs(t);
  return H2()[e];
}
function $2(t) {
  const e = qo(t);
  if (!e)
    return null;
  const {
    baseWidths: n,
    baseMapping: a,
    factors: i
  } = e, s = i ? n.map((l, h) => l * i[h]) : n;
  let r = -2, o;
  const c = [];
  for (const [l, h] of a.map((f, d) => [f, d]).sort(([f], [d]) => f - d))
    l !== -1 && (l === r + 1 ? (o.push(s[h]), r += 1) : (r = l, o = [s[h]], c.push(l, o)));
  return c;
}
function H1(t) {
  const e = $2(t), n = new B(null);
  n.set("BaseFont", Z.get(t)), n.set("Type", Z.get("Font")), n.set("Subtype", Z.get("CIDFontType2")), n.set("Encoding", Z.get("Identity-H")), n.set("CIDToGIDMap", Z.get("Identity")), n.set("W", e), n.set("FirstChar", e[0]), n.set("LastChar", e.at(-2) + e.at(-1).length - 1);
  const a = new B(null);
  n.set("FontDescriptor", a);
  const i = new B(null);
  return i.set("Ordering", "Identity"), i.set("Registry", "Adobe"), i.set("Supplement", 0), n.set("CIDSystemInfo", i), n;
}
class G2 {
  constructor(e) {
    this.lexer = e, this.operators = [], this.token = null, this.prev = null;
  }
  nextToken() {
    this.prev = this.token, this.token = this.lexer.getToken();
  }
  accept(e) {
    return this.token.type === e ? (this.nextToken(), !0) : !1;
  }
  expect(e) {
    if (this.accept(e))
      return !0;
    throw new W(`Unexpected symbol: found ${this.token.type} expected ${e}.`);
  }
  parse() {
    return this.nextToken(), this.expect(Zt.LBRACE), this.parseBlock(), this.expect(Zt.RBRACE), this.operators;
  }
  parseBlock() {
    for (; ; )
      if (this.accept(Zt.NUMBER))
        this.operators.push(this.prev.value);
      else if (this.accept(Zt.OPERATOR))
        this.operators.push(this.prev.value);
      else if (this.accept(Zt.LBRACE))
        this.parseCondition();
      else
        return;
  }
  parseCondition() {
    const e = this.operators.length;
    if (this.operators.push(null, null), this.parseBlock(), this.expect(Zt.RBRACE), this.accept(Zt.IF))
      this.operators[e] = this.operators.length, this.operators[e + 1] = "jz";
    else if (this.accept(Zt.LBRACE)) {
      const n = this.operators.length;
      this.operators.push(null, null);
      const a = this.operators.length;
      this.parseBlock(), this.expect(Zt.RBRACE), this.expect(Zt.IFELSE), this.operators[n] = this.operators.length, this.operators[n + 1] = "j", this.operators[e] = a, this.operators[e + 1] = "jz";
    } else
      throw new W("PS Function: error parsing conditional.");
  }
}
const Zt = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};
class vn {
  static get opCache() {
    return ae(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  static getOperator(e) {
    return vn.opCache[e] ||= new vn(Zt.OPERATOR, e);
  }
  static get LBRACE() {
    return ae(this, "LBRACE", new vn(Zt.LBRACE, "{"));
  }
  static get RBRACE() {
    return ae(this, "RBRACE", new vn(Zt.RBRACE, "}"));
  }
  static get IF() {
    return ae(this, "IF", new vn(Zt.IF, "IF"));
  }
  static get IFELSE() {
    return ae(this, "IFELSE", new vn(Zt.IFELSE, "IFELSE"));
  }
}
class z2 {
  constructor(e) {
    this.stream = e, this.nextChar(), this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e = !1, n = this.currentChar;
    for (; ; ) {
      if (n < 0)
        return Dt;
      if (e)
        (n === 10 || n === 13) && (e = !1);
      else if (n === 37)
        e = !0;
      else if (!An(n))
        break;
      n = this.nextChar();
    }
    switch (n | 0) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new vn(Zt.NUMBER, this.getNumber());
      case 123:
        return this.nextChar(), vn.LBRACE;
      case 125:
        return this.nextChar(), vn.RBRACE;
    }
    const a = this.strBuf;
    for (a.length = 0, a[0] = String.fromCharCode(n); (n = this.nextChar()) >= 0 && (n >= 65 && n <= 90 || n >= 97 && n <= 122); )
      a.push(String.fromCharCode(n));
    const i = a.join("");
    switch (i.toLowerCase()) {
      case "if":
        return vn.IF;
      case "ifelse":
        return vn.IFELSE;
      default:
        return vn.getOperator(i);
    }
  }
  getNumber() {
    let e = this.currentChar;
    const n = this.strBuf;
    for (n.length = 0, n[0] = String.fromCharCode(e); (e = this.nextChar()) >= 0 && (e >= 48 && e <= 57 || e === 45 || e === 46); )
      n.push(String.fromCharCode(e));
    const a = parseFloat(n.join(""));
    if (isNaN(a))
      throw new W(`Invalid floating point number: ${a}`);
    return a;
  }
}
class ui {
  constructor(e) {
    this._onlyRefs = e?.onlyRefs === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new un();
  }
  getByName(e) {
    this._onlyRefs && _e("Should not call `getByName` method.");
    const n = this._nameRefMap.get(e);
    return n ? this.getByRef(n) : this._imageMap.get(e) || null;
  }
  getByRef(e) {
    return this._imageCache.get(e) || null;
  }
  set(e, n, a) {
    _e("Abstract method `set` called.");
  }
}
class dl extends ui {
  set(e, n = null, a) {
    if (typeof e != "string")
      throw new Error('LocalImageCache.set - expected "name" argument.');
    if (n) {
      if (this._imageCache.has(n))
        return;
      this._nameRefMap.set(e, n), this._imageCache.put(n, a);
      return;
    }
    this._imageMap.has(e) || this._imageMap.set(e, a);
  }
}
class $1 extends ui {
  set(e = null, n = null, a) {
    if (typeof e != "string" && !n)
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (n) {
      if (this._imageCache.has(n))
        return;
      e !== null && this._nameRefMap.set(e, n), this._imageCache.put(n, a);
      return;
    }
    this._imageMap.has(e) || this._imageMap.set(e, a);
  }
}
class _2 extends ui {
  constructor(e) {
    super({
      onlyRefs: !0
    });
  }
  set(e = null, n, a) {
    if (!n)
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(n) || this._imageCache.put(n, a);
  }
}
class xl extends ui {
  set(e, n = null, a) {
    if (typeof e != "string")
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (n) {
      if (this._imageCache.has(n))
        return;
      this._nameRefMap.set(e, n), this._imageCache.put(n, a);
      return;
    }
    this._imageMap.has(e) || this._imageMap.set(e, a);
  }
}
class W2 extends ui {
  constructor(e) {
    super({
      onlyRefs: !0
    });
  }
  set(e = null, n, a) {
    if (!n)
      throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(n) || this._imageCache.put(n, a);
  }
}
class V2 extends ui {
  constructor(e) {
    super({
      onlyRefs: !0
    });
  }
  set(e = null, n, a) {
    if (!n)
      throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(n) || this._imageCache.put(n, a);
  }
}
class X2 extends ui {
  constructor(e) {
    super({
      onlyRefs: !0
    });
  }
  set(e = null, n, a) {
    if (!n)
      throw new Error('GlobalColorSpaceCache.set - expected "ref" argument.');
    this._imageCache.has(n) || this._imageCache.put(n, a);
  }
  clear() {
    this._imageCache.clear();
  }
}
class Ci {
  static NUM_PAGES_THRESHOLD = 2;
  static MIN_IMAGES_TO_CACHE = 10;
  static MAX_BYTE_SIZE = 5e7;
  #e = new St();
  constructor() {
    this._refCache = new un(), this._imageCache = new un();
  }
  get #t() {
    let e = 0;
    for (const n of this._imageCache)
      e += n.byteSize;
    return e;
  }
  get #n() {
    return !(this._imageCache.size < Ci.MIN_IMAGES_TO_CACHE || this.#t < Ci.MAX_BYTE_SIZE);
  }
  shouldCache(e, n) {
    let a = this._refCache.get(e);
    return a || (a = /* @__PURE__ */ new Set(), this._refCache.put(e, a)), a.add(n), !(a.size < Ci.NUM_PAGES_THRESHOLD || !this._imageCache.has(e) && this.#n);
  }
  addDecodeFailed(e) {
    this.#e.put(e);
  }
  hasDecodeFailed(e) {
    return this.#e.has(e);
  }
  addByteSize(e, n) {
    const a = this._imageCache.get(e);
    a && (a.byteSize || (a.byteSize = n));
  }
  getData(e, n) {
    const a = this._refCache.get(e);
    if (!a || a.size < Ci.NUM_PAGES_THRESHOLD)
      return null;
    const i = this._imageCache.get(e);
    return i ? (a.add(n), i) : null;
  }
  setData(e, n) {
    if (!this._refCache.has(e))
      throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    if (!this._imageCache.has(e)) {
      if (this.#n) {
        F("GlobalImageCache.setData - cache limit reached.");
        return;
      }
      this._imageCache.put(e, n);
    }
  }
  clear(e = !1) {
    e || (this.#e.clear(), this._refCache.clear()), this._imageCache.clear();
  }
}
class G1 {
  constructor({
    xref: e,
    isEvalSupported: n = !0
  }) {
    this.xref = e, this.isEvalSupported = n !== !1;
  }
  create(e, n = !1) {
    let a, i;
    if (e instanceof le ? a = e : e instanceof B ? a = e.objId : e instanceof Ne && (a = e.dict?.objId), a) {
      const r = this._localFunctionCache.getByRef(a);
      if (r)
        return r;
    }
    const s = this.xref.fetchIfRef(e);
    if (Array.isArray(s)) {
      if (!n)
        throw new Error('PDFFunctionFactory.create - expected "parseArray" argument.');
      i = gl.parseArray(this, s);
    } else
      i = gl.parse(this, s);
    return a && this._localFunctionCache.set(null, a, i), i;
  }
  get _localFunctionCache() {
    return ae(this, "_localFunctionCache", new _2());
  }
}
function In(t) {
  return Array.isArray(t) ? an(t, null) ? t : t.map((e) => +e) : null;
}
class gl {
  static getSampleArray(e, n, a, i) {
    let s, r, o = 1;
    for (s = 0, r = e.length; s < r; s++)
      o *= e[s];
    o *= n;
    const c = new Array(o);
    let l = 0, h = 0;
    const f = 1 / (2 ** a - 1), d = i.getBytes((o * a + 7) / 8);
    let u = 0;
    for (s = 0; s < o; s++) {
      for (; l < a; )
        h <<= 8, h |= d[u++], l += 8;
      l -= a, c[s] = (h >> l) * f, h &= (1 << l) - 1;
    }
    return c;
  }
  static parse(e, n) {
    const a = n.dict || n;
    switch (a.get("FunctionType")) {
      case 0:
        return this.constructSampled(e, n, a);
      case 1:
        break;
      case 2:
        return this.constructInterpolated(e, a);
      case 3:
        return this.constructStiched(e, a);
      case 4:
        return this.constructPostScript(e, n, a);
    }
    throw new W("Unknown type of function");
  }
  static parseArray(e, n) {
    const {
      xref: a
    } = e, i = [];
    for (const s of n)
      i.push(this.parse(e, a.fetchIfRef(s)));
    return function(s, r, o, c) {
      for (let l = 0, h = i.length; l < h; l++)
        i[l](s, r, o, c + l);
    };
  }
  static constructSampled(e, n, a) {
    function i(p) {
      const m = p.length, b = [];
      let y = 0;
      for (let w = 0; w < m; w += 2)
        b[y++] = [p[w], p[w + 1]];
      return b;
    }
    function s(p, m, b, y, w) {
      return y + (p - m) * ((w - y) / (b - m));
    }
    let r = In(a.getArray("Domain")), o = In(a.getArray("Range"));
    if (!r || !o)
      throw new W("No domain or range");
    const c = r.length / 2, l = o.length / 2;
    r = i(r), o = i(o);
    const h = In(a.getArray("Size")), f = a.get("BitsPerSample"), d = a.get("Order") || 1;
    d !== 1 && Ue("No support for cubic spline interpolation: " + d);
    let u = In(a.getArray("Encode"));
    if (u)
      u = i(u);
    else {
      u = [];
      for (let p = 0; p < c; ++p)
        u.push([0, h[p] - 1]);
    }
    let x = In(a.getArray("Decode"));
    x = x ? i(x) : o;
    const g = this.getSampleArray(h, l, f, n);
    return function(m, b, y, w) {
      const S = 1 << c, v = new Float64Array(S).fill(1), k = new Uint32Array(S);
      let A, C, T = l, M = 1;
      for (A = 0; A < c; ++A) {
        const O = r[A][0], N = r[A][1], H = Lt(m[b + A], O, N);
        let J = s(H, O, N, u[A][0], u[A][1]);
        const U = h[A];
        J = Lt(J, 0, U - 1);
        const j = J < U - 1 ? Math.floor(J) : J - 1, P = j + 1 - J, K = J - j, xe = j * T, X = xe + T;
        for (C = 0; C < S; C++)
          C & M ? (v[C] *= K, k[C] += X) : (v[C] *= P, k[C] += xe);
        T *= U, M <<= 1;
      }
      for (C = 0; C < l; ++C) {
        let O = 0;
        for (A = 0; A < S; A++)
          O += g[k[A] + C] * v[A];
        O = s(O, 0, 1, x[C][0], x[C][1]), y[w + C] = Lt(O, o[C][0], o[C][1]);
      }
    };
  }
  static constructInterpolated(e, n) {
    const a = In(n.getArray("C0")) || [0], i = In(n.getArray("C1")) || [1], s = n.get("N"), r = [];
    for (let c = 0, l = a.length; c < l; ++c)
      r.push(i[c] - a[c]);
    const o = r.length;
    return function(l, h, f, d) {
      const u = s === 1 ? l[h] : l[h] ** s;
      for (let x = 0; x < o; ++x)
        f[d + x] = a[x] + u * r[x];
    };
  }
  static constructStiched(e, n) {
    const a = In(n.getArray("Domain"));
    if (!a)
      throw new W("No domain");
    if (a.length / 2 !== 1)
      throw new W("Bad domain for stiched function");
    const {
      xref: s
    } = e, r = [];
    for (const h of n.get("Functions"))
      r.push(this.parse(e, s.fetchIfRef(h)));
    const o = In(n.getArray("Bounds")), c = In(n.getArray("Encode")), l = new Float32Array(1);
    return function(f, d, u, x) {
      const g = Lt(f[d], a[0], a[1]), p = o.length;
      let m;
      for (m = 0; m < p && !(g < o[m]); ++m)
        ;
      let b = a[0];
      m > 0 && (b = o[m - 1]);
      let y = a[1];
      m < o.length && (y = o[m]);
      const w = c[2 * m], S = c[2 * m + 1];
      l[0] = b === y ? w : w + (g - b) * (S - w) / (y - b), r[m](l, 0, u, x);
    };
  }
  static constructPostScript(e, n, a) {
    const i = In(a.getArray("Domain")), s = In(a.getArray("Range"));
    if (!i)
      throw new W("No domain.");
    if (!s)
      throw new W("No range.");
    const r = new z2(n), c = new G2(r).parse();
    if (e.isEvalSupported && gn.isEvalSupported) {
      const p = new tx().compile(c, i, s);
      if (p)
        return new Function("src", "srcOffset", "dest", "destOffset", p);
    }
    Ue("Unable to compile PS function");
    const l = s.length >> 1, h = i.length >> 1, f = new q2(c), d = /* @__PURE__ */ Object.create(null);
    let x = 2048 * 4;
    const g = new Float32Array(h);
    return function(m, b, y, w) {
      let S, v, k = "";
      const A = g;
      for (S = 0; S < h; S++)
        v = m[b + S], A[S] = v, k += v + "_";
      const C = d[k];
      if (C !== void 0) {
        y.set(C, w);
        return;
      }
      const T = new Float32Array(l), M = f.execute(A), O = M.length - l;
      for (S = 0; S < l; S++) {
        v = M[O + S];
        let N = s[S * 2];
        v < N ? v = N : (N = s[S * 2 + 1], v > N && (v = N)), T[S] = v;
      }
      x > 0 && (x--, d[k] = T), y.set(T, w);
    };
  }
}
function N0(t) {
  let e;
  if (t instanceof B)
    e = t;
  else if (t instanceof Ne)
    e = t.dict;
  else
    return !1;
  return e.has("FunctionType");
}
class Gr {
  static MAX_STACK_SIZE = 100;
  constructor(e) {
    this.stack = e ? Array.from(e) : [];
  }
  push(e) {
    if (this.stack.length >= Gr.MAX_STACK_SIZE)
      throw new Error("PostScript function stack overflow.");
    this.stack.push(e);
  }
  pop() {
    if (this.stack.length <= 0)
      throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(e) {
    if (this.stack.length + e >= Gr.MAX_STACK_SIZE)
      throw new Error("PostScript function stack overflow.");
    const n = this.stack;
    for (let a = n.length - e, i = e - 1; i >= 0; i--, a++)
      n.push(n[a]);
  }
  index(e) {
    this.push(this.stack[this.stack.length - e - 1]);
  }
  roll(e, n) {
    const a = this.stack, i = a.length - e, s = a.length - 1, r = i + (n - Math.floor(n / e) * e);
    for (let o = i, c = s; o < c; o++, c--) {
      const l = a[o];
      a[o] = a[c], a[c] = l;
    }
    for (let o = i, c = r - 1; o < c; o++, c--) {
      const l = a[o];
      a[o] = a[c], a[c] = l;
    }
    for (let o = r, c = s; o < c; o++, c--) {
      const l = a[o];
      a[o] = a[c], a[c] = l;
    }
  }
}
class q2 {
  constructor(e) {
    this.operators = e;
  }
  execute(e) {
    const n = new Gr(e);
    let a = 0;
    const i = this.operators, s = i.length;
    let r, o, c;
    for (; a < s; ) {
      if (r = i[a++], typeof r == "number") {
        n.push(r);
        continue;
      }
      switch (r) {
        case "jz":
          c = n.pop(), o = n.pop(), o || (a = c);
          break;
        case "j":
          o = n.pop(), a = o;
          break;
        case "abs":
          o = n.pop(), n.push(Math.abs(o));
          break;
        case "add":
          c = n.pop(), o = n.pop(), n.push(o + c);
          break;
        case "and":
          c = n.pop(), o = n.pop(), typeof o == "boolean" && typeof c == "boolean" ? n.push(o && c) : n.push(o & c);
          break;
        case "atan":
          c = n.pop(), o = n.pop(), o = Math.atan2(o, c) / Math.PI * 180, o < 0 && (o += 360), n.push(o);
          break;
        case "bitshift":
          c = n.pop(), o = n.pop(), o > 0 ? n.push(o << c) : n.push(o >> c);
          break;
        case "ceiling":
          o = n.pop(), n.push(Math.ceil(o));
          break;
        case "copy":
          o = n.pop(), n.copy(o);
          break;
        case "cos":
          o = n.pop(), n.push(Math.cos(o % 360 / 180 * Math.PI));
          break;
        case "cvi":
          o = n.pop() | 0, n.push(o);
          break;
        case "cvr":
          break;
        case "div":
          c = n.pop(), o = n.pop(), n.push(o / c);
          break;
        case "dup":
          n.copy(1);
          break;
        case "eq":
          c = n.pop(), o = n.pop(), n.push(o === c);
          break;
        case "exch":
          n.roll(2, 1);
          break;
        case "exp":
          c = n.pop(), o = n.pop(), n.push(o ** c);
          break;
        case "false":
          n.push(!1);
          break;
        case "floor":
          o = n.pop(), n.push(Math.floor(o));
          break;
        case "ge":
          c = n.pop(), o = n.pop(), n.push(o >= c);
          break;
        case "gt":
          c = n.pop(), o = n.pop(), n.push(o > c);
          break;
        case "idiv":
          c = n.pop(), o = n.pop(), n.push(o / c | 0);
          break;
        case "index":
          o = n.pop(), n.index(o);
          break;
        case "le":
          c = n.pop(), o = n.pop(), n.push(o <= c);
          break;
        case "ln":
          o = n.pop(), n.push(Math.log(o));
          break;
        case "log":
          o = n.pop(), n.push(Math.log10(o));
          break;
        case "lt":
          c = n.pop(), o = n.pop(), n.push(o < c);
          break;
        case "mod":
          c = n.pop(), o = n.pop(), n.push(o % c);
          break;
        case "mul":
          c = n.pop(), o = n.pop(), n.push(o * c);
          break;
        case "ne":
          c = n.pop(), o = n.pop(), n.push(o !== c);
          break;
        case "neg":
          o = n.pop(), n.push(-o);
          break;
        case "not":
          o = n.pop(), typeof o == "boolean" ? n.push(!o) : n.push(~o);
          break;
        case "or":
          c = n.pop(), o = n.pop(), typeof o == "boolean" && typeof c == "boolean" ? n.push(o || c) : n.push(o | c);
          break;
        case "pop":
          n.pop();
          break;
        case "roll":
          c = n.pop(), o = n.pop(), n.roll(o, c);
          break;
        case "round":
          o = n.pop(), n.push(Math.round(o));
          break;
        case "sin":
          o = n.pop(), n.push(Math.sin(o % 360 / 180 * Math.PI));
          break;
        case "sqrt":
          o = n.pop(), n.push(Math.sqrt(o));
          break;
        case "sub":
          c = n.pop(), o = n.pop(), n.push(o - c);
          break;
        case "true":
          n.push(!0);
          break;
        case "truncate":
          o = n.pop(), o = o < 0 ? Math.ceil(o) : Math.floor(o), n.push(o);
          break;
        case "xor":
          c = n.pop(), o = n.pop(), typeof o == "boolean" && typeof c == "boolean" ? n.push(o !== c) : n.push(o ^ c);
          break;
        default:
          throw new W(`Unknown operator ${r}`);
      }
    }
    return n.stack;
  }
}
class Vi {
  constructor(e) {
    this.type = e;
  }
  visit(e) {
    _e("abstract method");
  }
}
class K2 extends Vi {
  constructor(e, n, a) {
    super("args"), this.index = e, this.min = n, this.max = a;
  }
  visit(e) {
    e.visitArgument(this);
  }
}
class ni extends Vi {
  constructor(e) {
    super("literal"), this.number = e, this.min = e, this.max = e;
  }
  visit(e) {
    e.visitLiteral(this);
  }
}
class Ko extends Vi {
  constructor(e, n, a, i, s) {
    super("binary"), this.op = e, this.arg1 = n, this.arg2 = a, this.min = i, this.max = s;
  }
  visit(e) {
    e.visitBinaryOperation(this);
  }
}
class Y2 extends Vi {
  constructor(e, n) {
    super("max"), this.arg = e, this.min = e.min, this.max = n;
  }
  visit(e) {
    e.visitMin(this);
  }
}
class pl extends Vi {
  constructor(e, n, a) {
    super("var"), this.index = e, this.min = n, this.max = a;
  }
  visit(e) {
    e.visitVariable(this);
  }
}
class ml extends Vi {
  constructor(e, n) {
    super("definition"), this.variable = e, this.arg = n;
  }
  visit(e) {
    e.visitVariableDefinition(this);
  }
}
class bl {
  constructor() {
    this.parts = [];
  }
  visitArgument(e) {
    this.parts.push("Math.max(", e.min, ", Math.min(", e.max, ", src[srcOffset + ", e.index, "]))");
  }
  visitVariable(e) {
    this.parts.push("v", e.index);
  }
  visitLiteral(e) {
    this.parts.push(e.number);
  }
  visitBinaryOperation(e) {
    this.parts.push("("), e.arg1.visit(this), this.parts.push(" ", e.op, " "), e.arg2.visit(this), this.parts.push(")");
  }
  visitVariableDefinition(e) {
    this.parts.push("var "), e.variable.visit(this), this.parts.push(" = "), e.arg.visit(this), this.parts.push(";");
  }
  visitMin(e) {
    this.parts.push("Math.min("), e.arg.visit(this), this.parts.push(", ", e.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function J2(t, e) {
  return e.type === "literal" && e.number === 0 ? t : t.type === "literal" && t.number === 0 ? e : e.type === "literal" && t.type === "literal" ? new ni(t.number + e.number) : new Ko("+", t, e, t.min + e.min, t.max + e.max);
}
function Z2(t, e) {
  if (e.type === "literal") {
    if (e.number === 0)
      return new ni(0);
    if (e.number === 1)
      return t;
    if (t.type === "literal")
      return new ni(t.number * e.number);
  }
  if (t.type === "literal") {
    if (t.number === 0)
      return new ni(0);
    if (t.number === 1)
      return e;
  }
  const n = Math.min(t.min * e.min, t.min * e.max, t.max * e.min, t.max * e.max), a = Math.max(t.min * e.min, t.min * e.max, t.max * e.min, t.max * e.max);
  return new Ko("*", t, e, n, a);
}
function Q2(t, e) {
  if (e.type === "literal") {
    if (e.number === 0)
      return t;
    if (t.type === "literal")
      return new ni(t.number - e.number);
  }
  return e.type === "binary" && e.op === "-" && t.type === "literal" && t.number === 1 && e.arg1.type === "literal" && e.arg1.number === 1 ? e.arg2 : new Ko("-", t, e, t.min - e.max, t.max - e.min);
}
function ex(t, e) {
  return t.min >= e ? new ni(e) : t.max <= e ? t : new Y2(t, e);
}
class tx {
  compile(e, n, a) {
    const i = [], s = [], r = n.length >> 1, o = a.length >> 1;
    let c = 0, l, h, f, d, u, x, g, p;
    for (let b = 0; b < r; b++)
      i.push(new K2(b, n[b * 2], n[b * 2 + 1]));
    for (let b = 0, y = e.length; b < y; b++) {
      if (p = e[b], typeof p == "number") {
        i.push(new ni(p));
        continue;
      }
      switch (p) {
        case "add":
          if (i.length < 2)
            return null;
          d = i.pop(), f = i.pop(), i.push(J2(f, d));
          break;
        case "cvr":
          if (i.length < 1)
            return null;
          break;
        case "mul":
          if (i.length < 2)
            return null;
          d = i.pop(), f = i.pop(), i.push(Z2(f, d));
          break;
        case "sub":
          if (i.length < 2)
            return null;
          d = i.pop(), f = i.pop(), i.push(Q2(f, d));
          break;
        case "exch":
          if (i.length < 2)
            return null;
          u = i.pop(), x = i.pop(), i.push(u, x);
          break;
        case "pop":
          if (i.length < 1)
            return null;
          i.pop();
          break;
        case "index":
          if (i.length < 1 || (f = i.pop(), f.type !== "literal") || (l = f.number, l < 0 || !Number.isInteger(l) || i.length < l))
            return null;
          if (u = i[i.length - l - 1], u.type === "literal" || u.type === "var") {
            i.push(u);
            break;
          }
          g = new pl(c++, u.min, u.max), i[i.length - l - 1] = g, i.push(g), s.push(new ml(g, u));
          break;
        case "dup":
          if (i.length < 1)
            return null;
          if (typeof e[b + 1] == "number" && e[b + 2] === "gt" && e[b + 3] === b + 7 && e[b + 4] === "jz" && e[b + 5] === "pop" && e[b + 6] === e[b + 1]) {
            f = i.pop(), i.push(ex(f, e[b + 1])), b += 6;
            break;
          }
          if (u = i.at(-1), u.type === "literal" || u.type === "var") {
            i.push(u);
            break;
          }
          g = new pl(c++, u.min, u.max), i[i.length - 1] = g, i.push(g), s.push(new ml(g, u));
          break;
        case "roll":
          if (i.length < 2 || (d = i.pop(), f = i.pop(), d.type !== "literal" || f.type !== "literal") || (h = d.number, l = f.number, l <= 0 || !Number.isInteger(l) || !Number.isInteger(h) || i.length < l))
            return null;
          if (h = (h % l + l) % l, h === 0)
            break;
          i.push(...i.splice(i.length - l, l - h));
          break;
        default:
          return null;
      }
    }
    if (i.length !== o)
      return null;
    const m = [];
    for (const b of s) {
      const y = new bl();
      b.visit(y), m.push(y.toString());
    }
    for (let b = 0, y = i.length; b < y; b++) {
      const w = i[b], S = new bl();
      w.visit(S);
      const v = a[b * 2], k = a[b * 2 + 1], A = [S.toString()];
      v > w.min && (A.unshift("Math.max(", v, ", "), A.push(")")), k < w.max && (A.unshift("Math.min(", k, ", "), A.push(")")), A.unshift("dest[destOffset + ", b, "] = "), A.push(";"), m.push(A.join(""));
    }
    return m.join(`
`);
  }
}
const nx = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], ax = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function yl(t) {
  return (t & 1) !== 0;
}
function ix(t) {
  return (t & 1) === 0;
}
function sx(t, e, n) {
  let a, i;
  for (a = e, i = t.length; a < i; ++a)
    if (t[a] !== n)
      return a;
  return a;
}
function wl(t, e, n) {
  for (let a = e, i = n - 1; a < i; ++a, --i) {
    const s = t[a];
    t[a] = t[i], t[i] = s;
  }
}
function D0(t, e, n = !1) {
  let a = "ltr";
  return n ? a = "ttb" : e || (a = "rtl"), {
    str: t,
    dir: a
  };
}
const wa = [], Ke = [];
function z1(t, e = -1, n = !1) {
  let a = !0;
  const i = t.length;
  if (i === 0 || n)
    return D0(t, a, n);
  wa.length = i, Ke.length = i;
  let s = 0, r, o;
  for (r = 0; r < i; ++r) {
    wa[r] = t.charAt(r);
    const m = t.charCodeAt(r);
    let b = "L";
    m <= 255 ? b = nx[m] : 1424 <= m && m <= 1524 ? b = "R" : 1536 <= m && m <= 1791 ? (b = ax[m & 255], b || F("Bidi: invalid Unicode character " + m.toString(16))) : (1792 <= m && m <= 2220 || 64336 <= m && m <= 65023 || 65136 <= m && m <= 65279) && (b = "AL"), (b === "R" || b === "AL" || b === "AN") && s++, Ke[r] = b;
  }
  if (s === 0)
    return a = !0, D0(t, a);
  e === -1 && (s / i < 0.3 && i > 4 ? (a = !0, e = 0) : (a = !1, e = 1));
  const c = [];
  for (r = 0; r < i; ++r)
    c[r] = e;
  const l = yl(e) ? "R" : "L", h = l, f = h;
  let d = h;
  for (r = 0; r < i; ++r)
    Ke[r] === "NSM" ? Ke[r] = d : d = Ke[r];
  d = h;
  let u;
  for (r = 0; r < i; ++r)
    u = Ke[r], u === "EN" ? Ke[r] = d === "AL" ? "AN" : "EN" : (u === "R" || u === "L" || u === "AL") && (d = u);
  for (r = 0; r < i; ++r)
    u = Ke[r], u === "AL" && (Ke[r] = "R");
  for (r = 1; r < i - 1; ++r)
    Ke[r] === "ES" && Ke[r - 1] === "EN" && Ke[r + 1] === "EN" && (Ke[r] = "EN"), Ke[r] === "CS" && (Ke[r - 1] === "EN" || Ke[r - 1] === "AN") && Ke[r + 1] === Ke[r - 1] && (Ke[r] = Ke[r - 1]);
  for (r = 0; r < i; ++r)
    if (Ke[r] === "EN") {
      for (let m = r - 1; m >= 0 && Ke[m] === "ET"; --m)
        Ke[m] = "EN";
      for (let m = r + 1; m < i && Ke[m] === "ET"; ++m)
        Ke[m] = "EN";
    }
  for (r = 0; r < i; ++r)
    u = Ke[r], (u === "WS" || u === "ES" || u === "ET" || u === "CS") && (Ke[r] = "ON");
  for (d = h, r = 0; r < i; ++r)
    u = Ke[r], u === "EN" ? Ke[r] = d === "L" ? "L" : "EN" : (u === "R" || u === "L") && (d = u);
  for (r = 0; r < i; ++r)
    if (Ke[r] === "ON") {
      const m = sx(Ke, r + 1, "ON");
      let b = h;
      r > 0 && (b = Ke[r - 1]);
      let y = f;
      m + 1 < i && (y = Ke[m + 1]), b !== "L" && (b = "R"), y !== "L" && (y = "R"), b === y && Ke.fill(b, r, m), r = m - 1;
    }
  for (r = 0; r < i; ++r)
    Ke[r] === "ON" && (Ke[r] = l);
  for (r = 0; r < i; ++r)
    u = Ke[r], ix(c[r]) ? u === "R" ? c[r] += 1 : (u === "AN" || u === "EN") && (c[r] += 2) : (u === "L" || u === "AN" || u === "EN") && (c[r] += 1);
  let x = -1, g = 99, p;
  for (r = 0, o = c.length; r < o; ++r)
    p = c[r], x < p && (x = p), g > p && yl(p) && (g = p);
  for (p = x; p >= g; --p) {
    let m = -1;
    for (r = 0, o = c.length; r < o; ++r)
      c[r] < p ? m >= 0 && (wl(wa, m, r), m = -1) : m < 0 && (m = r);
    m >= 0 && wl(wa, m, c.length);
  }
  for (r = 0, o = wa.length; r < o; ++r) {
    const m = wa[r];
    (m === "<" || m === ">") && (wa[r] = "");
  }
  return D0(wa.join(""), a);
}
class Pi {
  #e;
  #t;
  #n;
  static strings = ["fontFamily", "fontWeight", "italicAngle"];
  static write(e) {
    const n = new TextEncoder(), a = {};
    let i = 0;
    for (const l of Pi.strings) {
      const h = n.encode(e[l]);
      a[l] = h, i += 4 + h.length;
    }
    const s = new ArrayBuffer(i), r = new Uint8Array(s), o = new DataView(s);
    let c = 0;
    for (const l of Pi.strings) {
      const h = a[l], f = h.length;
      o.setUint32(c, f), r.set(h, c + 4), c += 4 + f;
    }
    return at(c === s.byteLength, "CssFontInfo.write: Buffer overflow"), s;
  }
  constructor(e) {
    this.#e = e, this.#t = new DataView(this.#e), this.#n = new TextDecoder();
  }
  #a(e) {
    at(e < Pi.strings.length, "Invalid string index");
    let n = 0;
    for (let i = 0; i < e; i++)
      n += this.#t.getUint32(n) + 4;
    const a = this.#t.getUint32(n);
    return this.#n.decode(new Uint8Array(this.#e, n + 4, a));
  }
  get fontFamily() {
    return this.#a(0);
  }
  get fontWeight() {
    return this.#a(1);
  }
  get italicAngle() {
    return this.#a(2);
  }
}
class Ni {
  #e;
  #t;
  #n;
  static strings = ["css", "loadedName", "baseFontName", "src"];
  static write(e) {
    const n = new TextEncoder(), a = {};
    let i = 0;
    for (const d of Ni.strings) {
      const u = n.encode(e[d]);
      a[d] = u, i += 4 + u.length;
    }
    i += 4;
    let s, r, o = 1 + i;
    e.style && (s = n.encode(e.style.style), r = n.encode(e.style.weight), o += 4 + s.length + 4 + r.length);
    const c = new ArrayBuffer(o), l = new Uint8Array(c), h = new DataView(c);
    let f = 0;
    h.setUint8(f++, e.guessFallback ? 1 : 0), h.setUint32(f, 0), f += 4, i = 0;
    for (const d of Ni.strings) {
      const u = a[d], x = u.length;
      i += 4 + x, h.setUint32(f, x), l.set(u, f + 4), f += 4 + x;
    }
    return h.setUint32(f - i - 4, i), e.style && (h.setUint32(f, s.length), l.set(s, f + 4), f += 4 + s.length, h.setUint32(f, r.length), l.set(r, f + 4), f += 4 + r.length), at(f <= c.byteLength, "SubstitionInfo.write: Buffer overflow"), c.transferToFixedLength(f);
  }
  constructor(e) {
    this.#e = e, this.#t = new DataView(this.#e), this.#n = new TextDecoder();
  }
  get guessFallback() {
    return this.#t.getUint8(0) !== 0;
  }
  #a(e) {
    at(e < Ni.strings.length, "Invalid string index");
    let n = 5;
    for (let i = 0; i < e; i++)
      n += this.#t.getUint32(n) + 4;
    const a = this.#t.getUint32(n);
    return this.#n.decode(new Uint8Array(this.#e, n + 4, a));
  }
  get css() {
    return this.#a(0);
  }
  get loadedName() {
    return this.#a(1);
  }
  get baseFontName() {
    return this.#a(2);
  }
  get src() {
    return this.#a(3);
  }
  get style() {
    let e = 1;
    e += 4 + this.#t.getUint32(e);
    const n = this.#t.getUint32(e), a = this.#n.decode(new Uint8Array(this.#e, e + 4, n));
    e += 4 + n;
    const i = this.#t.getUint32(e), s = this.#n.decode(new Uint8Array(this.#e, e + 4, i));
    return {
      style: a,
      weight: s
    };
  }
}
class ct {
  static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
  static numbers = ["ascent", "defaultWidth", "descent"];
  static strings = ["fallbackName", "loadedName", "mimetype", "name"];
  static #e = Math.ceil(this.bools.length * 2 / 8);
  static #t = this.#e + this.numbers.length * 8;
  static #n = this.#t + 1 + 8;
  static #a = this.#n + 1 + 48;
  static #s = this.#a + 1 + 6;
  #r;
  #c;
  #i;
  constructor({
    data: e,
    extra: n
  }) {
    this.#r = e, this.#c = new TextDecoder(), this.#i = new DataView(this.#r), n && Object.assign(this, n);
  }
  #o(e) {
    at(e < ct.bools.length, "Invalid boolean index");
    const n = Math.floor(e / 4), a = e * 2 % 8, i = this.#i.getUint8(n) >> a & 3;
    return i === 0 ? void 0 : i === 2;
  }
  get black() {
    return this.#o(0);
  }
  get bold() {
    return this.#o(1);
  }
  get disableFontFace() {
    return this.#o(2);
  }
  get fontExtraProperties() {
    return this.#o(3);
  }
  get isInvalidPDFjsFont() {
    return this.#o(4);
  }
  get isType3Font() {
    return this.#o(5);
  }
  get italic() {
    return this.#o(6);
  }
  get missingFile() {
    return this.#o(7);
  }
  get remeasure() {
    return this.#o(8);
  }
  get vertical() {
    return this.#o(9);
  }
  #l(e) {
    return at(e < ct.numbers.length, "Invalid number index"), this.#i.getFloat64(ct.#e + e * 8);
  }
  get ascent() {
    return this.#l(0);
  }
  get defaultWidth() {
    return this.#l(1);
  }
  get descent() {
    return this.#l(2);
  }
  get bbox() {
    let e = ct.#t;
    if (this.#i.getUint8(e) === 0)
      return;
    e += 1;
    const a = [];
    for (let i = 0; i < 4; i++)
      a.push(this.#i.getInt16(e, !0)), e += 2;
    return a;
  }
  get fontMatrix() {
    let e = ct.#n;
    if (this.#i.getUint8(e) === 0)
      return;
    e += 1;
    const a = [];
    for (let i = 0; i < 6; i++)
      a.push(this.#i.getFloat64(e, !0)), e += 8;
    return a;
  }
  get defaultVMetrics() {
    let e = ct.#a;
    if (this.#i.getUint8(e) === 0)
      return;
    e += 1;
    const a = [];
    for (let i = 0; i < 3; i++)
      a.push(this.#i.getInt16(e, !0)), e += 2;
    return a;
  }
  #h(e) {
    at(e < ct.strings.length, "Invalid string index");
    let n = ct.#s + 4;
    for (let s = 0; s < e; s++)
      n += this.#i.getUint32(n) + 4;
    const a = this.#i.getUint32(n), i = new Uint8Array(a);
    return i.set(new Uint8Array(this.#r, n + 4, a)), this.#c.decode(i);
  }
  get fallbackName() {
    return this.#h(0);
  }
  get loadedName() {
    return this.#h(1);
  }
  get mimetype() {
    return this.#h(2);
  }
  get name() {
    return this.#h(3);
  }
  get data() {
    let e = ct.#s;
    const n = this.#i.getUint32(e);
    e += 4 + n;
    const a = this.#i.getUint32(e);
    e += 4 + a;
    const i = this.#i.getUint32(e);
    e += 4 + i;
    const s = this.#i.getUint32(e);
    if (s !== 0)
      return new Uint8Array(this.#r, e + 4, s);
  }
  clearData() {
    let e = ct.#s;
    const n = this.#i.getUint32(e);
    e += 4 + n;
    const a = this.#i.getUint32(e);
    e += 4 + a;
    const i = this.#i.getUint32(e);
    e += 4 + i;
    const s = this.#i.getUint32(e);
    new Uint8Array(this.#r, e + 4, s).fill(0), this.#i.setUint32(e, 0);
  }
  get cssFontInfo() {
    let e = ct.#s;
    const n = this.#i.getUint32(e);
    e += 4 + n;
    const a = this.#i.getUint32(e);
    e += 4 + a;
    const i = this.#i.getUint32(e);
    if (i === 0)
      return null;
    const s = new Uint8Array(i);
    return s.set(new Uint8Array(this.#r, e + 4, i)), new Pi(s.buffer);
  }
  get systemFontInfo() {
    let e = ct.#s;
    const n = this.#i.getUint32(e);
    e += 4 + n;
    const a = this.#i.getUint32(e);
    if (a === 0)
      return null;
    const i = new Uint8Array(a);
    return i.set(new Uint8Array(this.#r, e + 4, a)), new Ni(i.buffer);
  }
  static write(e) {
    const n = e.systemFontInfo ? Ni.write(e.systemFontInfo) : null, a = e.cssFontInfo ? Pi.write(e.cssFontInfo) : null, i = new TextEncoder(), s = {};
    let r = 0;
    for (const g of ct.strings)
      s[g] = i.encode(e[g]), r += 4 + s[g].length;
    const o = ct.#s + 4 + r + 4 + (n ? n.byteLength : 0) + 4 + (a ? a.byteLength : 0) + 4 + (e.data ? e.data.length : 0), c = new ArrayBuffer(o), l = new Uint8Array(c), h = new DataView(c);
    let f = 0;
    const d = ct.bools.length;
    let u = 0, x = 0;
    for (let g = 0; g < d; g++) {
      const p = e[ct.bools[g]];
      u |= (p === void 0 ? 0 : p ? 2 : 1) << x, x += 2, (x === 8 || g === d - 1) && (h.setUint8(f++, u), u = 0, x = 0);
    }
    at(f === ct.#e, "FontInfo.write: Boolean properties offset mismatch");
    for (const g of ct.numbers)
      h.setFloat64(f, e[g]), f += 8;
    if (at(f === ct.#t, "FontInfo.write: Number properties offset mismatch"), e.bbox) {
      h.setUint8(f++, 4);
      for (const g of e.bbox)
        h.setInt16(f, g, !0), f += 2;
    } else
      h.setUint8(f++, 0), f += 8;
    if (at(f === ct.#n, "FontInfo.write: BBox properties offset mismatch"), e.fontMatrix) {
      h.setUint8(f++, 6);
      for (const g of e.fontMatrix)
        h.setFloat64(f, g, !0), f += 8;
    } else
      h.setUint8(f++, 0), f += 48;
    if (at(f === ct.#a, "FontInfo.write: FontMatrix properties offset mismatch"), e.defaultVMetrics) {
      h.setUint8(f++, 1);
      for (const g of e.defaultVMetrics)
        h.setInt16(f, g, !0), f += 2;
    } else
      h.setUint8(f++, 0), f += 6;
    at(f === ct.#s, "FontInfo.write: DefaultVMetrics properties offset mismatch"), h.setUint32(ct.#s, 0), f += 4;
    for (const g of ct.strings) {
      const p = s[g], m = p.length;
      h.setUint32(f, m), l.set(p, f + 4), f += 4 + m;
    }
    if (h.setUint32(ct.#s, f - ct.#s - 4), !n)
      h.setUint32(f, 0), f += 4;
    else {
      const g = n.byteLength;
      h.setUint32(f, g), at(f + 4 + g <= c.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo"), l.set(new Uint8Array(n), f + 4), f += 4 + g;
    }
    if (!a)
      h.setUint32(f, 0), f += 4;
    else {
      const g = a.byteLength;
      h.setUint32(f, g), at(f + 4 + g <= c.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo"), l.set(new Uint8Array(a), f + 4), f += 4 + g;
    }
    return e.data === void 0 ? (h.setUint32(f, 0), f += 4) : (h.setUint32(f, e.data.length), l.set(e.data, f + 4), f += 4 + e.data.length), at(f <= c.byteLength, "FontInfo.write: Buffer overflow"), c.transferToFixedLength(f);
  }
}
const Ka = {
  style: "normal",
  weight: "normal"
}, Ya = {
  style: "normal",
  weight: "bold"
}, Ja = {
  style: "italic",
  weight: "normal"
}, Za = {
  style: "italic",
  weight: "bold"
}, ys = /* @__PURE__ */ new Map([["Times-Roman", {
  local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
  style: Ka,
  ultimate: "serif"
}], ["Times-Bold", {
  alias: "Times-Roman",
  style: Ya,
  ultimate: "serif"
}], ["Times-Italic", {
  alias: "Times-Roman",
  style: Ja,
  ultimate: "serif"
}], ["Times-BoldItalic", {
  alias: "Times-Roman",
  style: Za,
  ultimate: "serif"
}], ["Helvetica", {
  local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
  path: "LiberationSans-Regular.ttf",
  style: Ka,
  ultimate: "sans-serif"
}], ["Helvetica-Bold", {
  alias: "Helvetica",
  path: "LiberationSans-Bold.ttf",
  style: Ya,
  ultimate: "sans-serif"
}], ["Helvetica-Oblique", {
  alias: "Helvetica",
  path: "LiberationSans-Italic.ttf",
  style: Ja,
  ultimate: "sans-serif"
}], ["Helvetica-BoldOblique", {
  alias: "Helvetica",
  path: "LiberationSans-BoldItalic.ttf",
  style: Za,
  ultimate: "sans-serif"
}], ["Courier", {
  local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"],
  style: Ka,
  ultimate: "monospace"
}], ["Courier-Bold", {
  alias: "Courier",
  style: Ya,
  ultimate: "monospace"
}], ["Courier-Oblique", {
  alias: "Courier",
  style: Ja,
  ultimate: "monospace"
}], ["Courier-BoldOblique", {
  alias: "Courier",
  style: Za,
  ultimate: "monospace"
}], ["ArialBlack", {
  local: ["Arial Black"],
  style: {
    style: "normal",
    weight: "900"
  },
  fallback: "Helvetica-Bold"
}], ["ArialBlack-Bold", {
  alias: "ArialBlack"
}], ["ArialBlack-Italic", {
  alias: "ArialBlack",
  style: {
    style: "italic",
    weight: "900"
  },
  fallback: "Helvetica-BoldOblique"
}], ["ArialBlack-BoldItalic", {
  alias: "ArialBlack-Italic"
}], ["ArialNarrow", {
  local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
  style: Ka,
  fallback: "Helvetica"
}], ["ArialNarrow-Bold", {
  alias: "ArialNarrow",
  style: Ya,
  fallback: "Helvetica-Bold"
}], ["ArialNarrow-Italic", {
  alias: "ArialNarrow",
  style: Ja,
  fallback: "Helvetica-Oblique"
}], ["ArialNarrow-BoldItalic", {
  alias: "ArialNarrow",
  style: Za,
  fallback: "Helvetica-BoldOblique"
}], ["Calibri", {
  local: ["Calibri", "Carlito"],
  style: Ka,
  fallback: "Helvetica"
}], ["Calibri-Bold", {
  alias: "Calibri",
  style: Ya,
  fallback: "Helvetica-Bold"
}], ["Calibri-Italic", {
  alias: "Calibri",
  style: Ja,
  fallback: "Helvetica-Oblique"
}], ["Calibri-BoldItalic", {
  alias: "Calibri",
  style: Za,
  fallback: "Helvetica-BoldOblique"
}], ["Wingdings", {
  local: ["Wingdings", "URW Dingbats"],
  style: Ka
}], ["Wingdings-Regular", {
  alias: "Wingdings"
}], ["Wingdings-Bold", {
  alias: "Wingdings"
}]]), rx = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function ox(t) {
  switch (t) {
    case Ya:
      return "Bold";
    case Ja:
      return "Italic";
    case Za:
      return "Bold Italic";
    default:
      if (t?.weight === "bold")
        return "Bold";
      if (t?.style === "italic")
        return "Italic";
  }
  return "";
}
function vl(t) {
  const e = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return t.split(/[- ,+]+/g).filter((n) => !e.has(n.toLowerCase())).join(" ");
}
function bo({
  alias: t,
  local: e,
  path: n,
  fallback: a,
  style: i,
  ultimate: s
}, r, o, c = !0, l = !0, h = "") {
  const f = {
    style: null,
    ultimate: null
  };
  if (e) {
    const d = h ? ` ${h}` : "";
    for (const u of e)
      r.push(`local(${u}${d})`);
  }
  if (t) {
    const d = ys.get(t), u = h || ox(i);
    Object.assign(f, bo(d, r, o, c && !a, l && !n, u));
  }
  if (i && (f.style = i), s && (f.ultimate = s), c && a) {
    const d = ys.get(a), {
      ultimate: u
    } = bo(d, r, o, c, l && !n, h);
    f.ultimate ||= u;
  }
  return l && n && o && r.push(`url(${o}${n})`), f;
}
function Sl(t, e, n, a, i, s) {
  if (a.startsWith("InvalidPDFjsFont_"))
    return null;
  (s === "TrueType" || s === "Type1") && /^[A-Z]{6}\+/.test(a) && (a = a.slice(7)), a = Vs(a);
  const r = a;
  let o = t.get(r);
  if (o)
    return o;
  let c = ys.get(a);
  if (!c) {
    for (const [p, m] of rx)
      if (a.startsWith(p)) {
        a = `${m}${a.substring(p.length)}`, c = ys.get(a);
        break;
      }
  }
  let l = !1;
  c || (c = ys.get(i), l = !0);
  const h = `${e.getDocId()}_s${e.createFontId()}`;
  if (!c) {
    if (!ao(a))
      return F(`Cannot substitute the font because of its name: ${a}`), t.set(r, null), null;
    const p = /bold/gi.test(a), m = /oblique|italic/gi.test(a), b = p && m && Za || p && Ya || m && Ja || Ka;
    return o = {
      css: `"${vl(a)}",${h}`,
      guessFallback: !0,
      loadedName: h,
      baseFontName: a,
      src: `local(${a})`,
      style: b
    }, t.set(r, o), o;
  }
  const f = [];
  l && ao(a) && f.push(`local(${a})`);
  const {
    style: d,
    ultimate: u
  } = bo(c, f, n), x = u === null, g = x ? "" : `,${u}`;
  return o = {
    css: `"${vl(a)}",${h}${g}`,
    guessFallback: x,
    loadedName: h,
    baseFontName: a,
    src: f.join(","),
    style: d
  }, t.set(r, o), o;
}
const kl = 3285377520, Tn = 4294901760, qn = 65535;
class cx {
  constructor(e) {
    this.h1 = e ? e & 4294967295 : kl, this.h2 = e ? e & 4294967295 : kl;
  }
  update(e) {
    let n, a;
    if (typeof e == "string") {
      n = new Uint8Array(e.length * 2), a = 0;
      for (let g = 0, p = e.length; g < p; g++) {
        const m = e.charCodeAt(g);
        m <= 255 ? n[a++] = m : (n[a++] = m >>> 8, n[a++] = m & 255);
      }
    } else if (ArrayBuffer.isView(e))
      n = e.slice(), a = n.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = a >> 2, s = a - i * 4, r = new Uint32Array(n.buffer, 0, i);
    let o = 0, c = 0, l = this.h1, h = this.h2;
    const f = 3432918353, d = 461845907, u = f & qn, x = d & qn;
    for (let g = 0; g < i; g++)
      g & 1 ? (o = r[g], o = o * f & Tn | o * u & qn, o = o << 15 | o >>> 17, o = o * d & Tn | o * x & qn, l ^= o, l = l << 13 | l >>> 19, l = l * 5 + 3864292196) : (c = r[g], c = c * f & Tn | c * u & qn, c = c << 15 | c >>> 17, c = c * d & Tn | c * x & qn, h ^= c, h = h << 13 | h >>> 19, h = h * 5 + 3864292196);
    switch (o = 0, s) {
      case 3:
        o ^= n[i * 4 + 2] << 16;
      case 2:
        o ^= n[i * 4 + 1] << 8;
      case 1:
        o ^= n[i * 4], o = o * f & Tn | o * u & qn, o = o << 15 | o >>> 17, o = o * d & Tn | o * x & qn, i & 1 ? l ^= o : h ^= o;
    }
    this.h1 = l, this.h2 = h;
  }
  hexdigest() {
    let e = this.h1, n = this.h2;
    return e ^= n >>> 1, e = e * 3981806797 & Tn | e * 36045 & qn, n = n * 4283543511 & Tn | ((n << 16 | e >>> 16) * 2950163797 & Tn) >>> 16, e ^= n >>> 1, e = e * 444984403 & Tn | e * 60499 & qn, n = n * 3301882366 & Tn | ((n << 16 | e >>> 16) * 3120437893 & Tn) >>> 16, e ^= n >>> 1, (e >>> 0).toString(16).padStart(8, "0") + (n >>> 0).toString(16).padStart(8, "0");
  }
}
function Al(t, e, n, a, i, s) {
  const r = i * s;
  let o;
  e <= 8 ? o = new Uint8Array(r) : e <= 16 ? o = new Uint16Array(r) : o = new Uint32Array(r);
  const c = n / i, l = a / s;
  let h, f, d, u = 0, x;
  const g = new Uint16Array(i), p = n;
  for (h = 0; h < i; h++)
    g[h] = Math.floor(h * c);
  for (h = 0; h < s; h++)
    for (d = Math.floor(h * l) * p, f = 0; f < i; f++)
      x = d + g[f], o[u++] = t[x];
  return o;
}
class Ma {
  constructor({
    xref: e,
    res: n,
    image: a,
    isInline: i = !1,
    smask: s = null,
    mask: r = null,
    isMask: o = !1,
    pdfFunctionFactory: c,
    globalColorSpaceCache: l,
    localColorSpaceCache: h
  }) {
    this.image = a;
    const f = a.dict, d = f.get("F", "Filter");
    let u;
    if (d instanceof Z)
      u = d.name;
    else if (Array.isArray(d)) {
      const m = e.fetchIfRef(d[0]);
      m instanceof Z && (u = m.name);
    }
    switch (u) {
      case "JPXDecode":
        ({
          width: a.width,
          height: a.height,
          componentsCount: a.numComps,
          bitsPerComponent: a.bitsPerComponent
        } = s0.parseImageProperties(a.stream)), a.stream.reset();
        const m = fn.getReducePowerForJPX(a.width, a.height, a.numComps);
        if (this.jpxDecoderOptions = {
          numComponents: 0,
          isIndexedColormap: !1,
          smaskInData: f.has("SMaskInData"),
          reducePower: m
        }, m) {
          const b = 2 ** m;
          a.width = Math.ceil(a.width / b), a.height = Math.ceil(a.height / b);
        }
        break;
      case "JBIG2Decode":
        a.bitsPerComponent = 1, a.numComps = 1;
        break;
    }
    let x = f.get("W", "Width"), g = f.get("H", "Height");
    if (Number.isInteger(a.width) && a.width > 0 && Number.isInteger(a.height) && a.height > 0 && (a.width !== x || a.height !== g))
      F("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), x = a.width, g = a.height;
    else {
      const m = typeof x == "number" && x > 0, b = typeof g == "number" && g > 0;
      if (!m || !b) {
        if (!a.fallbackDims)
          throw new W(`Invalid image width: ${x} or height: ${g}`);
        F("PDFImage - using the Width/Height of the parent image, for SMask/Mask data."), m || (x = a.fallbackDims.width), b || (g = a.fallbackDims.height);
      }
    }
    this.width = x, this.height = g, this.interpolate = f.get("I", "Interpolate"), this.imageMask = f.get("IM", "ImageMask") || !1, this.matte = f.get("Matte") || !1;
    let p = a.bitsPerComponent;
    if (!p && (p = f.get("BPC", "BitsPerComponent"), !p))
      if (this.imageMask)
        p = 1;
      else
        throw new W(`Bits per component missing in image: ${this.imageMask}`);
    if (this.bpc = p, !this.imageMask) {
      let m = f.getRaw("CS") || f.getRaw("ColorSpace");
      const b = !!m;
      if (b)
        this.jpxDecoderOptions?.smaskInData && (m = Z.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions)
        m = Z.get("DeviceRGBA");
      else
        switch (a.numComps) {
          case 1:
            m = Z.get("DeviceGray");
            break;
          case 3:
            m = Z.get("DeviceRGB");
            break;
          case 4:
            m = Z.get("DeviceCMYK");
            break;
          default:
            throw new Error(`Images with ${a.numComps} color components not supported.`);
        }
      this.colorSpace = Ye.parse({
        cs: m,
        xref: e,
        resources: i ? n : null,
        pdfFunctionFactory: c,
        globalColorSpaceCache: l,
        localColorSpaceCache: h
      }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = b ? this.numComps : 0, this.jpxDecoderOptions.isIndexedColormap = this.colorSpace.name === "Indexed");
    }
    if (this.decode = f.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, p) || o && !jt.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = !0;
      const m = (1 << p) - 1;
      this.decodeCoefficients = [], this.decodeAddends = [];
      const b = this.colorSpace?.name === "Indexed";
      for (let y = 0, w = 0; y < this.decode.length; y += 2, ++w) {
        const S = this.decode[y], v = this.decode[y + 1];
        this.decodeCoefficients[w] = b ? (v - S) / m : v - S, this.decodeAddends[w] = b ? S : m * S;
      }
    }
    s ? (s.fallbackDims ??= {
      width: x,
      height: g
    }, this.smask = new Ma({
      xref: e,
      res: n,
      image: s,
      isInline: i,
      pdfFunctionFactory: c,
      globalColorSpaceCache: l,
      localColorSpaceCache: h
    })) : r && (r instanceof Ne ? r.dict.get("IM", "ImageMask") ? (r.fallbackDims ??= {
      width: x,
      height: g
    }, this.mask = new Ma({
      xref: e,
      res: n,
      image: r,
      isInline: i,
      isMask: !0,
      pdfFunctionFactory: c,
      globalColorSpaceCache: l,
      localColorSpaceCache: h
    })) : F("Ignoring /Mask in image without /ImageMask.") : this.mask = r);
  }
  static async buildImage({
    xref: e,
    res: n,
    image: a,
    isInline: i = !1,
    pdfFunctionFactory: s,
    globalColorSpaceCache: r,
    localColorSpaceCache: o
  }) {
    const c = a;
    let l = null, h = null;
    const f = a.dict.get("SMask"), d = a.dict.get("Mask");
    return f ? f instanceof Ne ? l = f : F("Unsupported /SMask format.") : d && (d instanceof Ne || Array.isArray(d) ? h = d : F("Unsupported /Mask format.")), new Ma({
      xref: e,
      res: n,
      image: c,
      isInline: i,
      smask: l,
      mask: h,
      pdfFunctionFactory: s,
      globalColorSpaceCache: r,
      localColorSpaceCache: o
    });
  }
  static async createMask({
    image: e,
    isOffscreenCanvasSupported: n = !1
  }) {
    const {
      dict: a
    } = e, i = a.get("W", "Width"), s = a.get("H", "Height"), r = a.get("I", "Interpolate"), c = a.getArray("D", "Decode")?.[0] > 0, l = (i + 7 >> 3) * s, h = e.getBytes(l), f = i === 1 && s === 1 && c === (h.length === 0 || !!(h[0] & 128));
    if (f)
      return {
        isSingleOpaquePixel: f
      };
    if (n) {
      if (fn.needsToBeResized(i, s)) {
        const y = new Uint8ClampedArray(i * s * 4);
        return so({
          src: h,
          dest: y,
          width: i,
          height: s,
          nonBlackColor: 0,
          inverseDecode: c
        }), fn.createImage({
          kind: Nt.RGBA_32BPP,
          data: y,
          width: i,
          height: s,
          interpolate: r
        });
      }
      const g = new OffscreenCanvas(i, s), p = g.getContext("2d"), m = p.createImageData(i, s);
      so({
        src: h,
        dest: m.data,
        width: i,
        height: s,
        nonBlackColor: 0,
        inverseDecode: c
      }), p.putImageData(m, 0, 0);
      const b = g.transferToImageBitmap();
      return {
        data: null,
        width: i,
        height: s,
        interpolate: r,
        bitmap: b
      };
    }
    const d = h.byteLength, u = l === d;
    let x;
    if (e instanceof on && (!c || u) ? x = h : c ? (x = new Uint8Array(l), x.set(h), x.fill(255, d)) : x = new Uint8Array(h), c)
      for (let g = 0; g < d; g++)
        x[g] ^= 255;
    return {
      data: x,
      width: i,
      height: s,
      interpolate: r
    };
  }
  get drawWidth() {
    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
  }
  decodeBuffer(e) {
    const n = this.bpc, a = this.numComps, i = this.decodeAddends, s = this.decodeCoefficients, r = (1 << n) - 1;
    let o, c;
    if (n === 1) {
      for (o = 0, c = e.length; o < c; o++)
        e[o] = +!e[o];
      return;
    }
    let l = 0;
    for (o = 0, c = this.width * this.height; o < c; o++)
      for (let h = 0; h < a; h++)
        e[l] = Lt(i[h] + e[l] * s[h], 0, r), l++;
  }
  getComponents(e) {
    const n = this.bpc;
    if (n === 8)
      return e;
    const a = this.width, i = this.height, s = this.numComps, r = a * i * s;
    let o = 0, c;
    n <= 8 ? c = new Uint8Array(r) : n <= 16 ? c = new Uint16Array(r) : c = new Uint32Array(r);
    const l = a * s, h = (1 << n) - 1;
    let f = 0, d, u;
    if (n === 1) {
      let x, g, p;
      for (let m = 0; m < i; m++) {
        for (g = f + (l & -8), p = f + l; f < g; )
          u = e[o++], c[f] = u >> 7 & 1, c[f + 1] = u >> 6 & 1, c[f + 2] = u >> 5 & 1, c[f + 3] = u >> 4 & 1, c[f + 4] = u >> 3 & 1, c[f + 5] = u >> 2 & 1, c[f + 6] = u >> 1 & 1, c[f + 7] = u & 1, f += 8;
        if (f < p)
          for (u = e[o++], x = 128; f < p; )
            c[f++] = +!!(u & x), x >>= 1;
      }
    } else {
      let x = 0;
      for (u = 0, f = 0, d = r; f < d; ++f) {
        for (f % l === 0 && (u = 0, x = 0); x < n; )
          u = u << 8 | e[o++], x += 8;
        const g = x - n;
        let p = u >> g;
        p < 0 ? p = 0 : p > h && (p = h), c[f] = p, u &= (1 << g) - 1, x = g;
      }
    }
    return c;
  }
  async fillOpacity(e, n, a, i, s) {
    const r = this.smask, o = this.mask;
    let c, l, h, f, d, u;
    if (r)
      l = r.width, h = r.height, c = new Uint8ClampedArray(l * h), await r.fillGrayBuffer(c), (l !== n || h !== a) && (c = Al(c, r.bpc, l, h, n, a));
    else if (o)
      if (o instanceof Ma) {
        for (l = o.width, h = o.height, c = new Uint8ClampedArray(l * h), o.numComps = 1, await o.fillGrayBuffer(c), f = 0, d = l * h; f < d; ++f)
          c[f] = 255 - c[f];
        (l !== n || h !== a) && (c = Al(c, o.bpc, l, h, n, a));
      } else if (Array.isArray(o)) {
        c = new Uint8ClampedArray(n * a);
        const x = this.numComps;
        for (f = 0, d = n * a; f < d; ++f) {
          let g = 0;
          const p = f * x;
          for (u = 0; u < x; ++u) {
            const m = s[p + u], b = u * 2;
            if (m < o[b] || m > o[b + 1]) {
              g = 255;
              break;
            }
          }
          c[f] = g;
        }
      } else
        throw new W("Unknown mask format.");
    if (c)
      for (f = 0, u = 3, d = n * i; f < d; ++f, u += 4)
        e[u] = c[f];
    else
      for (f = 0, u = 3, d = n * i; f < d; ++f, u += 4)
        e[u] = 255;
  }
  undoPreblend(e, n, a) {
    const i = this.smask?.matte;
    if (!i)
      return;
    const s = this.colorSpace.getRgb(i, 0), r = s[0], o = s[1], c = s[2], l = n * a * 4;
    for (let h = 0; h < l; h += 4) {
      const f = e[h + 3];
      if (f === 0) {
        e[h] = 255, e[h + 1] = 255, e[h + 2] = 255;
        continue;
      }
      const d = 255 / f;
      e[h] = (e[h] - r) * d + r, e[h + 1] = (e[h + 1] - o) * d + o, e[h + 2] = (e[h + 2] - c) * d + c;
    }
  }
  async createImageData(e = !1, n = !1) {
    const a = this.drawWidth, i = this.drawHeight, s = {
      width: a,
      height: i,
      interpolate: this.interpolate,
      kind: 0,
      data: null
    }, r = this.numComps, o = this.width, c = this.height, l = this.bpc, h = o * r * l + 7 >> 3, f = n && fn.needsToBeResized(a, i);
    if (!this.smask && !this.mask && this.colorSpace.name === "DeviceRGBA") {
      s.kind = Nt.RGBA_32BPP;
      const S = s.data = await this.getImageBytes(c * o * 4, {});
      return n ? f ? fn.createImage(s, !1) : this.createBitmap(Nt.RGBA_32BPP, a, i, S) : s;
    }
    if (!e) {
      let S;
      if (this.colorSpace.name === "DeviceGray" && l === 1 ? S = Nt.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && l === 8 && !this.needsDecode && (S = Nt.RGB_24BPP), S && !this.smask && !this.mask && a === o && i === c) {
        const v = await this.#e(o, c);
        if (v)
          return v;
        const k = await this.getImageBytes(c * h, {});
        if (n)
          return f ? fn.createImage({
            data: k,
            kind: S,
            width: a,
            height: i,
            interpolate: this.interpolate
          }, this.needsDecode) : this.createBitmap(S, o, c, k);
        if (s.kind = S, s.data = k, this.needsDecode) {
          at(S === Nt.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
          const A = s.data;
          for (let C = 0, T = A.length; C < T; C++)
            A[C] ^= 255;
        }
        return s;
      }
      if (this.image instanceof Wi && !this.smask && !this.mask && !this.needsDecode) {
        let v = c * h;
        if (n && !f) {
          let k = !1;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              v *= 4, k = !0;
              break;
            case "DeviceRGB":
              v = v / 3 * 4, k = !0;
              break;
            case "DeviceCMYK":
              k = !0;
              break;
          }
          if (k) {
            const A = await this.#e(a, i);
            if (A)
              return A;
            const C = await this.getImageBytes(v, {
              drawWidth: a,
              drawHeight: i,
              forceRGBA: !0
            });
            return this.createBitmap(Nt.RGBA_32BPP, a, i, C);
          }
        } else
          switch (this.colorSpace.name) {
            case "DeviceGray":
              v *= 3;
            case "DeviceRGB":
            case "DeviceCMYK":
              return s.kind = Nt.RGB_24BPP, s.data = await this.getImageBytes(v, {
                drawWidth: a,
                drawHeight: i,
                forceRGB: !0
              }), f ? fn.createImage(s) : s;
          }
      }
    }
    const d = await this.getImageBytes(c * h, {
      internal: !0
    }), u = 0 | d.length / h * i / c, x = this.getComponents(d);
    let g, p, m, b, y, w;
    if (n && !f && (m = new OffscreenCanvas(a, i), b = m.getContext("2d"), y = b.createImageData(a, i), w = y.data), s.kind = Nt.RGBA_32BPP, !e && !this.smask && !this.mask ? (!n || f ? (s.kind = Nt.RGB_24BPP, w = new Uint8ClampedArray(a * i * 3), g = 0) : (new Uint32Array(w.buffer).fill(gn.isLittleEndian ? 4278190080 : 255), g = 1), p = !1) : ((!n || f) && (w = new Uint8ClampedArray(a * i * 4)), g = 1, p = !0, await this.fillOpacity(w, a, i, u, x)), this.needsDecode && this.decodeBuffer(x), this.colorSpace.fillRgb(w, o, c, a, i, u, l, x, g), p && this.undoPreblend(w, a, u), n && !f) {
      b.putImageData(y, 0, 0);
      const S = m.transferToImageBitmap();
      return {
        data: null,
        width: a,
        height: i,
        bitmap: S,
        interpolate: this.interpolate
      };
    }
    return s.data = w, f ? fn.createImage(s) : s;
  }
  async fillGrayBuffer(e) {
    const n = this.numComps;
    if (n !== 1)
      throw new W(`Reading gray scale from a color image: ${n}`);
    const a = this.width, i = this.height, s = this.bpc, r = a * n * s + 7 >> 3, o = await this.getImageBytes(i * r, {
      internal: !0
    }), c = this.getComponents(o);
    let l, h;
    if (s === 1) {
      if (h = a * i, this.needsDecode)
        for (l = 0; l < h; ++l)
          e[l] = c[l] - 1 & 255;
      else
        for (l = 0; l < h; ++l)
          e[l] = -c[l] & 255;
      return;
    }
    this.needsDecode && this.decodeBuffer(c), h = a * i;
    const f = 255 / ((1 << s) - 1);
    for (l = 0; l < h; ++l)
      e[l] = f * c[l];
  }
  createBitmap(e, n, a, i) {
    const s = new OffscreenCanvas(n, a), r = s.getContext("2d");
    let o;
    e === Nt.RGBA_32BPP ? o = new ImageData(i, n, a) : (o = r.createImageData(n, a), m1({
      kind: e,
      src: i,
      dest: new Uint32Array(o.data.buffer),
      width: n,
      height: a,
      inverseDecode: this.needsDecode
    })), r.putImageData(o, 0, 0);
    const c = s.transferToImageBitmap();
    return {
      data: null,
      width: n,
      height: a,
      bitmap: c,
      interpolate: this.interpolate
    };
  }
  async #e(e, n) {
    const a = await this.image.getTransferableImage();
    return a ? {
      data: null,
      width: e,
      height: n,
      bitmap: a,
      interpolate: this.interpolate
    } : null;
  }
  async getImageBytes(e, {
    drawWidth: n,
    drawHeight: a,
    forceRGBA: i = !1,
    forceRGB: s = !1,
    internal: r = !1
  }) {
    this.image.reset(), this.image.drawWidth = n || this.width, this.image.drawHeight = a || this.height, this.image.forceRGBA = !!i, this.image.forceRGB = !!s;
    const o = await this.image.getImageData(e, this.jpxDecoderOptions);
    return r || this.image instanceof on ? o : (at(o instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(o));
  }
}
const lx = Object.freeze({
  maxImageSize: -1,
  disableFontFace: !1,
  ignoreErrors: !1,
  isEvalSupported: !0,
  isOffscreenCanvasSupported: !1,
  isImageDecoderSupported: !1,
  canvasMaxAreaInBytes: -1,
  fontExtraProperties: !1,
  useSystemFonts: !0,
  useWasm: !0,
  useWorkerFetch: !0,
  cMapUrl: null,
  iccUrl: null,
  standardFontDataUrl: null,
  wasmUrl: null
}), Cl = {
  TILING: 1,
  SHADING: 2
}, hx = 10, Il = Promise.resolve();
function _1(t, e = !1) {
  if (Array.isArray(t)) {
    for (const n of t) {
      const a = _1(n, !0);
      if (a)
        return a;
    }
    return F(`Unsupported blend mode Array: ${t}`), "source-over";
  }
  if (!(t instanceof Z))
    return e ? null : "source-over";
  switch (t.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return e ? null : (F(`Unsupported blend mode: ${t.name}`), "source-over");
}
function L0(t, {
  objId: e,
  fn: n,
  args: a,
  optionalContent: i,
  hasMask: s
}) {
  e && t.addDependency(e), t.addImageOps(n, a, i, s), n === I.paintImageMaskXObject && a[0]?.count > 0 && a[0].count++;
}
class js {
  static TIME_SLOT_DURATION_MS = 20;
  static CHECK_TIME_EVERY = 100;
  constructor() {
    this.reset();
  }
  check() {
    return ++this.checked < js.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
  }
  reset() {
    this.endTime = Date.now() + js.TIME_SLOT_DURATION_MS, this.checked = 0;
  }
}
class Ui {
  constructor({
    xref: e,
    handler: n,
    pageIndex: a,
    idFactory: i,
    fontCache: s,
    builtInCMapCache: r,
    standardFontDataCache: o,
    globalColorSpaceCache: c,
    globalImageCache: l,
    systemFontCache: h,
    options: f = null
  }) {
    this.xref = e, this.handler = n, this.pageIndex = a, this.idFactory = i, this.fontCache = s, this.builtInCMapCache = r, this.standardFontDataCache = o, this.globalColorSpaceCache = c, this.globalImageCache = l, this.systemFontCache = h, this.options = f || lx, this.type3FontRefs = null, this._regionalImageCache = new V2(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
  }
  get _pdfFunctionFactory() {
    const e = new G1({
      xref: this.xref,
      isEvalSupported: this.options.isEvalSupported
    });
    return ae(this, "_pdfFunctionFactory", e);
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(e = null) {
    const n = Object.create(this);
    return n.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e), n;
  }
  hasBlendModes(e, n) {
    if (!(e instanceof B) || e.objId && n.has(e.objId))
      return !1;
    const a = new St(n);
    e.objId && a.put(e.objId);
    const i = [e], s = this.xref;
    for (; i.length; ) {
      const r = i.shift(), o = r.get("ExtGState");
      if (o instanceof B)
        for (let l of o.getRawValues()) {
          if (l instanceof le) {
            if (a.has(l))
              continue;
            try {
              l = s.fetch(l);
            } catch (f) {
              a.put(l), Ue(`hasBlendModes - ignoring ExtGState: "${f}".`);
              continue;
            }
          }
          if (!(l instanceof B))
            continue;
          l.objId && a.put(l.objId);
          const h = l.get("BM");
          if (h instanceof Z) {
            if (h.name !== "Normal")
              return !0;
            continue;
          }
          if (h !== void 0 && Array.isArray(h)) {
            for (const f of h)
              if (f instanceof Z && f.name !== "Normal")
                return !0;
          }
        }
      const c = r.get("XObject");
      if (c instanceof B)
        for (let l of c.getRawValues()) {
          if (l instanceof le) {
            if (a.has(l))
              continue;
            try {
              l = s.fetch(l);
            } catch (f) {
              a.put(l), Ue(`hasBlendModes - ignoring XObject: "${f}".`);
              continue;
            }
          }
          if (!(l instanceof Ne))
            continue;
          l.dict.objId && a.put(l.dict.objId);
          const h = l.dict.get("Resources");
          h instanceof B && (h.objId && a.has(h.objId) || (i.push(h), h.objId && a.put(h.objId)));
        }
    }
    for (const r of a)
      n.put(r);
    return !1;
  }
  async fetchBuiltInCMap(e) {
    const n = this.builtInCMapCache.get(e);
    if (n)
      return n;
    let a;
    return this.options.useWorkerFetch ? a = {
      cMapData: await to(`${this.options.cMapUrl}${e}.bcmap`),
      isCompressed: !0
    } : a = await this.handler.sendWithPromise("FetchBinaryData", {
      type: "cMapReaderFactory",
      name: e
    }), this.builtInCMapCache.set(e, a), a;
  }
  async fetchStandardFontData(e) {
    const n = this.standardFontDataCache.get(e);
    if (n)
      return new pt(n);
    if (this.options.useSystemFonts && e !== "Symbol" && e !== "ZapfDingbats")
      return null;
    const a = ud(), i = a[e];
    let s;
    try {
      this.options.useWorkerFetch ? s = await to(`${this.options.standardFontDataUrl}${i}`) : s = await this.handler.sendWithPromise("FetchBinaryData", {
        type: "standardFontDataFactory",
        filename: i
      });
    } catch (r) {
      return F(r), null;
    }
    return this.standardFontDataCache.set(e, s), new pt(s);
  }
  async buildFormXObject(e, n, a, i, s, r, o, c) {
    const {
      dict: l
    } = n, h = Fa(l.getArray("Matrix"), null), f = ma(l.getArray("BBox"), null);
    let d, u;
    l.has("OC") && (d = await this.parseMarkedContentProps(l.get("OC"), e)), d !== void 0 && i.addOp(I.beginMarkedContentProps, ["OC", d]);
    const x = l.get("Group");
    if (x) {
      u = {
        matrix: h,
        bbox: f,
        smask: a,
        isolated: !1,
        knockout: !1
      };
      const y = x.get("S");
      let w = null;
      if (dt(y, "Transparency") && (u.isolated = x.get("I") || !1, u.knockout = x.get("K") || !1, x.has("CS"))) {
        const S = this._getColorSpace(x.getRaw("CS"), e, o);
        w = S instanceof jt ? S : await this._handleColorSpace(S);
      }
      a?.backdrop && (w ||= Ye.rgb, a.backdrop = w.getRgbHex(a.backdrop, 0)), i.addOp(I.beginGroup, [u]);
    }
    const g = h && new Float32Array(h), p = !x && f && new Float32Array(f) || null, m = [g, p];
    i.addOp(I.paintFormXObjectBegin, m);
    const b = l.get("Resources");
    await this.getOperatorList({
      stream: n,
      task: s,
      resources: b instanceof B ? b : e,
      operatorList: i,
      initialState: r,
      prevRefs: c
    }), i.addOp(I.paintFormXObjectEnd, []), x && i.addOp(I.endGroup, [u]), d !== void 0 && i.addOp(I.endMarkedContent, []);
  }
  _sendImgData(e, n, a = !1) {
    const i = n ? [n.bitmap || n.data.buffer] : null;
    return this.parsingType3Font || a ? this.handler.send("commonobj", [e, "Image", n], i) : this.handler.send("obj", [e, this.pageIndex, "Image", n], i);
  }
  async buildPaintImageXObject({
    resources: e,
    image: n,
    isInline: a = !1,
    operatorList: i,
    cacheKey: s,
    localImageCache: r,
    localColorSpaceCache: o
  }) {
    const {
      maxImageSize: c,
      ignoreErrors: l,
      isOffscreenCanvasSupported: h
    } = this.options, {
      dict: f
    } = n, d = f.objId, u = f.get("W", "Width"), x = f.get("H", "Height");
    if (!(u && typeof u == "number") || !(x && typeof x == "number")) {
      F("Image dimensions are missing, or not numbers.");
      return;
    }
    if (c !== -1 && u * x > c) {
      const C = "Image exceeded maximum allowed size and was removed.";
      if (!l)
        throw new Error(C);
      F(C);
      return;
    }
    let g;
    f.has("OC") && (g = await this.parseMarkedContentProps(f.get("OC"), e));
    const p = f.get("IM", "ImageMask") || !1;
    let m, b, y;
    if (p) {
      if (m = await Ma.createMask({
        image: n,
        isOffscreenCanvasSupported: h && !this.parsingType3Font
      }), m.isSingleOpaquePixel) {
        if (b = I.paintSolidColorImageMask, y = [], i.addImageOps(b, y, g), s) {
          const T = {
            fn: b,
            args: y,
            optionalContent: g
          };
          r.set(s, d, T), d && this._regionalImageCache.set(null, d, T);
        }
        return;
      }
      if (this.parsingType3Font) {
        if (y = nd(m), y) {
          i.addImageOps(I.constructPath, y, g);
          return;
        }
        F("Cannot compile Type3 glyph."), i.addImageOps(I.paintImageMaskXObject, [m], g);
        return;
      }
      const C = `mask_${this.idFactory.createObjId()}`;
      if (i.addDependency(C), m.dataLen = m.bitmap ? m.width * m.height * 4 : m.data.length, this._sendImgData(C, m), b = I.paintImageMaskXObject, y = [{
        data: C,
        width: m.width,
        height: m.height,
        interpolate: m.interpolate,
        count: 1
      }], i.addImageOps(b, y, g), s) {
        const T = {
          objId: C,
          fn: b,
          args: y,
          optionalContent: g
        };
        r.set(s, d, T), d && this._regionalImageCache.set(null, d, T);
      }
      return;
    }
    const w = 200, S = f.has("SMask") || f.has("Mask");
    if (a && u + x < w && !S) {
      try {
        m = await new Ma({
          xref: this.xref,
          res: e,
          image: n,
          isInline: a,
          pdfFunctionFactory: this._pdfFunctionFactory,
          globalColorSpaceCache: this.globalColorSpaceCache,
          localColorSpaceCache: o
        }).createImageData(!0, !1), i.addImageOps(I.paintInlineImageXObject, [m], g);
      } catch (C) {
        const T = `Unable to decode inline image: "${C}".`;
        if (!l)
          throw new Error(T);
        F(T);
      }
      return;
    }
    let v = `img_${this.idFactory.createObjId()}`, k = !1, A = null;
    if (this.parsingType3Font ? v = `${this.idFactory.getDocId()}_type3_${v}` : s && d && (k = this.globalImageCache.shouldCache(d, this.pageIndex), k && (at(!a, "Cannot cache an inline image globally."), v = `${this.idFactory.getDocId()}_${v}`)), i.addDependency(v), b = I.paintImageXObject, y = [v, u, x], i.addImageOps(b, y, g, S), k) {
      if (A = {
        objId: v,
        fn: b,
        args: y,
        optionalContent: g,
        hasMask: S,
        byteSize: 0
      }, this.globalImageCache.hasDecodeFailed(d)) {
        this.globalImageCache.setData(d, A), this._sendImgData(v, null, k);
        return;
      }
      if (u * x > 25e4 || S) {
        const C = await this.handler.sendWithPromise("commonobj", [v, "CopyLocalImage", {
          imageRef: d
        }]);
        if (C) {
          this.globalImageCache.setData(d, A), this.globalImageCache.addByteSize(d, C);
          return;
        }
      }
    }
    if (Ma.buildImage({
      xref: this.xref,
      res: e,
      image: n,
      isInline: a,
      pdfFunctionFactory: this._pdfFunctionFactory,
      globalColorSpaceCache: this.globalColorSpaceCache,
      localColorSpaceCache: o
    }).then(async (C) => (m = await C.createImageData(!1, h), m.dataLen = m.bitmap ? m.width * m.height * 4 : m.data.length, m.ref = d, k && this.globalImageCache.addByteSize(d, m.dataLen), this._sendImgData(v, m, k))).catch((C) => (F(`Unable to decode image "${v}": "${C}".`), d && this.globalImageCache.addDecodeFailed(d), this._sendImgData(v, null, k))), s) {
      const C = {
        objId: v,
        fn: b,
        args: y,
        optionalContent: g,
        hasMask: S
      };
      r.set(s, d, C), d && (this._regionalImageCache.set(null, d, C), k && (at(A, "The global cache-data must be available."), this.globalImageCache.setData(d, A)));
    }
  }
  handleSMask(e, n, a, i, s, r, o) {
    const c = e.get("G"), l = {
      subtype: e.get("S").name,
      backdrop: e.get("BC")
    }, h = e.get("TR");
    if (N0(h)) {
      const f = this._pdfFunctionFactory.create(h), d = new Uint8Array(256), u = new Float32Array(1);
      for (let x = 0; x < 256; x++)
        u[0] = x / 255, f(u, 0, u, 0), d[x] = u[0] * 255 | 0;
      l.transferMap = d;
    }
    return this.buildFormXObject(n, c, l, a, i, s.state.clone({
      newPath: !0
    }), r, o);
  }
  handleTransferFunction(e) {
    let n;
    if (Array.isArray(e))
      n = e;
    else if (N0(e))
      n = [e];
    else
      return null;
    const a = [];
    let i = 0, s = 0;
    for (const r of n) {
      const o = this.xref.fetchIfRef(r);
      if (i++, dt(o, "Identity")) {
        a.push(null);
        continue;
      } else if (!N0(o))
        return null;
      const c = this._pdfFunctionFactory.create(o), l = new Uint8Array(256), h = new Float32Array(1);
      for (let f = 0; f < 256; f++)
        h[0] = f / 255, c(h, 0, h, 0), l[f] = h[0] * 255 | 0;
      a.push(l), s++;
    }
    return !(i === 1 || i === 4) || s === 0 ? null : a;
  }
  handleTilingType(e, n, a, i, s, r, o, c) {
    const l = new Ht(), h = B.merge({
      xref: this.xref,
      dictArray: [s.get("Resources"), a]
    });
    return this.getOperatorList({
      stream: i,
      task: o,
      resources: h,
      operatorList: l
    }).then(function() {
      const f = l.getIR(), d = ul(f, s, n);
      r.addDependencies(l.dependencies), r.addOp(e, d), s.objId && c.set(null, s.objId, {
        operatorListIR: f,
        dict: s
      });
    }).catch((f) => {
      if (!(f instanceof _t)) {
        if (this.options.ignoreErrors) {
          F(`handleTilingType - ignoring pattern: "${f}".`);
          return;
        }
        throw f;
      }
    });
  }
  async handleSetFont(e, n, a, i, s, r, o = null, c = null) {
    const l = n?.[0] instanceof Z ? n[0].name : null, h = await this.loadFont(l, a, e, s, o, c);
    return h.font.isType3Font && i.addDependencies(h.type3Dependencies), r.font = h.font, h.send(this.handler), h.loadedName;
  }
  handleText(e, n) {
    const a = n.font, i = a.charsToGlyphs(e);
    return a.data && (n.textRenderingMode & e1.ADD_TO_PATH_FLAG || n.fillColorSpace.name === "Pattern" || a.disableFontFace) && Ui.buildFontPaths(a, i, this.handler, this.options), i;
  }
  ensureStateFont(e) {
    if (e.font)
      return;
    const n = new W("Missing setFont (Tf) operator before text rendering operator.");
    if (this.options.ignoreErrors) {
      F(`ensureStateFont: "${n}".`);
      return;
    }
    throw n;
  }
  async setGState({
    resources: e,
    gState: n,
    operatorList: a,
    cacheKey: i,
    task: s,
    stateManager: r,
    localGStateCache: o,
    localColorSpaceCache: c,
    seenRefs: l
  }) {
    const h = n.objId;
    let f = !0;
    const d = [];
    let u = Promise.resolve();
    for (const [x, g] of n)
      switch (x) {
        case "Type":
          break;
        case "LW":
          if (typeof g != "number") {
            F(`Invalid LW (line width): ${g}`);
            break;
          }
          d.push([x, Math.abs(g)]);
          break;
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          d.push([x, g]);
          break;
        case "Font":
          f = !1, u = u.then(() => this.handleSetFont(e, null, g[0], a, s, r.state).then(function(m) {
            a.addDependency(m), d.push([x, [m, g[1]]]);
          }));
          break;
        case "BM":
          d.push([x, _1(g)]);
          break;
        case "SMask":
          if (dt(g, "None")) {
            d.push([x, !1]);
            break;
          }
          g instanceof B ? (f = !1, u = u.then(() => this.handleSMask(g, e, a, s, r, c, l)), d.push([x, !0])) : F("Unsupported SMask type");
          break;
        case "TR":
          const p = this.handleTransferFunction(g);
          d.push([x, p]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          Ue("graphic state operator " + x);
          break;
        default:
          Ue("Unknown graphic state operator " + x);
          break;
      }
    await u, d.length > 0 && a.addOp(I.setGState, [d]), f && o.set(i, h, d);
  }
  loadFont(e, n, a, i, s = null, r = null) {
    const o = async () => new U0({
      loadedName: "g_font_error",
      font: new hl(`Font "${e}" is not available.`),
      dict: n
    });
    let c;
    if (n)
      n instanceof le && (c = n);
    else {
      const p = a.get("Font");
      p && (c = p.getRaw(e));
    }
    if (c) {
      if (this.type3FontRefs?.has(c))
        return o();
      if (this.fontCache.has(c))
        return this.fontCache.get(c);
      try {
        n = this.xref.fetchIfRef(c);
      } catch (p) {
        F(`loadFont - lookup failed: "${p}".`);
      }
    }
    if (!(n instanceof B)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font)
        return F(`Font "${e}" is not available.`), o();
      F(`Font "${e}" is not available -- attempting to fallback to a default font.`), n = s || Ui.fallbackFontDict;
    }
    if (n.cacheKey && this.fontCache.has(n.cacheKey))
      return this.fontCache.get(n.cacheKey);
    const {
      promise: l,
      resolve: h
    } = Promise.withResolvers();
    let f;
    try {
      f = this.preEvaluateFont(n), f.cssFontInfo = r;
    } catch (p) {
      return F(`loadFont - preEvaluateFont failed: "${p}".`), o();
    }
    const {
      descriptor: d,
      hash: u
    } = f, x = c instanceof le;
    let g;
    if (u && d instanceof B) {
      const p = d.fontAliases ||= /* @__PURE__ */ Object.create(null);
      if (p[u]) {
        const m = p[u].aliasRef;
        if (x && m && this.fontCache.has(m))
          return this.fontCache.putAlias(c, m), this.fontCache.get(c);
      } else
        p[u] = {
          fontID: this.idFactory.createFontId()
        };
      x && (p[u].aliasRef = c), g = p[u].fontID;
    } else
      g = this.idFactory.createFontId();
    return at(g?.startsWith("f"), 'The "fontID" must be (correctly) defined.'), x ? this.fontCache.put(c, l) : (n.cacheKey = `cacheKey_${g}`, this.fontCache.put(n.cacheKey, l)), n.loadedName = `${this.idFactory.getDocId()}_${g}`, this.translateFont(f).then(async (p) => {
      const m = new U0({
        loadedName: n.loadedName,
        font: p,
        dict: n
      });
      if (p.isType3Font)
        try {
          await m.loadType3Data(this, a, i);
        } catch (b) {
          throw new Error(`Type3 font load error: ${b}`);
        }
      h(m);
    }).catch((p) => {
      F(`loadFont - translateFont failed: "${p}".`), h(new U0({
        loadedName: n.loadedName,
        font: new hl(p?.message),
        dict: n
      }));
    }), l;
  }
  buildPath(e, n, a) {
    const {
      pathMinMax: i,
      pathBuffer: s
    } = a;
    switch (e | 0) {
      case I.rectangle: {
        const r = a.currentPointX = n[0], o = a.currentPointY = n[1], c = n[2], l = n[3], h = r + c, f = o + l;
        c === 0 || l === 0 ? s.push(Et.moveTo, r, o, Et.lineTo, h, f, Et.closePath) : s.push(Et.moveTo, r, o, Et.lineTo, h, o, Et.lineTo, h, f, Et.lineTo, r, f, Et.closePath), Je.rectBoundingBox(r, o, h, f, i);
        break;
      }
      case I.moveTo: {
        const r = a.currentPointX = n[0], o = a.currentPointY = n[1];
        s.push(Et.moveTo, r, o), Je.pointBoundingBox(r, o, i);
        break;
      }
      case I.lineTo: {
        const r = a.currentPointX = n[0], o = a.currentPointY = n[1];
        s.push(Et.lineTo, r, o), Je.pointBoundingBox(r, o, i);
        break;
      }
      case I.curveTo: {
        const r = a.currentPointX, o = a.currentPointY, [c, l, h, f, d, u] = n;
        a.currentPointX = d, a.currentPointY = u, s.push(Et.curveTo, c, l, h, f, d, u), Je.bezierBoundingBox(r, o, c, l, h, f, d, u, i);
        break;
      }
      case I.curveTo2: {
        const r = a.currentPointX, o = a.currentPointY, [c, l, h, f] = n;
        a.currentPointX = h, a.currentPointY = f, s.push(Et.curveTo, r, o, c, l, h, f), Je.bezierBoundingBox(r, o, r, o, c, l, h, f, i);
        break;
      }
      case I.curveTo3: {
        const r = a.currentPointX, o = a.currentPointY, [c, l, h, f] = n;
        a.currentPointX = h, a.currentPointY = f, s.push(Et.curveTo, c, l, h, f, h, f), Je.bezierBoundingBox(r, o, c, l, h, f, h, f, i);
        break;
      }
      case I.closePath:
        s.push(Et.closePath);
        break;
    }
  }
  _getColorSpace(e, n, a) {
    return Ye.parse({
      cs: e,
      xref: this.xref,
      resources: n,
      pdfFunctionFactory: this._pdfFunctionFactory,
      globalColorSpaceCache: this.globalColorSpaceCache,
      localColorSpaceCache: a,
      asyncIfNotCached: !0
    });
  }
  async _handleColorSpace(e) {
    try {
      return await e;
    } catch (n) {
      if (n instanceof _t)
        return null;
      if (this.options.ignoreErrors)
        return F(`_handleColorSpace - ignoring ColorSpace: "${n}".`), null;
      throw n;
    }
  }
  parseShading({
    shading: e,
    resources: n,
    localColorSpaceCache: a,
    localShadingPatternCache: i
  }) {
    let s = i.get(e);
    if (s)
      return s;
    let r;
    try {
      r = n2.parseShading(e, this.xref, n, this._pdfFunctionFactory, this.globalColorSpaceCache, a).getIR();
    } catch (o) {
      if (o instanceof _t)
        return null;
      if (this.options.ignoreErrors)
        return F(`parseShading - ignoring shading: "${o}".`), i.set(e, null), null;
      throw o;
    }
    return s = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (s = `${this.idFactory.getDocId()}_type3_${s}`), i.set(e, s), this.parsingType3Font ? this.handler.send("commonobj", [s, "Pattern", r]) : this.handler.send("obj", [s, this.pageIndex, "Pattern", r]), s;
  }
  handleColorN(e, n, a, i, s, r, o, c, l, h) {
    const f = a.pop();
    if (f instanceof Z) {
      const d = s.getRaw(f.name), u = d instanceof le && l.getByRef(d);
      if (u)
        try {
          const g = i.base ? i.base.getRgbHex(a, 0) : null, p = ul(u.operatorListIR, u.dict, g);
          e.addOp(n, p);
          return;
        } catch {
        }
      const x = this.xref.fetchIfRef(d);
      if (x) {
        const g = x instanceof Ne ? x.dict : x, p = g.get("PatternType");
        if (p === Cl.TILING) {
          const m = i.base ? i.base.getRgbHex(a, 0) : null;
          return this.handleTilingType(n, m, r, x, g, e, o, l);
        } else if (p === Cl.SHADING) {
          const m = g.get("Shading"), b = this.parseShading({
            shading: m,
            resources: r,
            localColorSpaceCache: c,
            localShadingPatternCache: h
          });
          if (b) {
            const y = Fa(g.getArray("Matrix"), null);
            e.addOp(n, ["Shading", b, y]);
          }
          return;
        }
        throw new W(`Unknown PatternType: ${p}`);
      }
    }
    throw new W(`Unknown PatternName: ${f}`);
  }
  _parseVisibilityExpression(e, n, a) {
    if (++n > 10) {
      F("Visibility expression is too deeply nested");
      return;
    }
    const s = e.length, r = this.xref.fetchIfRef(e[0]);
    if (s < 2 || !(r instanceof Z)) {
      F("Invalid visibility expression");
      return;
    }
    switch (r.name) {
      case "And":
      case "Or":
      case "Not":
        a.push(r.name);
        break;
      default:
        F(`Invalid operator ${r.name} in visibility expression`);
        return;
    }
    for (let o = 1; o < s; o++) {
      const c = e[o], l = this.xref.fetchIfRef(c);
      if (Array.isArray(l)) {
        const h = [];
        a.push(h), this._parseVisibilityExpression(l, n, h);
      } else c instanceof le && a.push(c.toString());
    }
  }
  async parseMarkedContentProps(e, n) {
    let a;
    if (e instanceof Z)
      a = n.get("Properties").get(e.name);
    else if (e instanceof B)
      a = e;
    else
      throw new W("Optional content properties malformed.");
    const i = a.get("Type")?.name;
    if (i === "OCG")
      return {
        type: i,
        id: a.objId
      };
    if (i === "OCMD") {
      const s = a.get("VE");
      if (Array.isArray(s)) {
        const o = [];
        if (this._parseVisibilityExpression(s, 0, o), o.length > 0)
          return {
            type: "OCMD",
            expression: o
          };
      }
      const r = a.get("OCGs");
      if (Array.isArray(r) || r instanceof B) {
        const o = [];
        if (Array.isArray(r))
          for (const c of r)
            o.push(c.toString());
        else
          o.push(r.objId);
        return {
          type: i,
          ids: o,
          policy: a.get("P") instanceof Z ? a.get("P").name : null,
          expression: null
        };
      } else if (r instanceof le)
        return {
          type: i,
          id: r.toString()
        };
    }
    return null;
  }
  getOperatorList({
    stream: e,
    task: n,
    resources: a,
    operatorList: i,
    initialState: s = null,
    fallbackFontDict: r = null,
    prevRefs: o = null
  }) {
    const c = e.dict?.objId, l = new St(o);
    if (c) {
      if (o?.has(c))
        throw new Error(`getOperatorList - ignoring circular reference: ${c}`);
      l.put(c);
    }
    if (a ||= B.empty, s ||= new W1(), !i)
      throw new Error('getOperatorList: missing "operatorList" parameter');
    const h = this, f = this.xref, d = new dl(), u = new $1(), x = new xl(), g = new W2(), p = /* @__PURE__ */ new Map(), m = a.get("XObject") || B.empty, b = a.get("Pattern") || B.empty, y = new Or(s), w = new Da(e, f, y), S = new js();
    function v(k) {
      for (let A = 0, C = w.savedStatesDepth; A < C; A++)
        i.addOp(I.restore, []);
    }
    return new Promise(function k(A, C) {
      const T = function(P) {
        Promise.all([P, i.ready]).then(function() {
          try {
            k(A, C);
          } catch (K) {
            C(K);
          }
        }, C);
      };
      n.ensureNotTerminated(), S.reset();
      const M = {};
      let O, N, H, J, U, j;
      for (; !(O = S.check()) && (M.args = null, !!w.read(M)); ) {
        let P = M.args, K = M.fn;
        switch (K | 0) {
          case I.paintXObject:
            if (j = P[0] instanceof Z, U = P[0].name, j) {
              const R = d.getByName(U);
              if (R) {
                L0(i, R), P = null;
                continue;
              }
            }
            T(new Promise(function(R, L) {
              if (!j)
                throw new W("XObject must be referred to by name.");
              let V = m.getRaw(U);
              if (V instanceof le) {
                const te = d.getByRef(V) || h._regionalImageCache.getByRef(V) || h.globalImageCache.getData(V, h.pageIndex);
                if (te) {
                  L0(i, te), R();
                  return;
                }
                V = f.fetch(V);
              }
              if (!(V instanceof Ne))
                throw new W("XObject should be a stream");
              const he = V.dict.get("Subtype");
              if (!(he instanceof Z))
                throw new W("XObject should have a Name subtype");
              if (he.name === "Form") {
                y.save(), h.buildFormXObject(a, V, null, i, n, y.state.clone({
                  newPath: !0
                }), u, l).then(function() {
                  y.restore(), R();
                }, L);
                return;
              } else if (he.name === "Image") {
                h.buildPaintImageXObject({
                  resources: a,
                  image: V,
                  operatorList: i,
                  cacheKey: U,
                  localImageCache: d,
                  localColorSpaceCache: u
                }).then(R, L);
                return;
              } else if (he.name === "PS")
                Ue("Ignored XObject subtype PS");
              else
                throw new W(`Unhandled XObject subtype ${he.name}`);
              R();
            }).catch(function(R) {
              if (!(R instanceof _t)) {
                if (h.options.ignoreErrors) {
                  F(`getOperatorList - ignoring XObject: "${R}".`);
                  return;
                }
                throw R;
              }
            }));
            return;
          case I.setFont:
            const xe = P[1];
            T(h.handleSetFont(a, P, null, i, n, y.state, r).then(function(R) {
              i.addDependency(R), i.addOp(I.setFont, [R, xe]);
            }));
            return;
          case I.endInlineImage:
            const X = P[0].cacheKey;
            if (X) {
              const R = d.getByName(X);
              if (R) {
                L0(i, R), P = null;
                continue;
              }
            }
            T(h.buildPaintImageXObject({
              resources: a,
              image: P[0],
              isInline: !0,
              operatorList: i,
              cacheKey: X,
              localImageCache: d,
              localColorSpaceCache: u
            }));
            return;
          case I.showText:
            if (!y.state.font) {
              h.ensureStateFont(y.state);
              continue;
            }
            P[0] = h.handleText(P[0], y.state);
            break;
          case I.showSpacedText:
            if (!y.state.font) {
              h.ensureStateFont(y.state);
              continue;
            }
            const ye = [], we = y.state;
            for (const R of P[0])
              typeof R == "string" ? ye.push(...h.handleText(R, we)) : typeof R == "number" && ye.push(R);
            P[0] = ye, K = I.showText;
            break;
          case I.nextLineShowText:
            if (!y.state.font) {
              h.ensureStateFont(y.state);
              continue;
            }
            i.addOp(I.nextLine), P[0] = h.handleText(P[0], y.state), K = I.showText;
            break;
          case I.nextLineSetSpacingShowText:
            if (!y.state.font) {
              h.ensureStateFont(y.state);
              continue;
            }
            i.addOp(I.nextLine), i.addOp(I.setWordSpacing, [P.shift()]), i.addOp(I.setCharSpacing, [P.shift()]), P[0] = h.handleText(P[0], y.state), K = I.showText;
            break;
          case I.setTextRenderingMode:
            y.state.textRenderingMode = P[0];
            break;
          case I.setFillColorSpace: {
            const R = h._getColorSpace(P[0], a, u);
            if (R instanceof jt) {
              y.state.fillColorSpace = R;
              continue;
            }
            T(h._handleColorSpace(R).then((L) => {
              y.state.fillColorSpace = L || Ye.gray;
            }));
            return;
          }
          case I.setStrokeColorSpace: {
            const R = h._getColorSpace(P[0], a, u);
            if (R instanceof jt) {
              y.state.strokeColorSpace = R;
              continue;
            }
            T(h._handleColorSpace(R).then((L) => {
              y.state.strokeColorSpace = L || Ye.gray;
            }));
            return;
          }
          case I.setFillColor:
            J = y.state.fillColorSpace, P = [J.getRgbHex(P, 0)], K = I.setFillRGBColor;
            break;
          case I.setStrokeColor:
            J = y.state.strokeColorSpace, P = [J.getRgbHex(P, 0)], K = I.setStrokeRGBColor;
            break;
          case I.setFillGray:
            y.state.fillColorSpace = Ye.gray, P = [Ye.gray.getRgbHex(P, 0)], K = I.setFillRGBColor;
            break;
          case I.setStrokeGray:
            y.state.strokeColorSpace = Ye.gray, P = [Ye.gray.getRgbHex(P, 0)], K = I.setStrokeRGBColor;
            break;
          case I.setFillCMYKColor:
            y.state.fillColorSpace = Ye.cmyk, P = [Ye.cmyk.getRgbHex(P, 0)], K = I.setFillRGBColor;
            break;
          case I.setStrokeCMYKColor:
            y.state.strokeColorSpace = Ye.cmyk, P = [Ye.cmyk.getRgbHex(P, 0)], K = I.setStrokeRGBColor;
            break;
          case I.setFillRGBColor:
            y.state.fillColorSpace = Ye.rgb, P = [Ye.rgb.getRgbHex(P, 0)];
            break;
          case I.setStrokeRGBColor:
            y.state.strokeColorSpace = Ye.rgb, P = [Ye.rgb.getRgbHex(P, 0)];
            break;
          case I.setFillColorN:
            if (J = y.state.patternFillColorSpace, !J) {
              if (an(P, null)) {
                P = [Ye.gray.getRgbHex(P, 0)], K = I.setFillRGBColor;
                break;
              }
              P = [], K = I.setFillTransparent;
              break;
            }
            if (J.name === "Pattern") {
              T(h.handleColorN(i, I.setFillColorN, P, J, b, a, n, u, g, p));
              return;
            }
            P = [J.getRgbHex(P, 0)], K = I.setFillRGBColor;
            break;
          case I.setStrokeColorN:
            if (J = y.state.patternStrokeColorSpace, !J) {
              if (an(P, null)) {
                P = [Ye.gray.getRgbHex(P, 0)], K = I.setStrokeRGBColor;
                break;
              }
              P = [], K = I.setStrokeTransparent;
              break;
            }
            if (J.name === "Pattern") {
              T(h.handleColorN(i, I.setStrokeColorN, P, J, b, a, n, u, g, p));
              return;
            }
            P = [J.getRgbHex(P, 0)], K = I.setStrokeRGBColor;
            break;
          case I.shadingFill:
            let D;
            try {
              const R = a.get("Shading");
              if (!R)
                throw new W("No shading resource found");
              if (D = R.get(P[0].name), !D)
                throw new W("No shading object found");
            } catch (R) {
              if (R instanceof _t)
                continue;
              if (h.options.ignoreErrors) {
                F(`getOperatorList - ignoring Shading: "${R}".`);
                continue;
              }
              throw R;
            }
            const G = h.parseShading({
              shading: D,
              resources: a,
              localColorSpaceCache: u,
              localShadingPatternCache: p
            });
            if (!G)
              continue;
            P = [G], K = I.shadingFill;
            break;
          case I.setGState:
            if (j = P[0] instanceof Z, U = P[0].name, j) {
              const R = x.getByName(U);
              if (R) {
                R.length > 0 && i.addOp(I.setGState, [R]), P = null;
                continue;
              }
            }
            T(new Promise(function(R, L) {
              if (!j)
                throw new W("GState must be referred to by name.");
              const V = a.get("ExtGState");
              if (!(V instanceof B))
                throw new W("ExtGState should be a dictionary.");
              const he = V.get(U);
              if (!(he instanceof B))
                throw new W("GState should be a dictionary.");
              h.setGState({
                resources: a,
                gState: he,
                operatorList: i,
                cacheKey: U,
                task: n,
                stateManager: y,
                localGStateCache: x,
                localColorSpaceCache: u,
                seenRefs: l
              }).then(R, L);
            }).catch(function(R) {
              if (!(R instanceof _t)) {
                if (h.options.ignoreErrors) {
                  F(`getOperatorList - ignoring ExtGState: "${R}".`);
                  return;
                }
                throw R;
              }
            }));
            return;
          case I.setLineWidth: {
            const [R] = P;
            if (typeof R != "number") {
              F(`Invalid setLineWidth: ${R}`);
              continue;
            }
            P[0] = Math.abs(R);
            break;
          }
          case I.setDash: {
            const R = P[1];
            if (typeof R != "number") {
              F(`Invalid setDash: ${R}`);
              continue;
            }
            const L = P[0];
            if (!Array.isArray(L)) {
              F(`Invalid setDash: ${L}`);
              continue;
            }
            L.some((V) => typeof V != "number") && (P[0] = L.filter((V) => typeof V == "number"));
            break;
          }
          case I.moveTo:
          case I.lineTo:
          case I.curveTo:
          case I.curveTo2:
          case I.curveTo3:
          case I.closePath:
          case I.rectangle:
            h.buildPath(K, P, y.state);
            continue;
          case I.stroke:
          case I.closeStroke:
          case I.fill:
          case I.eoFill:
          case I.fillStroke:
          case I.eoFillStroke:
          case I.closeFillStroke:
          case I.closeEOFillStroke:
          case I.endPath: {
            const {
              state: {
                pathBuffer: R,
                pathMinMax: L
              }
            } = y;
            (K === I.closeStroke || K === I.closeFillStroke || K === I.closeEOFillStroke) && R.push(Et.closePath), R.length === 0 ? i.addOp(I.constructPath, [K, [null], null]) : (i.addOp(I.constructPath, [K, [new Float32Array(R)], L.slice()]), R.length = 0, L.set([1 / 0, 1 / 0, -1 / 0, -1 / 0], 0));
            continue;
          }
          case I.setTextMatrix:
            i.addOp(K, [new Float32Array(P)]);
            continue;
          case I.markPoint:
          case I.markPointProps:
          case I.beginCompat:
          case I.endCompat:
            continue;
          case I.beginMarkedContentProps:
            if (!(P[0] instanceof Z)) {
              F(`Expected name for beginMarkedContentProps arg0=${P[0]}`), i.addOp(I.beginMarkedContentProps, ["OC", null]);
              continue;
            }
            if (P[0].name === "OC") {
              T(h.parseMarkedContentProps(P[1], a).then((R) => {
                i.addOp(I.beginMarkedContentProps, ["OC", R]);
              }).catch((R) => {
                if (!(R instanceof _t)) {
                  if (h.options.ignoreErrors) {
                    F(`getOperatorList - ignoring beginMarkedContentProps: "${R}".`), i.addOp(I.beginMarkedContentProps, ["OC", null]);
                    return;
                  }
                  throw R;
                }
              }));
              return;
            }
            P = [P[0].name, P[1] instanceof B ? P[1].get("MCID") : null];
            break;
          case I.beginMarkedContent:
          case I.endMarkedContent:
          default:
            if (P !== null) {
              for (N = 0, H = P.length; N < H && !(P[N] instanceof B); N++)
                ;
              if (N < H) {
                F("getOperatorList - ignoring operator: " + K);
                continue;
              }
            }
        }
        i.addOp(K, P);
      }
      if (O) {
        T(Il);
        return;
      }
      v(), A();
    }).catch((k) => {
      if (!(k instanceof _t)) {
        if (this.options.ignoreErrors) {
          F(`getOperatorList - ignoring errors during "${n.name}" task: "${k}".`), v();
          return;
        }
        throw k;
      }
    });
  }
  getTextContent({
    stream: e,
    task: n,
    resources: a,
    stateManager: i = null,
    includeMarkedContent: s = !1,
    sink: r,
    seenStyles: o = /* @__PURE__ */ new Set(),
    viewBox: c,
    lang: l = null,
    markedContentData: h = null,
    disableNormalization: f = !1,
    keepWhiteSpace: d = !1,
    prevRefs: u = null,
    intersector: x = null
  }) {
    const g = e.dict?.objId, p = new St(u);
    if (g) {
      if (u?.has(g))
        throw new Error(`getTextContent - ignoring circular reference: ${g}`);
      p.put(g);
    }
    a ||= B.empty, i ||= new Or(new fx()), s && (h ||= {
      level: 0
    });
    const m = {
      items: [],
      styles: /* @__PURE__ */ Object.create(null),
      lang: l
    }, b = {
      initialized: !1,
      str: [],
      totalWidth: 0,
      totalHeight: 0,
      width: 0,
      height: 0,
      vertical: !1,
      prevTransform: null,
      textAdvanceScale: 0,
      spaceInFlowMin: 0,
      spaceInFlowMax: 0,
      trackingSpaceMin: 1 / 0,
      negativeSpaceMax: -1 / 0,
      notASpace: -1 / 0,
      transform: null,
      fontName: null,
      hasEOL: !1
    }, y = [" ", " "];
    let w = 0;
    function S(ie) {
      const ue = (w + 1) % 2, ce = y[w] !== " " && y[ue] === " ";
      return y[w] = ie, w = ue, !d && ce;
    }
    function v() {
      return !d && y[w] !== " " && y[(w + 1) % 2] === " ";
    }
    function k() {
      y[0] = y[1] = " ", w = 0;
    }
    const A = 0.102, C = 0.03, T = -0.2, M = 0.102, O = 0.6, N = 0.25, H = this, J = this.xref, U = [];
    let j = null;
    const P = new dl(), K = new xl(), xe = new Da(e, J, i);
    let X;
    function ye({
      width: ie = 0,
      height: ue = 0,
      transform: ce = b.prevTransform,
      fontName: ke = b.fontName
    }) {
      x?.addExtraChar(" "), m.items.push({
        str: " ",
        dir: "ltr",
        width: ie,
        height: ue,
        transform: ce,
        fontName: ke,
        hasEOL: !1
      });
    }
    function we() {
      const ie = X.font, ue = [X.fontSize * X.textHScale, 0, 0, X.fontSize, 0, X.textRise];
      if (ie.isType3Font && (X.fontSize <= 1 || ie.isCharBBox) && !Fs(X.fontMatrix, ti)) {
        const ce = ie.bbox[3] - ie.bbox[1];
        ce > 0 && (ue[3] *= ce * X.fontMatrix[3]);
      }
      return Je.transform(X.ctm, Je.transform(X.textMatrix, ue));
    }
    function D() {
      if (b.initialized)
        return b;
      const {
        font: ie,
        loadedName: ue
      } = X;
      if (!o.has(ue) && (o.add(ue), m.styles[ue] = {
        fontFamily: ie.fallbackName,
        ascent: ie.ascent,
        descent: ie.descent,
        vertical: ie.vertical
      }, H.options.fontExtraProperties && ie.systemFontInfo)) {
        const ve = m.styles[ue];
        ve.fontSubstitution = ie.systemFontInfo.css, ve.fontSubstitutionLoadedName = ie.systemFontInfo.loadedName;
      }
      b.fontName = ue;
      const ce = b.transform = we();
      ie.vertical ? (b.width = b.totalWidth = Math.hypot(ce[0], ce[1]), b.height = b.totalHeight = 0, b.vertical = !0) : (b.width = b.totalWidth = 0, b.height = b.totalHeight = Math.hypot(ce[2], ce[3]), b.vertical = !1);
      const ke = Math.hypot(X.textLineMatrix[0], X.textLineMatrix[1]), me = Math.hypot(X.ctm[0], X.ctm[1]);
      b.textAdvanceScale = me * ke;
      const {
        fontSize: ge
      } = X;
      return b.trackingSpaceMin = ge * A, b.notASpace = ge * C, b.negativeSpaceMax = ge * T, b.spaceInFlowMin = ge * M, b.spaceInFlowMax = ge * O, b.hasEOL = !1, b.initialized = !0, b;
    }
    function G() {
      if (!b.initialized)
        return;
      const ie = Math.hypot(X.textLineMatrix[0], X.textLineMatrix[1]), ce = Math.hypot(X.ctm[0], X.ctm[1]) * ie;
      ce !== b.textAdvanceScale && (b.vertical ? (b.totalHeight += b.height * b.textAdvanceScale, b.height = 0) : (b.totalWidth += b.width * b.textAdvanceScale, b.width = 0), b.textAdvanceScale = ce);
    }
    function R(ie) {
      let ue = ie.str.join("");
      f || (ue = tf(ue));
      const ce = z1(ue, -1, ie.vertical);
      return {
        str: ce.str,
        dir: ce.dir,
        width: Math.abs(ie.totalWidth),
        height: Math.abs(ie.totalHeight),
        transform: ie.transform,
        fontName: ie.fontName,
        hasEOL: ie.hasEOL
      };
    }
    async function L(ie, ue) {
      const ce = await H.loadFont(ie, ue, a, n);
      X.loadedName = ce.loadedName, X.font = ce.font, X.fontMatrix = ce.font.fontMatrix || ti;
    }
    function V(ie, ue, ce) {
      const ke = Math.hypot(ce[0], ce[1]);
      return [(ce[0] * ie + ce[1] * ue) / ke, (ce[2] * ie + ce[3] * ue) / ke];
    }
    function he(ie) {
      const ue = we();
      let ce = ue[4], ke = ue[5];
      if (X.font?.vertical) {
        if (ce < c[0] || ce > c[2] || ke + ie < c[1] || ke > c[3])
          return !1;
      } else if (ce + ie < c[0] || ce > c[2] || ke < c[1] || ke > c[3])
        return !1;
      if (!X.font || !b.prevTransform)
        return !0;
      let me = b.prevTransform[4], ge = b.prevTransform[5];
      if (me === ce && ge === ke)
        return !0;
      let ve = -1;
      switch (ue[0] && ue[1] === 0 && ue[2] === 0 ? ve = ue[0] > 0 ? 0 : 180 : ue[1] && ue[0] === 0 && ue[3] === 0 && (ve = ue[1] > 0 ? 90 : 270), ve) {
        case 0:
          break;
        case 90:
          [ce, ke] = [ke, ce], [me, ge] = [ge, me];
          break;
        case 180:
          [ce, ke, me, ge] = [-ce, -ke, -me, -ge];
          break;
        case 270:
          [ce, ke] = [-ke, -ce], [me, ge] = [-ge, -me];
          break;
        default:
          [ce, ke] = V(ce, ke, ue), [me, ge] = V(me, ge, b.prevTransform);
      }
      if (X.font.vertical) {
        const Te = (ge - ke) / b.textAdvanceScale, je = ce - me, De = Math.sign(b.height);
        return Te < De * b.negativeSpaceMax ? Math.abs(je) > 0.5 * b.width ? (_(), !0) : (k(), fe(), !0) : Math.abs(je) > b.width ? (_(), !0) : (Te <= De * b.notASpace && k(), Te <= De * b.trackingSpaceMin ? v() ? (k(), fe(), ye({
          height: Math.abs(Te)
        })) : b.height += Te : de(Te, b.prevTransform, De) || (b.str.length === 0 ? (k(), ye({
          height: Math.abs(Te)
        })) : b.height += Te), Math.abs(je) > b.width * N && fe(), !0);
      }
      const Re = (ce - me) / b.textAdvanceScale, ne = ke - ge, Fe = Math.sign(b.width);
      return Re < Fe * b.negativeSpaceMax ? Math.abs(ne) > 0.5 * b.height ? (_(), !0) : (k(), fe(), !0) : Math.abs(ne) > b.height ? (_(), !0) : (Re <= Fe * b.notASpace && k(), Re <= Fe * b.trackingSpaceMin ? v() ? (k(), fe(), ye({
        width: Math.abs(Re)
      })) : b.width += Re : de(Re, b.prevTransform, Fe) || (b.str.length === 0 ? (k(), ye({
        width: Math.abs(Re)
      })) : b.width += Re), Math.abs(ne) > b.height * N && fe(), !0);
    }
    function te({
      chars: ie,
      extraSpacing: ue
    }) {
      const ce = X.font;
      if (!ie) {
        const ge = X.charSpacing + ue;
        ge && (ce.vertical ? X.translateTextMatrix(0, -ge) : X.translateTextMatrix(ge * X.textHScale, 0)), d && he(0);
        return;
      }
      const ke = ce.charsToGlyphs(ie), me = X.fontMatrix[0] * X.fontSize;
      for (let ge = 0, ve = ke.length; ge < ve; ge++) {
        const Re = ke[ge], {
          category: ne,
          originalCharCode: Fe
        } = Re;
        if (ne.isInvisibleFormatMark)
          continue;
        let Te = X.charSpacing + (ge + 1 === ve ? ue : 0), je = Re.width;
        ce.vertical && (je = Re.vmetric ? Re.vmetric[0] : -je);
        let De = je * me;
        if (Fe === 32 && (Te += X.wordSpacing), !d && ne.isWhitespace) {
          ce.vertical ? (Te += -De, X.translateTextMatrix(0, -Te)) : (Te += De, X.translateTextMatrix(Te * X.textHScale, 0)), S(" ");
          continue;
        }
        if (!ne.isZeroWidthDiacritic && !he(De)) {
          ce.vertical ? X.translateTextMatrix(0, De) : X.translateTextMatrix(De * X.textHScale, 0);
          continue;
        }
        const yt = D();
        ne.isZeroWidthDiacritic && (De = 0), ce.vertical ? (x?.addGlyph(we(), 0, De, Re.unicode), X.translateTextMatrix(0, De), De = Math.abs(De), yt.height += De) : (De *= X.textHScale, x?.addGlyph(we(), De, 0, Re.unicode), X.translateTextMatrix(De, 0), yt.width += De), De && (yt.prevTransform = we());
        const Ha = Re.unicode;
        S(Ha) && (yt.str.push(" "), x?.addExtraChar(" ")), x || yt.str.push(Ha), Te && (ce.vertical ? X.translateTextMatrix(0, -Te) : X.translateTextMatrix(Te * X.textHScale, 0));
      }
    }
    function _() {
      x?.addExtraChar(`
`), k(), b.initialized ? (b.hasEOL = !0, fe()) : m.items.push({
        str: "",
        dir: "ltr",
        width: 0,
        height: 0,
        transform: we(),
        fontName: X.loadedName,
        hasEOL: !0
      });
    }
    function de(ie, ue, ce) {
      if (ce * b.spaceInFlowMin <= ie && ie <= ce * b.spaceInFlowMax)
        return b.initialized && (k(), b.str.push(" "), x?.addExtraChar(" ")), !1;
      const ke = b.fontName;
      let me = 0;
      return b.vertical && (me = ie, ie = 0), fe(), k(), ye({
        width: Math.abs(ie),
        height: Math.abs(me),
        transform: ue || we(),
        fontName: ke
      }), !0;
    }
    function fe() {
      !b.initialized || !b.str || (b.vertical ? b.totalHeight += b.height * b.textAdvanceScale : b.totalWidth += b.width * b.textAdvanceScale, m.items.push(R(b)), b.initialized = !1, b.str.length = 0);
    }
    function Ee(ie = !1) {
      const ue = m.items.length;
      ue !== 0 && (ie && ue < hx || (r?.enqueue(m, ue), m.items = [], m.styles = /* @__PURE__ */ Object.create(null)));
    }
    const Ae = new js();
    return new Promise(function ie(ue, ce) {
      const ke = function(Fe) {
        Ee(!0), Promise.all([Fe, r?.ready]).then(function() {
          try {
            ie(ue, ce);
          } catch (Te) {
            ce(Te);
          }
        }, ce);
      };
      n.ensureNotTerminated(), Ae.reset();
      const me = {};
      let ge, ve, Re, ne = [];
      for (; !(ge = Ae.check()) && (ne.length = 0, me.args = ne, !!xe.read(me)); ) {
        const Fe = X;
        X = i.state;
        const Te = me.fn;
        switch (ne = me.args, Te | 0) {
          case I.setFont:
            const je = ne[0].name, De = ne[1];
            if (X.font && je === X.fontName && De === X.fontSize)
              break;
            fe(), X.fontName = je, X.fontSize = De, ke(L(je, null));
            return;
          case I.setTextRise:
            X.textRise = ne[0];
            break;
          case I.setHScale:
            X.textHScale = ne[0] / 100;
            break;
          case I.setLeading:
            X.leading = ne[0];
            break;
          case I.moveText:
            X.translateTextLineMatrix(ne[0], ne[1]), X.textMatrix = X.textLineMatrix.slice();
            break;
          case I.setLeadingMoveText:
            X.leading = -ne[1], X.translateTextLineMatrix(ne[0], ne[1]), X.textMatrix = X.textLineMatrix.slice();
            break;
          case I.nextLine:
            X.carriageReturn();
            break;
          case I.setTextMatrix:
            X.setTextMatrix(ne[0], ne[1], ne[2], ne[3], ne[4], ne[5]), X.setTextLineMatrix(ne[0], ne[1], ne[2], ne[3], ne[4], ne[5]), G();
            break;
          case I.setCharSpacing:
            X.charSpacing = ne[0];
            break;
          case I.setWordSpacing:
            X.wordSpacing = ne[0];
            break;
          case I.beginText:
            X.textMatrix = $n.slice(), X.textLineMatrix = $n.slice();
            break;
          case I.showSpacedText:
            if (!i.state.font) {
              H.ensureStateFont(i.state);
              continue;
            }
            const yt = (X.font.vertical ? 1 : -1) * X.fontSize / 1e3, Ha = ne[0];
            for (let ot = 0, $a = Ha.length; ot < $a; ot++) {
              const Ot = Ha[ot];
              if (typeof Ot == "string")
                U.push(Ot);
              else if (typeof Ot == "number" && Ot !== 0) {
                const bn = U.join("");
                U.length = 0, te({
                  chars: bn,
                  extraSpacing: Ot * yt
                });
              }
            }
            if (U.length > 0) {
              const ot = U.join("");
              U.length = 0, te({
                chars: ot,
                extraSpacing: 0
              });
            }
            break;
          case I.showText:
            if (!i.state.font) {
              H.ensureStateFont(i.state);
              continue;
            }
            te({
              chars: ne[0],
              extraSpacing: 0
            });
            break;
          case I.nextLineShowText:
            if (!i.state.font) {
              H.ensureStateFont(i.state);
              continue;
            }
            X.carriageReturn(), te({
              chars: ne[0],
              extraSpacing: 0
            });
            break;
          case I.nextLineSetSpacingShowText:
            if (!i.state.font) {
              H.ensureStateFont(i.state);
              continue;
            }
            X.wordSpacing = ne[0], X.charSpacing = ne[1], X.carriageReturn(), te({
              chars: ne[2],
              extraSpacing: 0
            });
            break;
          case I.paintXObject:
            if (fe(), j ??= a.get("XObject") || B.empty, Re = ne[0] instanceof Z, ve = ne[0].name, Re && P.getByName(ve))
              break;
            ke(new Promise(function(ot, $a) {
              if (!Re)
                throw new W("XObject must be referred to by name.");
              let Ot = j.getRaw(ve);
              if (Ot instanceof le) {
                if (P.getByRef(Ot)) {
                  ot();
                  return;
                }
                if (H.globalImageCache.getData(Ot, H.pageIndex)) {
                  ot();
                  return;
                }
                Ot = J.fetch(Ot);
              }
              if (!(Ot instanceof Ne))
                throw new W("XObject should be a stream");
              const {
                dict: bn
              } = Ot, ya = bn.get("Subtype");
              if (!(ya instanceof Z))
                throw new W("XObject should have a Name subtype");
              if (ya.name !== "Form") {
                P.set(ve, bn.objId, !0), ot();
                return;
              }
              const y0 = i.state.clone(), er = new Or(y0), tr = Fa(bn.getArray("Matrix"), null);
              tr && er.transform(tr);
              const Ki = bn.get("Resources");
              Ee();
              const nr = {
                enqueueInvoked: !1,
                enqueue(ar, w0) {
                  this.enqueueInvoked = !0, r.enqueue(ar, w0);
                },
                get desiredSize() {
                  return r.desiredSize ?? 0;
                },
                get ready() {
                  return r.ready;
                }
              };
              H.getTextContent({
                stream: Ot,
                task: n,
                resources: Ki instanceof B ? Ki : a,
                stateManager: er,
                includeMarkedContent: s,
                sink: r && nr,
                seenStyles: o,
                viewBox: c,
                lang: l,
                markedContentData: h,
                disableNormalization: f,
                keepWhiteSpace: d,
                prevRefs: p
              }).then(function() {
                nr.enqueueInvoked || P.set(ve, bn.objId, !0), ot();
              }, $a);
            }).catch(function(ot) {
              if (!(ot instanceof _t)) {
                if (H.options.ignoreErrors) {
                  F(`getTextContent - ignoring XObject: "${ot}".`);
                  return;
                }
                throw ot;
              }
            }));
            return;
          case I.setGState:
            if (Re = ne[0] instanceof Z, ve = ne[0].name, Re && K.getByName(ve))
              break;
            ke(new Promise(function(ot, $a) {
              if (!Re)
                throw new W("GState must be referred to by name.");
              const Ot = a.get("ExtGState");
              if (!(Ot instanceof B))
                throw new W("ExtGState should be a dictionary.");
              const bn = Ot.get(ve);
              if (!(bn instanceof B))
                throw new W("GState should be a dictionary.");
              const ya = bn.get("Font");
              if (!ya) {
                K.set(ve, bn.objId, !0), ot();
                return;
              }
              fe(), X.fontName = null, X.fontSize = ya[1], L(null, ya[0]).then(ot, $a);
            }).catch(function(ot) {
              if (!(ot instanceof _t)) {
                if (H.options.ignoreErrors) {
                  F(`getTextContent - ignoring ExtGState: "${ot}".`);
                  return;
                }
                throw ot;
              }
            }));
            return;
          case I.beginMarkedContent:
            fe(), s && (h.level++, m.items.push({
              type: "beginMarkedContent",
              tag: ne[0] instanceof Z ? ne[0].name : null
            }));
            break;
          case I.beginMarkedContentProps:
            if (fe(), s) {
              h.level++;
              let ot = null;
              ne[1] instanceof B && (ot = ne[1].get("MCID")), m.items.push({
                type: "beginMarkedContentProps",
                id: Number.isInteger(ot) ? `${H.idFactory.getPageObjId()}_mc${ot}` : null,
                tag: ne[0] instanceof Z ? ne[0].name : null
              });
            }
            break;
          case I.endMarkedContent:
            if (fe(), s) {
              if (h.level === 0)
                break;
              h.level--, m.items.push({
                type: "endMarkedContent"
              });
            }
            break;
          case I.restore:
            Fe && (Fe.font !== X.font || Fe.fontSize !== X.fontSize || Fe.fontName !== X.fontName) && fe();
            break;
        }
        if (m.items.length >= (r?.desiredSize ?? 1)) {
          ge = !0;
          break;
        }
      }
      if (ge) {
        ke(Il);
        return;
      }
      fe(), Ee(), ue();
    }).catch((ie) => {
      if (!(ie instanceof _t)) {
        if (this.options.ignoreErrors) {
          F(`getTextContent - ignoring errors during "${n.name}" task: "${ie}".`), fe(), Ee();
          return;
        }
        throw ie;
      }
    });
  }
  async extractDataStructures(e, n) {
    const a = this.xref;
    let i;
    const s = this.readToUnicode(n.toUnicode);
    if (n.composite) {
      const d = e.get("CIDSystemInfo");
      d instanceof B && (n.cidSystemInfo = {
        registry: Ve(d.get("Registry")),
        ordering: Ve(d.get("Ordering")),
        supplement: d.get("Supplement")
      });
      try {
        const u = e.get("CIDToGIDMap");
        u instanceof Ne && (i = u.getBytes());
      } catch (u) {
        if (!this.options.ignoreErrors)
          throw u;
        F(`extractDataStructures - ignoring CIDToGIDMap data: "${u}".`);
      }
    }
    const r = [];
    let o = null, c;
    if (e.has("Encoding")) {
      if (c = e.get("Encoding"), c instanceof B) {
        if (o = c.get("BaseEncoding"), o = o instanceof Z ? o.name : null, c.has("Differences")) {
          const d = c.get("Differences");
          let u = 0;
          for (const x of d) {
            const g = a.fetchIfRef(x);
            if (typeof g == "number")
              u = g;
            else if (g instanceof Z)
              r[u++] = g.name;
            else
              throw new W(`Invalid entry in 'Differences' array: ${g}`);
          }
        }
      } else if (c instanceof Z)
        o = c.name;
      else {
        const d = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors)
          throw new W(d);
        F(d);
      }
      o !== "MacRomanEncoding" && o !== "MacExpertEncoding" && o !== "WinAnsiEncoding" && (o = null);
    }
    const l = !n.file || n.isInternalFont, h = go()[n.name];
    if (o && l && h && (o = null), o)
      n.defaultEncoding = Ms(o);
    else {
      let d = !!(n.flags & Dn.Symbolic);
      const u = !!(n.flags & Dn.Nonsymbolic);
      n.type === "TrueType" && d && u && r.length !== 0 && (n.flags &= -5, d = !1), c = xa, n.type === "TrueType" && !u && (c = Bs), (d || h) && (c = jo, l && (/Symbol/i.test(n.name) ? c = Ho : /Dingbats/i.test(n.name) ? c = $o : /Wingdings/i.test(n.name) && (c = Bs))), n.defaultEncoding = c;
    }
    n.differences = r, n.baseEncodingName = o, n.hasEncoding = !!o || r.length > 0, n.dict = e, n.toUnicode = await s;
    const f = await this.buildToUnicode(n);
    return n.toUnicode = f, i && (n.cidToGidMap = this.readCidToGidMap(i, f)), n;
  }
  _simpleFontToUnicode(e, n = !1) {
    at(!e.composite, "Must be a simple font.");
    const a = [], i = e.defaultEncoding.slice(), s = e.baseEncodingName, r = e.differences;
    for (const c in r) {
      const l = r[c];
      l !== ".notdef" && (i[c] = l);
    }
    const o = Qn();
    for (const c in i) {
      let l = i[c];
      if (l === "")
        continue;
      let h = o[l];
      if (h !== void 0) {
        a[c] = String.fromCharCode(h);
        continue;
      }
      let f = 0;
      switch (l[0]) {
        case "G":
          l.length === 3 && (f = parseInt(l.substring(1), 16));
          break;
        case "g":
          l.length === 5 && (f = parseInt(l.substring(1), 16));
          break;
        case "C":
        case "c":
          if (l.length >= 3 && l.length <= 4) {
            const d = l.substring(1);
            if (n) {
              f = parseInt(d, 16);
              break;
            }
            if (f = +d, Number.isNaN(f) && Number.isInteger(parseInt(d, 16)))
              return this._simpleFontToUnicode(e, !0);
          }
          break;
        case "u":
          h = Li(l, o), h !== -1 && (f = h);
          break;
        default:
          switch (l) {
            case "f_h":
            case "f_t":
            case "T_h":
              a[c] = l.replaceAll("_", "");
              continue;
          }
          break;
      }
      if (f > 0 && f <= 1114111 && Number.isInteger(f)) {
        if (s && f === +c) {
          const d = Ms(s);
          if (d && (l = d[c])) {
            a[c] = String.fromCharCode(o[l]);
            continue;
          }
        }
        a[c] = String.fromCodePoint(f);
      }
    }
    return a;
  }
  async buildToUnicode(e) {
    if (e.hasIncludedToUnicodeMap = e.toUnicode?.length > 0, e.hasIncludedToUnicodeMap)
      return !e.composite && e.hasEncoding && (e.fallbackToUnicode = this._simpleFontToUnicode(e)), e.toUnicode;
    if (!e.composite)
      return new xs(this._simpleFontToUnicode(e));
    if (e.composite && (e.cMap.builtInCMap && !(e.cMap instanceof Bi) || e.cidSystemInfo?.registry === "Adobe" && (e.cidSystemInfo.ordering === "GB1" || e.cidSystemInfo.ordering === "CNS1" || e.cidSystemInfo.ordering === "Japan1" || e.cidSystemInfo.ordering === "Korea1"))) {
      const {
        registry: n,
        ordering: a
      } = e.cidSystemInfo, i = Z.get(`${n}-${a}-UCS2`), s = await xr.create({
        encoding: i,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }), r = [], o = [];
      return e.cMap.forEach(function(c, l) {
        if (l > 65535)
          throw new W("Max size of CID is 65,535");
        const h = s.lookup(l);
        if (h) {
          o.length = 0;
          for (let f = 0, d = h.length; f < d; f += 2)
            o.push((h.charCodeAt(f) << 8) + h.charCodeAt(f + 1));
          r[c] = String.fromCharCode(...o);
        }
      }), new xs(r);
    }
    return new On(e.firstChar, e.lastChar);
  }
  async readToUnicode(e) {
    if (!e)
      return null;
    if (e instanceof Z) {
      const n = await xr.create({
        encoding: e,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      return n instanceof Bi ? new On(0, 65535) : new xs(n.getMap());
    }
    if (e instanceof Ne)
      try {
        const n = await xr.create({
          encoding: e,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        });
        if (n instanceof Bi)
          return new On(0, 65535);
        const a = new Array(n.length);
        return n.forEach(function(i, s) {
          if (typeof s == "number") {
            a[i] = String.fromCodePoint(s);
            return;
          }
          s.length % 2 !== 0 && (s = "\0" + s);
          const r = [];
          for (let o = 0; o < s.length; o += 2) {
            const c = s.charCodeAt(o) << 8 | s.charCodeAt(o + 1);
            if ((c & 63488) !== 55296) {
              r.push(c);
              continue;
            }
            o += 2;
            const l = s.charCodeAt(o) << 8 | s.charCodeAt(o + 1);
            r.push(((c & 1023) << 10) + (l & 1023) + 65536);
          }
          a[i] = String.fromCodePoint(...r);
        }), new xs(a);
      } catch (n) {
        if (n instanceof _t)
          return null;
        if (this.options.ignoreErrors)
          return F(`readToUnicode - ignoring ToUnicode data: "${n}".`), null;
        throw n;
      }
    return null;
  }
  readCidToGidMap(e, n) {
    const a = [];
    for (let i = 0, s = e.length; i < s; i++) {
      const r = e[i++] << 8 | e[i], o = i >> 1;
      r === 0 && !n.has(o) || (a[o] = r);
    }
    return a;
  }
  extractWidths(e, n, a) {
    const i = this.xref;
    let s = [], r = 0;
    const o = [];
    let c;
    if (a.composite) {
      const f = e.get("DW");
      r = typeof f == "number" ? Math.ceil(f) : 1e3;
      const d = e.get("W");
      if (Array.isArray(d))
        for (let u = 0, x = d.length; u < x; u++) {
          let g = i.fetchIfRef(d[u++]);
          if (!Number.isInteger(g))
            break;
          const p = i.fetchIfRef(d[u]);
          if (Array.isArray(p))
            for (const m of p) {
              const b = i.fetchIfRef(m);
              typeof b == "number" && (s[g] = b), g++;
            }
          else if (Number.isInteger(p)) {
            const m = i.fetchIfRef(d[++u]);
            if (typeof m != "number")
              continue;
            for (let b = g; b <= p; b++)
              s[b] = m;
          } else
            break;
        }
      if (a.vertical) {
        const u = e.getArray("DW2");
        let x = an(u, 2) ? u : [880, -1e3];
        if (c = [x[1], r * 0.5, x[0]], x = e.get("W2"), Array.isArray(x))
          for (let g = 0, p = x.length; g < p; g++) {
            let m = i.fetchIfRef(x[g++]);
            if (!Number.isInteger(m))
              break;
            const b = i.fetchIfRef(x[g]);
            if (Array.isArray(b))
              for (let y = 0, w = b.length; y < w; y++) {
                const S = [i.fetchIfRef(b[y++]), i.fetchIfRef(b[y++]), i.fetchIfRef(b[y])];
                an(S, null) && (o[m] = S), m++;
              }
            else if (Number.isInteger(b)) {
              const y = [i.fetchIfRef(x[++g]), i.fetchIfRef(x[++g]), i.fetchIfRef(x[++g])];
              if (!an(y, null))
                continue;
              for (let w = m; w <= b; w++)
                o[w] = y;
            } else
              break;
          }
      }
    } else {
      const f = e.get("Widths");
      if (Array.isArray(f)) {
        let d = a.firstChar;
        for (const x of f) {
          const g = i.fetchIfRef(x);
          typeof g == "number" && (s[d] = g), d++;
        }
        const u = n.get("MissingWidth");
        r = typeof u == "number" ? u : 0;
      } else {
        const d = e.get("BaseFont");
        if (d instanceof Z) {
          const u = this.getBaseFontMetrics(d.name);
          s = this.buildCharCodeToWidth(u.widths, a), r = u.defaultWidth;
        }
      }
    }
    let l = !0, h = r;
    for (const f in s) {
      const d = s[f];
      if (d) {
        if (!h) {
          h = d;
          continue;
        }
        if (h !== d) {
          l = !1;
          break;
        }
      }
    }
    l ? a.flags |= Dn.FixedPitch : a.flags &= -2, a.defaultWidth = r, a.widths = s, a.defaultVMetrics = c, a.vmetrics = o;
  }
  isSerifFont(e) {
    const n = e.split("-", 1)[0];
    return n in _o() || /serif/gi.test(n);
  }
  getBaseFontMetrics(e) {
    let n = 0, a = /* @__PURE__ */ Object.create(null), i = !1, r = Ds()[e] || e;
    const o = Sd();
    r in o || (r = this.isSerifFont(e) ? "Times-Roman" : "Helvetica");
    const c = o[r];
    return typeof c == "number" ? (n = c, i = !0) : a = c(), {
      defaultWidth: n,
      monospace: i,
      widths: a
    };
  }
  buildCharCodeToWidth(e, n) {
    const a = /* @__PURE__ */ Object.create(null), i = n.differences, s = n.defaultEncoding;
    for (let r = 0; r < 256; r++) {
      if (r in i && e[i[r]]) {
        a[r] = e[i[r]];
        continue;
      }
      if (r in s && e[s[r]]) {
        a[r] = e[s[r]];
        continue;
      }
    }
    return a;
  }
  preEvaluateFont(e) {
    const n = e;
    let a = e.get("Subtype");
    if (!(a instanceof Z))
      throw new W("invalid font Subtype");
    let i = !1, s;
    if (a.name === "Type0") {
      const h = e.get("DescendantFonts");
      if (!h)
        throw new W("Descendant fonts are not specified");
      if (e = Array.isArray(h) ? this.xref.fetchIfRef(h[0]) : h, !(e instanceof B))
        throw new W("Descendant font is not a dictionary.");
      if (a = e.get("Subtype"), !(a instanceof Z))
        throw new W("invalid font Subtype");
      i = !0;
    }
    let r = e.get("FirstChar");
    Number.isInteger(r) || (r = 0);
    let o = e.get("LastChar");
    Number.isInteger(o) || (o = i ? 65535 : 255);
    const c = e.get("FontDescriptor"), l = e.get("ToUnicode") || n.get("ToUnicode");
    if (c) {
      s = new cx();
      const h = n.getRaw("Encoding");
      if (h instanceof Z)
        s.update(h.name);
      else if (h instanceof le)
        s.update(h.toString());
      else if (h instanceof B) {
        for (const d of h.getRawValues())
          if (d instanceof Z)
            s.update(d.name);
          else if (d instanceof le)
            s.update(d.toString());
          else if (Array.isArray(d)) {
            const u = d.length, x = new Array(u);
            for (let g = 0; g < u; g++) {
              const p = d[g];
              p instanceof Z ? x[g] = p.name : (typeof p == "number" || p instanceof le) && (x[g] = p.toString());
            }
            s.update(x.join());
          }
      }
      if (s.update(`${r}-${o}`), l instanceof Ne) {
        const d = l.str || l, u = d.buffer ? new Uint8Array(d.buffer.buffer, 0, d.bufferLength) : new Uint8Array(d.bytes.buffer, d.start, d.end - d.start);
        s.update(u);
      } else l instanceof Z && s.update(l.name);
      const f = e.get("Widths") || n.get("Widths");
      if (Array.isArray(f)) {
        const d = [];
        for (const u of f)
          (typeof u == "number" || u instanceof le) && d.push(u.toString());
        s.update(d.join());
      }
      if (i) {
        s.update("compositeFont");
        const d = e.get("W") || n.get("W");
        if (Array.isArray(d)) {
          const x = [];
          for (const g of d)
            if (typeof g == "number" || g instanceof le)
              x.push(g.toString());
            else if (Array.isArray(g)) {
              const p = [];
              for (const m of g)
                (typeof m == "number" || m instanceof le) && p.push(m.toString());
              x.push(`[${p.join()}]`);
            }
          s.update(x.join());
        }
        const u = e.getRaw("CIDToGIDMap") || n.getRaw("CIDToGIDMap");
        u instanceof Z ? s.update(u.name) : u instanceof le ? s.update(u.toString()) : u instanceof Ne && s.update(u.peekBytes());
      }
    }
    return {
      descriptor: c,
      dict: e,
      baseDict: n,
      composite: i,
      type: a.name,
      firstChar: r,
      lastChar: o,
      toUnicode: l,
      hash: s ? s.hexdigest() : ""
    };
  }
  async translateFont({
    descriptor: e,
    dict: n,
    baseDict: a,
    composite: i,
    type: s,
    firstChar: r,
    lastChar: o,
    toUnicode: c,
    cssFontInfo: l
  }) {
    const h = s === "Type3";
    if (!e)
      if (h)
        e = B.empty;
      else {
        let j = n.get("BaseFont");
        if (!(j instanceof Z))
          throw new W("Base font is not specified");
        j = j.name.replaceAll(/[,_]/g, "-");
        const P = this.getBaseFontMetrics(j), K = j.split("-", 1)[0], xe = (this.isSerifFont(K) ? Dn.Serif : 0) | (P.monospace ? Dn.FixedPitch : 0) | (go()[K] ? Dn.Symbolic : Dn.Nonsymbolic), X = {
          type: s,
          name: j,
          loadedName: a.loadedName,
          systemFontInfo: null,
          widths: P.widths,
          defaultWidth: P.defaultWidth,
          isSimulatedFlags: !0,
          flags: xe,
          firstChar: r,
          lastChar: o,
          toUnicode: c,
          xHeight: 0,
          capHeight: 0,
          italicAngle: 0,
          isType3Font: h
        }, ye = n.get("Widths"), we = Vc(j);
        let D = null;
        we && (D = await this.fetchStandardFontData(we), X.isInternalFont = !!D), !X.isInternalFont && this.options.useSystemFonts && (X.systemFontInfo = Sl(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, j, we, s));
        const G = await this.extractDataStructures(n, X);
        if (Array.isArray(ye)) {
          const R = [];
          let L = r;
          for (const V of ye) {
            const he = this.xref.fetchIfRef(V);
            typeof he == "number" && (R[L] = he), L++;
          }
          G.widths = R;
        } else
          G.widths = this.buildCharCodeToWidth(P.widths, G);
        return new ll(j, D, G, this.options);
      }
    let f = e.get("FontName"), d = n.get("BaseFont");
    typeof f == "string" && (f = Z.get(f)), typeof d == "string" && (d = Z.get(d));
    const u = f?.name, x = d?.name;
    if (h ? u || (f = Z.get(s)) : u !== x && (Ue(`The FontDescriptor's FontName is "${u}" but should be the same as the Font's BaseFont "${x}".`), u && x && (x.startsWith(u) || !Xc(u) && Xc(x)) && (f = null), f ||= d), !(f instanceof Z))
      throw new W("invalid font name");
    let g, p, m, b, y;
    try {
      if (g = e.get("FontFile", "FontFile2", "FontFile3"), g)
        if (g instanceof Ne) {
          if (g.isEmpty)
            throw new W("FontFile is empty");
        } else throw new W("FontFile should be a stream");
    } catch (j) {
      if (!this.options.ignoreErrors)
        throw j;
      F(`translateFont - fetching "${f.name}" font file: "${j}".`), g = null;
    }
    let w = !1, S = null, v = null;
    if (g) {
      if (g.dict) {
        const j = g.dict.get("Subtype");
        j instanceof Z && (p = j.name), m = g.dict.get("Length1"), b = g.dict.get("Length2"), y = g.dict.get("Length3");
      }
    } else if (l) {
      const j = qo(f.name);
      j && (l.fontFamily = `${l.fontFamily}-PdfJS-XFA`, l.metrics = j.metrics || null, S = j.factors || null, g = await this.fetchStandardFontData(j.name), w = !!g, a = n = H1(f.name), i = !0);
    } else if (!h) {
      const j = Vc(f.name);
      j && (g = await this.fetchStandardFontData(j), w = !!g), !w && this.options.useSystemFonts && (v = Sl(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, f.name, j, s));
    }
    const k = Fa(n.getArray("FontMatrix"), ti), A = ma(e.getArray("FontBBox") || n.getArray("FontBBox"), h ? [0, 0, 0, 0] : void 0);
    let C = e.get("Ascent");
    typeof C != "number" && (C = void 0);
    let T = e.get("Descent");
    typeof T != "number" && (T = void 0);
    let M = e.get("XHeight");
    typeof M != "number" && (M = 0);
    let O = e.get("CapHeight");
    typeof O != "number" && (O = 0);
    let N = e.get("Flags");
    Number.isInteger(N) || (N = 0);
    let H = e.get("ItalicAngle");
    typeof H != "number" && (H = 0);
    const J = {
      type: s,
      name: f.name,
      subtype: p,
      file: g,
      length1: m,
      length2: b,
      length3: y,
      isInternalFont: w,
      loadedName: a.loadedName,
      composite: i,
      fixedPitch: !1,
      fontMatrix: k,
      firstChar: r,
      lastChar: o,
      toUnicode: c,
      bbox: A,
      ascent: C,
      descent: T,
      xHeight: M,
      capHeight: O,
      flags: N,
      italicAngle: H,
      isType3Font: h,
      cssFontInfo: l,
      scaleFactors: S,
      systemFontInfo: v
    };
    if (i) {
      const j = a.get("Encoding");
      j instanceof Z && (J.cidEncoding = j.name);
      const P = await xr.create({
        encoding: j,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      J.cMap = P, J.vertical = J.cMap.vertical;
    }
    const U = await this.extractDataStructures(n, J);
    return this.extractWidths(n, e, U), new ll(f.name, g, U, this.options);
  }
  static buildFontPaths(e, n, a, i) {
    function s(r) {
      const o = `${e.loadedName}_path_${r}`;
      try {
        if (e.renderer.hasBuiltPath(r))
          return;
        a.send("commonobj", [o, "FontPath", e.renderer.getPathJs(r)]);
      } catch (c) {
        if (i.ignoreErrors) {
          F(`buildFontPaths - ignoring ${o} glyph: "${c}".`);
          return;
        }
        throw c;
      }
    }
    for (const r of n) {
      s(r.fontChar);
      const o = r.accent;
      o?.fontChar && s(o.fontChar);
    }
  }
  static get fallbackFontDict() {
    const e = new B();
    return e.set("BaseFont", Z.get("Helvetica")), e.set("Type", Z.get("FallbackType")), e.set("Subtype", Z.get("FallbackType")), e.set("Encoding", Z.get("WinAnsiEncoding")), ae(this, "fallbackFontDict", e);
  }
}
class U0 {
  #e = !1;
  #t = null;
  constructor({
    loadedName: e,
    font: n,
    dict: a
  }) {
    this.loadedName = e, this.font = n, this.dict = a, this.type3Dependencies = n.isType3Font ? /* @__PURE__ */ new Set() : null;
  }
  send(e) {
    if (this.#e)
      return;
    this.#e = !0;
    const n = this.font.exportData(), a = [];
    n.data && (n.data.charProcOperatorList && (n.charProcOperatorList = n.data.charProcOperatorList), n.data = ct.write(n.data), a.push(n.data)), e.send("commonobj", [this.loadedName, "Font", n], a);
  }
  fallback(e, n) {
    this.font.data && (this.font.disableFontFace = !0, Ui.buildFontPaths(this.font, this.font.glyphCacheValues, e, n));
  }
  loadType3Data(e, n, a) {
    if (this.#t)
      return this.#t;
    const {
      font: i,
      type3Dependencies: s
    } = this;
    at(i.isType3Font, "Must be a Type3 font.");
    const r = e.clone({
      ignoreErrors: !1
    }), o = new St(e.type3FontRefs);
    this.dict.objId && !o.has(this.dict.objId) && o.put(this.dict.objId), r.type3FontRefs = o;
    let c = Promise.resolve();
    const l = this.dict.get("CharProcs"), h = this.dict.get("Resources") || n, f = /* @__PURE__ */ Object.create(null), [d, u, x, g] = i.bbox, p = x - d, m = g - u, b = Math.hypot(p, m);
    for (const y of l.getKeys())
      c = c.then(() => {
        const w = l.get(y), S = new Ht();
        return r.getOperatorList({
          stream: w,
          task: a,
          resources: h,
          operatorList: S
        }).then(() => {
          switch (S.fnArray[0]) {
            case I.setCharWidthAndBounds:
              this.#n(S, b);
              break;
            case I.setCharWidth:
              b || this.#a(S);
              break;
          }
          f[y] = S.getIR();
          for (const v of S.dependencies)
            s.add(v);
        }).catch(function(v) {
          F(`Type3 font resource "${y}" is not available.`);
          const k = new Ht();
          f[y] = k.getIR();
        });
      });
    return this.#t = c.then(() => {
      i.charProcOperatorList = f, this._bbox && (i.isCharBBox = !0, i.bbox = this._bbox);
    }), this.#t;
  }
  #n(e, n = NaN) {
    const a = Je.normalizeRect(e.argsArray[0].slice(2)), i = a[2] - a[0], s = a[3] - a[1], r = Math.hypot(i, s);
    i === 0 || s === 0 ? (e.fnArray.splice(0, 1), e.argsArray.splice(0, 1)) : (n === 0 || Math.round(r / n) >= 10) && (this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0], Je.rectBoundingBox(...a, this._bbox));
    let o = 0, c = e.length;
    for (; o < c; ) {
      switch (e.fnArray[o]) {
        case I.setCharWidthAndBounds:
          break;
        case I.setStrokeColorSpace:
        case I.setFillColorSpace:
        case I.setStrokeColor:
        case I.setStrokeColorN:
        case I.setFillColor:
        case I.setFillColorN:
        case I.setStrokeGray:
        case I.setFillGray:
        case I.setStrokeRGBColor:
        case I.setFillRGBColor:
        case I.setStrokeCMYKColor:
        case I.setFillCMYKColor:
        case I.shadingFill:
        case I.setRenderingIntent:
          e.fnArray.splice(o, 1), e.argsArray.splice(o, 1), c--;
          continue;
        case I.setGState:
          const [l] = e.argsArray[o];
          let h = 0, f = l.length;
          for (; h < f; ) {
            const [d] = l[h];
            switch (d) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                l.splice(h, 1), f--;
                continue;
            }
            h++;
          }
          break;
      }
      o++;
    }
  }
  #a(e) {
    let n = 1;
    const a = e.length;
    for (; n < a; ) {
      switch (e.fnArray[n]) {
        case I.constructPath:
          const i = e.argsArray[n][2];
          this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0], Je.rectBoundingBox(...i, this._bbox);
          break;
      }
      n++;
    }
  }
}
class Or {
  constructor(e = new W1()) {
    this.state = e, this.stateStack = [];
  }
  save() {
    const e = this.state;
    this.stateStack.push(this.state), this.state = e.clone();
  }
  restore() {
    const e = this.stateStack.pop();
    e && (this.state = e);
  }
  transform(e) {
    this.state.ctm = Je.transform(this.state.ctm, e);
  }
}
class fx {
  constructor() {
    this.ctm = new Float32Array($n), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = ti, this.textMatrix = $n.slice(), this.textLineMatrix = $n.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
  }
  setTextMatrix(e, n, a, i, s, r) {
    const o = this.textMatrix;
    o[0] = e, o[1] = n, o[2] = a, o[3] = i, o[4] = s, o[5] = r;
  }
  setTextLineMatrix(e, n, a, i, s, r) {
    const o = this.textLineMatrix;
    o[0] = e, o[1] = n, o[2] = a, o[3] = i, o[4] = s, o[5] = r;
  }
  translateTextMatrix(e, n) {
    const a = this.textMatrix;
    a[4] = a[0] * e + a[2] * n + a[4], a[5] = a[1] * e + a[3] * n + a[5];
  }
  translateTextLineMatrix(e, n) {
    const a = this.textLineMatrix;
    a[4] = a[0] * e + a[2] * n + a[4], a[5] = a[1] * e + a[3] * n + a[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const e = Object.create(this);
    return e.textMatrix = this.textMatrix.slice(), e.textLineMatrix = this.textLineMatrix.slice(), e.fontMatrix = this.fontMatrix.slice(), e;
  }
}
class W1 {
  constructor() {
    this.ctm = new Float32Array($n), this.font = null, this.textRenderingMode = e1.FILL, this._fillColorSpace = this._strokeColorSpace = Ye.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null, this.currentPointX = this.currentPointY = 0, this.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]), this.pathBuffer = [];
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(e) {
    this._fillColorSpace = this.patternFillColorSpace = e;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(e) {
    this._strokeColorSpace = this.patternStrokeColorSpace = e;
  }
  clone({
    newPath: e = !1
  } = {}) {
    const n = Object.create(this);
    return e && (n.pathBuffer = [], n.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0])), n;
  }
}
class Da {
  static get opMap() {
    return ae(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), {
      w: {
        id: I.setLineWidth,
        numArgs: 1,
        variableArgs: !1
      },
      J: {
        id: I.setLineCap,
        numArgs: 1,
        variableArgs: !1
      },
      j: {
        id: I.setLineJoin,
        numArgs: 1,
        variableArgs: !1
      },
      M: {
        id: I.setMiterLimit,
        numArgs: 1,
        variableArgs: !1
      },
      d: {
        id: I.setDash,
        numArgs: 2,
        variableArgs: !1
      },
      ri: {
        id: I.setRenderingIntent,
        numArgs: 1,
        variableArgs: !1
      },
      i: {
        id: I.setFlatness,
        numArgs: 1,
        variableArgs: !1
      },
      gs: {
        id: I.setGState,
        numArgs: 1,
        variableArgs: !1
      },
      q: {
        id: I.save,
        numArgs: 0,
        variableArgs: !1
      },
      Q: {
        id: I.restore,
        numArgs: 0,
        variableArgs: !1
      },
      cm: {
        id: I.transform,
        numArgs: 6,
        variableArgs: !1
      },
      m: {
        id: I.moveTo,
        numArgs: 2,
        variableArgs: !1
      },
      l: {
        id: I.lineTo,
        numArgs: 2,
        variableArgs: !1
      },
      c: {
        id: I.curveTo,
        numArgs: 6,
        variableArgs: !1
      },
      v: {
        id: I.curveTo2,
        numArgs: 4,
        variableArgs: !1
      },
      y: {
        id: I.curveTo3,
        numArgs: 4,
        variableArgs: !1
      },
      h: {
        id: I.closePath,
        numArgs: 0,
        variableArgs: !1
      },
      re: {
        id: I.rectangle,
        numArgs: 4,
        variableArgs: !1
      },
      S: {
        id: I.stroke,
        numArgs: 0,
        variableArgs: !1
      },
      s: {
        id: I.closeStroke,
        numArgs: 0,
        variableArgs: !1
      },
      f: {
        id: I.fill,
        numArgs: 0,
        variableArgs: !1
      },
      F: {
        id: I.fill,
        numArgs: 0,
        variableArgs: !1
      },
      "f*": {
        id: I.eoFill,
        numArgs: 0,
        variableArgs: !1
      },
      B: {
        id: I.fillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      "B*": {
        id: I.eoFillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      b: {
        id: I.closeFillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      "b*": {
        id: I.closeEOFillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      n: {
        id: I.endPath,
        numArgs: 0,
        variableArgs: !1
      },
      W: {
        id: I.clip,
        numArgs: 0,
        variableArgs: !1
      },
      "W*": {
        id: I.eoClip,
        numArgs: 0,
        variableArgs: !1
      },
      BT: {
        id: I.beginText,
        numArgs: 0,
        variableArgs: !1
      },
      ET: {
        id: I.endText,
        numArgs: 0,
        variableArgs: !1
      },
      Tc: {
        id: I.setCharSpacing,
        numArgs: 1,
        variableArgs: !1
      },
      Tw: {
        id: I.setWordSpacing,
        numArgs: 1,
        variableArgs: !1
      },
      Tz: {
        id: I.setHScale,
        numArgs: 1,
        variableArgs: !1
      },
      TL: {
        id: I.setLeading,
        numArgs: 1,
        variableArgs: !1
      },
      Tf: {
        id: I.setFont,
        numArgs: 2,
        variableArgs: !1
      },
      Tr: {
        id: I.setTextRenderingMode,
        numArgs: 1,
        variableArgs: !1
      },
      Ts: {
        id: I.setTextRise,
        numArgs: 1,
        variableArgs: !1
      },
      Td: {
        id: I.moveText,
        numArgs: 2,
        variableArgs: !1
      },
      TD: {
        id: I.setLeadingMoveText,
        numArgs: 2,
        variableArgs: !1
      },
      Tm: {
        id: I.setTextMatrix,
        numArgs: 6,
        variableArgs: !1
      },
      "T*": {
        id: I.nextLine,
        numArgs: 0,
        variableArgs: !1
      },
      Tj: {
        id: I.showText,
        numArgs: 1,
        variableArgs: !1
      },
      TJ: {
        id: I.showSpacedText,
        numArgs: 1,
        variableArgs: !1
      },
      "'": {
        id: I.nextLineShowText,
        numArgs: 1,
        variableArgs: !1
      },
      '"': {
        id: I.nextLineSetSpacingShowText,
        numArgs: 3,
        variableArgs: !1
      },
      d0: {
        id: I.setCharWidth,
        numArgs: 2,
        variableArgs: !1
      },
      d1: {
        id: I.setCharWidthAndBounds,
        numArgs: 6,
        variableArgs: !1
      },
      CS: {
        id: I.setStrokeColorSpace,
        numArgs: 1,
        variableArgs: !1
      },
      cs: {
        id: I.setFillColorSpace,
        numArgs: 1,
        variableArgs: !1
      },
      SC: {
        id: I.setStrokeColor,
        numArgs: 4,
        variableArgs: !0
      },
      SCN: {
        id: I.setStrokeColorN,
        numArgs: 33,
        variableArgs: !0
      },
      sc: {
        id: I.setFillColor,
        numArgs: 4,
        variableArgs: !0
      },
      scn: {
        id: I.setFillColorN,
        numArgs: 33,
        variableArgs: !0
      },
      G: {
        id: I.setStrokeGray,
        numArgs: 1,
        variableArgs: !1
      },
      g: {
        id: I.setFillGray,
        numArgs: 1,
        variableArgs: !1
      },
      RG: {
        id: I.setStrokeRGBColor,
        numArgs: 3,
        variableArgs: !1
      },
      rg: {
        id: I.setFillRGBColor,
        numArgs: 3,
        variableArgs: !1
      },
      K: {
        id: I.setStrokeCMYKColor,
        numArgs: 4,
        variableArgs: !1
      },
      k: {
        id: I.setFillCMYKColor,
        numArgs: 4,
        variableArgs: !1
      },
      sh: {
        id: I.shadingFill,
        numArgs: 1,
        variableArgs: !1
      },
      BI: {
        id: I.beginInlineImage,
        numArgs: 0,
        variableArgs: !1
      },
      ID: {
        id: I.beginImageData,
        numArgs: 0,
        variableArgs: !1
      },
      EI: {
        id: I.endInlineImage,
        numArgs: 1,
        variableArgs: !1
      },
      Do: {
        id: I.paintXObject,
        numArgs: 1,
        variableArgs: !1
      },
      MP: {
        id: I.markPoint,
        numArgs: 1,
        variableArgs: !1
      },
      DP: {
        id: I.markPointProps,
        numArgs: 2,
        variableArgs: !1
      },
      BMC: {
        id: I.beginMarkedContent,
        numArgs: 1,
        variableArgs: !1
      },
      BDC: {
        id: I.beginMarkedContentProps,
        numArgs: 2,
        variableArgs: !1
      },
      EMC: {
        id: I.endMarkedContent,
        numArgs: 0,
        variableArgs: !1
      },
      BX: {
        id: I.beginCompat,
        numArgs: 0,
        variableArgs: !1
      },
      EX: {
        id: I.endCompat,
        numArgs: 0,
        variableArgs: !1
      },
      BM: null,
      BD: null,
      true: null,
      fa: null,
      fal: null,
      fals: null,
      false: null,
      nu: null,
      nul: null,
      null: null
    }));
  }
  static MAX_INVALID_PATH_OPS = 10;
  constructor(e, n, a = new Or()) {
    this.parser = new ka({
      lexer: new Un(e, Da.opMap),
      xref: n
    }), this.stateManager = a, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(e) {
    let n = e.args;
    for (; ; ) {
      const a = this.parser.getObj();
      if (a instanceof Ct) {
        const i = a.cmd, s = Da.opMap[i];
        if (!s) {
          F(`Unknown command "${i}".`);
          continue;
        }
        const r = s.id, o = s.numArgs;
        let c = n !== null ? n.length : 0;
        if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = r >= I.moveTo && r <= I.endPath, s.variableArgs)
          c > o && Ue(`Command ${i}: expected [0, ${o}] args, but received ${c} args.`);
        else {
          if (c !== o) {
            const l = this.nonProcessedArgs;
            for (; c > o; )
              l.push(n.shift()), c--;
            for (; c < o && l.length !== 0; )
              n === null && (n = []), n.unshift(l.pop()), c++;
          }
          if (c < o) {
            const l = `command ${i}: expected ${o} args, but received ${c} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > Da.MAX_INVALID_PATH_OPS)
              throw new W(`Invalid ${l}`);
            F(`Skipping ${l}`), n !== null && (n.length = 0);
            continue;
          }
        }
        return this.preprocessCommand(r, n), e.fn = r, e.args = n, !0;
      }
      if (a === Dt)
        return !1;
      if (a !== null && (n === null && (n = []), n.push(a), n.length > 33))
        throw new W("Too many arguments");
    }
  }
  preprocessCommand(e, n) {
    switch (e | 0) {
      case I.save:
        this.stateManager.save();
        break;
      case I.restore:
        this.stateManager.restore();
        break;
      case I.transform:
        this.stateManager.transform(n);
        break;
    }
  }
}
class ux extends Da {
  constructor(e) {
    super(new rn(e));
  }
  parse() {
    const e = {
      fn: 0,
      args: []
    }, n = {
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3)
    };
    try {
      for (; e.args.length = 0, !!this.read(e); ) {
        if (this.savedStatesDepth !== 0)
          continue;
        const {
          fn: a,
          args: i
        } = e;
        switch (a | 0) {
          case I.setFont:
            const [s, r] = i;
            s instanceof Z && (n.fontName = s.name), typeof r == "number" && r > 0 && (n.fontSize = r);
            break;
          case I.setFillRGBColor:
            Ye.rgb.getRgbItem(i, 0, n.fontColor, 0);
            break;
          case I.setFillGray:
            Ye.gray.getRgbItem(i, 0, n.fontColor, 0);
            break;
          case I.setFillCMYKColor:
            Ye.cmyk.getRgbItem(i, 0, n.fontColor, 0);
            break;
        }
      }
    } catch (a) {
      F(`parseDefaultAppearance - ignoring errors: "${a}".`);
    }
    return n;
  }
}
function Yo(t) {
  return new ux(t).parse();
}
class dx extends Da {
  constructor(e, n, a, i) {
    super(e), this.stream = e, this.evaluatorOptions = n, this.xref = a, this.globalColorSpaceCache = i, this.resources = e.dict?.get("Resources");
  }
  parse() {
    const e = {
      fn: 0,
      args: []
    };
    let n = {
      scaleFactor: 1,
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3),
      fillColorSpace: Ye.gray
    }, a = !1;
    const i = [];
    try {
      for (; e.args.length = 0, !(a || !this.read(e)); ) {
        const {
          fn: s,
          args: r
        } = e;
        switch (s | 0) {
          case I.save:
            i.push({
              scaleFactor: n.scaleFactor,
              fontSize: n.fontSize,
              fontName: n.fontName,
              fontColor: n.fontColor.slice(),
              fillColorSpace: n.fillColorSpace
            });
            break;
          case I.restore:
            n = i.pop() || n;
            break;
          case I.setTextMatrix:
            n.scaleFactor *= Math.hypot(r[0], r[1]);
            break;
          case I.setFont:
            const [o, c] = r;
            o instanceof Z && (n.fontName = o.name), typeof c == "number" && c > 0 && (n.fontSize = c * n.scaleFactor);
            break;
          case I.setFillColorSpace:
            n.fillColorSpace = Ye.parse({
              cs: r[0],
              xref: this.xref,
              resources: this.resources,
              pdfFunctionFactory: this._pdfFunctionFactory,
              globalColorSpaceCache: this.globalColorSpaceCache,
              localColorSpaceCache: this._localColorSpaceCache
            });
            break;
          case I.setFillColor:
            n.fillColorSpace.getRgbItem(r, 0, n.fontColor, 0);
            break;
          case I.setFillRGBColor:
            Ye.rgb.getRgbItem(r, 0, n.fontColor, 0);
            break;
          case I.setFillGray:
            Ye.gray.getRgbItem(r, 0, n.fontColor, 0);
            break;
          case I.setFillCMYKColor:
            Ye.cmyk.getRgbItem(r, 0, n.fontColor, 0);
            break;
          case I.showText:
          case I.showSpacedText:
          case I.nextLineShowText:
          case I.nextLineSetSpacingShowText:
            a = !0;
            break;
        }
      }
    } catch (s) {
      F(`parseAppearanceStream - ignoring errors: "${s}".`);
    }
    return this.stream.reset(), delete n.scaleFactor, delete n.fillColorSpace, n;
  }
  get _localColorSpaceCache() {
    return ae(this, "_localColorSpaceCache", new $1());
  }
  get _pdfFunctionFactory() {
    const e = new G1({
      xref: this.xref,
      isEvalSupported: this.evaluatorOptions.isEvalSupported
    });
    return ae(this, "_pdfFunctionFactory", e);
  }
}
function xx(t, e, n, a) {
  return new dx(t, e, n, a).parse();
}
function aa(t, e) {
  if (t[0] === t[1] && t[1] === t[2]) {
    const n = t[0] / 255;
    return `${ze(n)} ${e ? "g" : "G"}`;
  }
  return Array.from(t, (n) => ze(n / 255)).join(" ") + ` ${e ? "rg" : "RG"}`;
}
function gx({
  fontSize: t,
  fontName: e,
  fontColor: n
}) {
  return `/${No(e)} ${t} Tf ${aa(n, !0)}`;
}
class Jn {
  constructor(e, n) {
    this.xref = e, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = n;
    const a = new OffscreenCanvas(1, 1);
    this.ctxMeasure = a.getContext("2d", {
      willReadFrequently: !0
    }), Jn._fontNameId || (Jn._fontNameId = 1), this.fontName = Z.get(`InvalidPDFjsFont_${n}_${Jn._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!Jn._fontDescriptorRef) {
      const e = new B(this.xref);
      e.setIfName("Type", "FontDescriptor"), e.set("FontName", this.fontName), e.set("FontFamily", "MyriadPro Regular"), e.set("FontBBox", [0, 0, 0, 0]), e.setIfName("FontStretch", "Normal"), e.set("FontWeight", 400), e.set("ItalicAngle", 0), Jn._fontDescriptorRef = this.xref.getNewPersistentRef(e);
    }
    return Jn._fontDescriptorRef;
  }
  get descendantFontRef() {
    const e = new B(this.xref);
    e.set("BaseFont", this.fontName), e.setIfName("Type", "Font"), e.setIfName("Subtype", "CIDFontType0"), e.setIfName("CIDToGIDMap", "Identity"), e.set("FirstChar", this.firstChar), e.set("LastChar", this.lastChar), e.set("FontDescriptor", this.fontDescriptorRef), e.set("DW", 1e3);
    const n = [], a = [...this.widths.entries()].sort();
    let i = null, s = null;
    for (const [o, c] of a) {
      if (!i) {
        i = o, s = [c];
        continue;
      }
      o === i + s.length ? s.push(c) : (n.push(i, s), i = o, s = [c]);
    }
    i && n.push(i, s), e.set("W", n);
    const r = new B(this.xref);
    return r.set("Ordering", "Identity"), r.set("Registry", "Adobe"), r.set("Supplement", 0), e.set("CIDSystemInfo", r), this.xref.getNewPersistentRef(e);
  }
  get baseFontRef() {
    const e = new B(this.xref);
    return e.set("BaseFont", this.fontName), e.setIfName("Type", "Font"), e.setIfName("Subtype", "Type0"), e.setIfName("Encoding", "Identity-H"), e.set("DescendantFonts", [this.descendantFontRef]), e.setIfName("ToUnicode", "Identity-H"), this.xref.getNewPersistentRef(e);
  }
  get resources() {
    const e = new B(this.xref), n = new B(this.xref);
    return n.set(this.fontName.name, this.baseFontRef), e.set("Font", n), e;
  }
  _createContext() {
    return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
  }
  createFontResources(e) {
    const n = this._createContext();
    for (const a of e.split(/\r\n?|\n/))
      for (const i of a.split("")) {
        const s = i.charCodeAt(0);
        if (this.widths.has(s))
          continue;
        const r = n.measureText(i), o = Math.ceil(r.width);
        this.widths.set(s, o), this.firstChar = Math.min(s, this.firstChar), this.lastChar = Math.max(s, this.lastChar);
      }
    return this.resources;
  }
  static getFirstPositionInfo(e, n, a) {
    const [i, s, r, o] = e;
    let c = r - i, l = o - s;
    n % 180 !== 0 && ([c, l] = [l, c]);
    const h = ua * a, f = Pr * a;
    return {
      coords: [0, l + f - h],
      bbox: [0, 0, c, l],
      matrix: n !== 0 ? Ur(n, l, h) : void 0
    };
  }
  createAppearance(e, n, a, i, s, r) {
    const o = this._createContext(), c = [];
    let l = -1 / 0;
    for (const N of e.split(/\r\n?|\n/)) {
      c.push(N);
      const H = o.measureText(N).width;
      l = Math.max(l, H);
      for (const J of df(N)) {
        const U = String.fromCodePoint(J);
        let j = this.widths.get(J);
        if (j === void 0) {
          const P = o.measureText(U);
          j = Math.ceil(P.width), this.widths.set(J, j), this.firstChar = Math.min(J, this.firstChar), this.lastChar = Math.max(J, this.lastChar);
        }
      }
    }
    l *= i / 1e3;
    const [h, f, d, u] = n;
    let x = d - h, g = u - f;
    a % 180 !== 0 && ([x, g] = [g, x]);
    let p = 1;
    l > x && (p = x / l);
    let m = 1;
    const b = ua * i, y = Pr * i, w = b * c.length;
    w > g && (m = g / w);
    const S = Math.min(p, m), v = i * S, k = ["q", `0 0 ${ze(x)} ${ze(g)} re W n`, "BT", `1 0 0 1 0 ${ze(g + y)} Tm 0 Tc ${aa(s, !0)}`, `/${this.fontName.name} ${ze(v)} Tf`], {
      resources: A
    } = this;
    if (r = typeof r == "number" && r >= 0 && r <= 1 ? r : 1, r !== 1) {
      k.push("/R0 gs");
      const N = new B(this.xref), H = new B(this.xref);
      H.set("ca", r), H.set("CA", r), H.setIfName("Type", "ExtGState"), N.set("R0", H), A.set("ExtGState", N);
    }
    const C = ze(b);
    for (const N of c)
      k.push(`0 -${C} Td <${pf(N)}> Tj`);
    k.push("ET", "Q");
    const T = k.join(`
`), M = new B(this.xref);
    if (M.setIfName("Subtype", "Form"), M.setIfName("Type", "XObject"), M.set("BBox", [0, 0, x, g]), M.set("Length", T.length), M.set("Resources", A), a) {
      const N = Ur(a, x, g);
      M.set("Matrix", N);
    }
    const O = new rn(T);
    return O.dict = M, O;
  }
}
const px = ["m/d", "m/d/yy", "mm/dd/yy", "mm/yy", "d-mmm", "d-mmm-yy", "dd-mmm-yy", "yy-mm-dd", "mmm-yy", "mmmm-yy", "mmm d, yyyy", "mmmm d, yyyy", "m/d/yy h:MM tt", "m/d/yy HH:MM"], mx = ["HH:MM", "h:MM tt", "HH:MM:ss", "h:MM:ss tt"];
class V1 {
  constructor(e, n, a) {
    this.root = e, this.xref = n, this._type = a;
  }
  getAll() {
    const e = /* @__PURE__ */ new Map();
    if (!this.root)
      return e;
    const n = this.xref, a = new St();
    a.put(this.root);
    const i = [this.root];
    for (; i.length > 0; ) {
      const s = n.fetchIfRef(i.shift());
      if (!(s instanceof B))
        continue;
      if (s.has("Kids")) {
        const o = s.get("Kids");
        if (!Array.isArray(o))
          continue;
        for (const c of o) {
          if (a.has(c))
            throw new W(`Duplicate entry in "${this._type}" tree.`);
          i.push(c), a.put(c);
        }
        continue;
      }
      const r = s.get(this._type);
      if (Array.isArray(r))
        for (let o = 0, c = r.length; o < c; o += 2)
          e.set(n.fetchIfRef(r[o]), n.fetchIfRef(r[o + 1]));
    }
    return e;
  }
  getRaw(e) {
    if (!this.root)
      return null;
    const n = this.xref;
    let a = n.fetchIfRef(this.root), i = 0;
    const s = 10;
    for (; a.has("Kids"); ) {
      if (++i > s)
        return F(`Search depth limit reached for "${this._type}" tree.`), null;
      const o = a.get("Kids");
      if (!Array.isArray(o))
        return null;
      let c = 0, l = o.length - 1;
      for (; c <= l; ) {
        const h = c + l >> 1, f = n.fetchIfRef(o[h]), d = f.get("Limits");
        if (e < n.fetchIfRef(d[0]))
          l = h - 1;
        else if (e > n.fetchIfRef(d[1]))
          c = h + 1;
        else {
          a = f;
          break;
        }
      }
      if (c > l)
        return null;
    }
    const r = a.get(this._type);
    if (Array.isArray(r)) {
      let o = 0, c = r.length - 2;
      for (; o <= c; ) {
        const l = o + c >> 1, h = l + (l & 1), f = n.fetchIfRef(r[h]);
        if (e < f)
          c = h - 2;
        else if (e > f)
          o = h + 2;
        else
          return r[h + 1];
      }
    }
    return null;
  }
  get(e) {
    return this.xref.fetchIfRef(this.getRaw(e));
  }
}
class wi extends V1 {
  constructor(e, n) {
    super(e, n, "Names");
  }
}
class zr extends V1 {
  constructor(e, n) {
    super(e, n, "Nums");
  }
}
function Jo() {
  r2(), of(), ed(), s0.cleanup();
}
function Tl(t) {
  return t instanceof B ? t.has("UF") ? t.get("UF") : t.has("F") ? t.get("F") : t.has("Unix") ? t.get("Unix") : t.has("Mac") ? t.get("Mac") : t.has("DOS") ? t.get("DOS") : null : null;
}
function bx(t) {
  return t.substring(t.lastIndexOf("/") + 1);
}
class yo {
  #e = !1;
  constructor(e, n, a = !1) {
    e instanceof B && (this.xref = n, this.root = e, e.has("FS") && (this.fs = e.get("FS")), e.has("RF") && F("Related file specifications are not supported"), a || (e.has("EF") ? this.#e = !0 : F("Non-embedded file specifications are not supported")));
  }
  get filename() {
    let e = "";
    const n = Tl(this.root);
    return n && typeof n == "string" && (e = Ve(n, !0).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), ae(this, "filename", e || "unnamed");
  }
  get content() {
    if (!this.#e)
      return null;
    this._contentRef ||= Tl(this.root?.get("EF"));
    let e = null;
    if (this._contentRef) {
      const n = this.xref.fetchIfRef(this._contentRef);
      n instanceof Ne ? e = n.getBytes() : F("Embedded file specification points to non-existing/invalid content");
    } else
      F("Embedded file specification does not have any content");
    return e;
  }
  get description() {
    let e = "";
    const n = this.root?.get("Desc");
    return n && typeof n == "string" && (e = Ve(n)), ae(this, "description", e);
  }
  get serializable() {
    return {
      rawFilename: this.filename,
      filename: bx(this.filename),
      content: this.content,
      description: this.description
    };
  }
}
const hn = {
  NoError: 0,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  UnterminatedElement: -9
};
function ki(t, e) {
  const n = t[e];
  return n === " " || n === `
` || n === "\r" || n === "	";
}
function yx(t) {
  for (let e = 0, n = t.length; e < n; e++)
    if (!ki(t, e))
      return !1;
  return !0;
}
class X1 {
  _resolveEntities(e) {
    return e.replaceAll(/&([^;]+);/g, (n, a) => {
      if (a.substring(0, 2) === "#x")
        return String.fromCodePoint(parseInt(a.substring(2), 16));
      if (a.substring(0, 1) === "#")
        return String.fromCodePoint(parseInt(a.substring(1), 10));
      switch (a) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(a);
    });
  }
  _parseContent(e, n) {
    const a = [];
    let i = n;
    function s() {
      for (; i < e.length && ki(e, i); )
        ++i;
    }
    for (; i < e.length && !ki(e, i) && e[i] !== ">" && e[i] !== "/"; )
      ++i;
    const r = e.substring(n, i);
    for (s(); i < e.length && e[i] !== ">" && e[i] !== "/" && e[i] !== "?"; ) {
      s();
      let o = "", c = "";
      for (; i < e.length && !ki(e, i) && e[i] !== "="; )
        o += e[i], ++i;
      if (s(), e[i] !== "=")
        return null;
      ++i, s();
      const l = e[i];
      if (l !== '"' && l !== "'")
        return null;
      const h = e.indexOf(l, ++i);
      if (h < 0)
        return null;
      c = e.substring(i, h), a.push({
        name: o,
        value: this._resolveEntities(c)
      }), i = h + 1, s();
    }
    return {
      name: r,
      attributes: a,
      parsed: i - n
    };
  }
  _parseProcessingInstruction(e, n) {
    let a = n;
    function i() {
      for (; a < e.length && ki(e, a); )
        ++a;
    }
    for (; a < e.length && !ki(e, a) && e[a] !== ">" && e[a] !== "?" && e[a] !== "/"; )
      ++a;
    const s = e.substring(n, a);
    i();
    const r = a;
    for (; a < e.length && (e[a] !== "?" || e[a + 1] !== ">"); )
      ++a;
    const o = e.substring(r, a);
    return {
      name: s,
      value: o,
      parsed: a - n
    };
  }
  parseXml(e) {
    let n = 0;
    for (; n < e.length; ) {
      const a = e[n];
      let i = n;
      if (a === "<") {
        ++i;
        const s = e[i];
        let r;
        switch (s) {
          case "/":
            if (++i, r = e.indexOf(">", i), r < 0) {
              this.onError(hn.UnterminatedElement);
              return;
            }
            this.onEndElement(e.substring(i, r)), i = r + 1;
            break;
          case "?":
            ++i;
            const o = this._parseProcessingInstruction(e, i);
            if (e.substring(i + o.parsed, i + o.parsed + 2) !== "?>") {
              this.onError(hn.UnterminatedXmlDeclaration);
              return;
            }
            this.onPi(o.name, o.value), i += o.parsed + 2;
            break;
          case "!":
            if (e.substring(i + 1, i + 3) === "--") {
              if (r = e.indexOf("-->", i + 3), r < 0) {
                this.onError(hn.UnterminatedComment);
                return;
              }
              this.onComment(e.substring(i + 3, r)), i = r + 3;
            } else if (e.substring(i + 1, i + 8) === "[CDATA[") {
              if (r = e.indexOf("]]>", i + 8), r < 0) {
                this.onError(hn.UnterminatedCdat);
                return;
              }
              this.onCdata(e.substring(i + 8, r)), i = r + 3;
            } else if (e.substring(i + 1, i + 8) === "DOCTYPE") {
              const h = e.indexOf("[", i + 8);
              let f = !1;
              if (r = e.indexOf(">", i + 8), r < 0) {
                this.onError(hn.UnterminatedDoctypeDeclaration);
                return;
              }
              if (h > 0 && r > h) {
                if (r = e.indexOf("]>", i + 8), r < 0) {
                  this.onError(hn.UnterminatedDoctypeDeclaration);
                  return;
                }
                f = !0;
              }
              const d = e.substring(i + 8, r + (f ? 1 : 0));
              this.onDoctype(d), i = r + (f ? 2 : 1);
            } else {
              this.onError(hn.MalformedElement);
              return;
            }
            break;
          default:
            const c = this._parseContent(e, i);
            if (c === null) {
              this.onError(hn.MalformedElement);
              return;
            }
            let l = !1;
            if (e.substring(i + c.parsed, i + c.parsed + 2) === "/>")
              l = !0;
            else if (e.substring(i + c.parsed, i + c.parsed + 1) !== ">") {
              this.onError(hn.UnterminatedElement);
              return;
            }
            this.onBeginElement(c.name, c.attributes, l), i += c.parsed + (l ? 2 : 1);
            break;
        }
      } else {
        for (; i < e.length && e[i] !== "<"; )
          i++;
        const s = e.substring(n, i);
        this.onText(this._resolveEntities(s));
      }
      n = i;
    }
  }
  onResolveEntity(e) {
    return `&${e};`;
  }
  onPi(e, n) {
  }
  onComment(e) {
  }
  onCdata(e) {
  }
  onDoctype(e) {
  }
  onText(e) {
  }
  onBeginElement(e, n, a) {
  }
  onEndElement(e) {
  }
  onError(e) {
  }
}
class ws {
  constructor(e, n) {
    this.nodeName = e, this.nodeValue = n, Object.defineProperty(this, "parentNode", {
      value: null,
      writable: !0
    });
  }
  get firstChild() {
    return this.childNodes?.[0];
  }
  get nextSibling() {
    const e = this.parentNode.childNodes;
    if (!e)
      return;
    const n = e.indexOf(this);
    if (n !== -1)
      return e[n + 1];
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map((e) => e.textContent).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    return this.childNodes?.length > 0;
  }
  searchNode(e, n) {
    if (n >= e.length)
      return this;
    const a = e[n];
    if (a.name.startsWith("#") && n < e.length - 1)
      return this.searchNode(e, n + 1);
    const i = [];
    let s = this;
    for (; ; ) {
      if (a.name === s.nodeName)
        if (a.pos === 0) {
          const r = s.searchNode(e, n + 1);
          if (r !== null)
            return r;
        } else {
          if (i.length === 0)
            return null;
          {
            const [r] = i.pop();
            let o = 0;
            for (const c of r.childNodes)
              if (a.name === c.nodeName) {
                if (o === a.pos)
                  return c.searchNode(e, n + 1);
                o++;
              }
            return s.searchNode(e, n + 1);
          }
        }
      if (s.childNodes?.length > 0)
        i.push([s, 0]), s = s.childNodes[0];
      else {
        if (i.length === 0)
          return null;
        for (; i.length !== 0; ) {
          const [r, o] = i.pop(), c = o + 1;
          if (c < r.childNodes.length) {
            i.push([r, c]), s = r.childNodes[c];
            break;
          }
        }
        if (i.length === 0)
          return null;
      }
    }
  }
  dump(e) {
    if (this.nodeName === "#text") {
      e.push(Oi(this.nodeValue));
      return;
    }
    if (e.push(`<${this.nodeName}`), this.attributes)
      for (const n of this.attributes)
        e.push(` ${n.name}="${Oi(n.value)}"`);
    if (this.hasChildNodes()) {
      e.push(">");
      for (const n of this.childNodes)
        n.dump(e);
      e.push(`</${this.nodeName}>`);
    } else this.nodeValue ? e.push(`>${Oi(this.nodeValue)}</${this.nodeName}>`) : e.push("/>");
  }
}
class o0 extends X1 {
  constructor({
    hasAttributes: e = !1,
    lowerCaseName: n = !1
  }) {
    super(), this._currentFragment = null, this._stack = null, this._errorCode = hn.NoError, this._hasAttributes = e, this._lowerCaseName = n;
  }
  parseFromString(e) {
    if (this._currentFragment = [], this._stack = [], this._errorCode = hn.NoError, this.parseXml(e), this._errorCode !== hn.NoError)
      return;
    const [n] = this._currentFragment;
    if (n)
      return {
        documentElement: n
      };
  }
  onText(e) {
    if (yx(e))
      return;
    const n = new ws("#text", e);
    this._currentFragment.push(n);
  }
  onCdata(e) {
    const n = new ws("#text", e);
    this._currentFragment.push(n);
  }
  onBeginElement(e, n, a) {
    this._lowerCaseName && (e = e.toLowerCase());
    const i = new ws(e);
    i.childNodes = [], this._hasAttributes && (i.attributes = n), this._currentFragment.push(i), !a && (this._stack.push(this._currentFragment), this._currentFragment = i.childNodes);
  }
  onEndElement(e) {
    this._currentFragment = this._stack.pop() || [];
    const n = this._currentFragment.at(-1);
    if (!n)
      return null;
    for (const a of n.childNodes)
      a.parentNode = n;
    return n;
  }
  onError(e) {
    this._errorCode = e;
  }
}
class wx {
  constructor(e) {
    e = this._repair(e);
    const a = new o0({
      lowerCaseName: !0
    }).parseFromString(e);
    this._metadataMap = /* @__PURE__ */ new Map(), this._data = e, a && this._parse(a);
  }
  _repair(e) {
    return e.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(n, a) {
      const i = a.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(r, o, c, l) {
        return String.fromCharCode(o * 64 + c * 8 + l * 1);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(r, o) {
        switch (o) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${o} isn't defined.`);
      }), s = [">"];
      for (let r = 0, o = i.length; r < o; r += 2) {
        const c = i.charCodeAt(r) * 256 + i.charCodeAt(r + 1);
        c >= 32 && c < 127 && c !== 60 && c !== 62 && c !== 38 ? s.push(String.fromCharCode(c)) : s.push("&#x" + (65536 + c).toString(16).substring(1) + ";");
      }
      return s.join("");
    });
  }
  _getSequence(e) {
    const n = e.nodeName;
    return n !== "rdf:bag" && n !== "rdf:seq" && n !== "rdf:alt" ? null : e.childNodes.filter((a) => a.nodeName === "rdf:li");
  }
  _parseArray(e) {
    if (!e.hasChildNodes())
      return;
    const [n] = e.childNodes, a = this._getSequence(n) || [];
    this._metadataMap.set(e.nodeName, a.map((i) => i.textContent.trim()));
  }
  _parse(e) {
    let n = e.documentElement;
    if (n.nodeName !== "rdf:rdf")
      for (n = n.firstChild; n && n.nodeName !== "rdf:rdf"; )
        n = n.nextSibling;
    if (!(!n || n.nodeName !== "rdf:rdf" || !n.hasChildNodes())) {
      for (const a of n.childNodes)
        if (a.nodeName === "rdf:description")
          for (const i of a.childNodes) {
            const s = i.nodeName;
            switch (s) {
              case "#text":
                continue;
              case "dc:creator":
              case "dc:subject":
                this._parseArray(i);
                continue;
            }
            this._metadataMap.set(s, i.textContent.trim());
          }
    }
  }
  get serializable() {
    return {
      parsedData: this._metadataMap,
      rawData: this._data
    };
  }
}
const El = 40, Rn = {
  PAGE_CONTENT: 1,
  STREAM_CONTENT: 2,
  OBJECT: 3,
  ANNOTATION: 4,
  ELEMENT: 5
};
class Pa {
  constructor(e, n, a) {
    this.xref = e, this.dict = n, this.ref = a instanceof le ? a : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  #e(e, n, a) {
    if (!(e instanceof le) || n < 0)
      return;
    this.structParentIds ||= new un();
    let i = this.structParentIds.get(e);
    i || (i = [], this.structParentIds.put(e, i)), i.push([n, a]);
  }
  addAnnotationIdToPage(e, n) {
    this.#e(e, n, Rn.ANNOTATION);
  }
  readRoleMap() {
    const e = this.dict.get("RoleMap");
    if (e instanceof B)
      for (const [n, a] of e)
        a instanceof Z && this.roleMap.set(n, a.name);
  }
  static async canCreateStructureTree({
    catalogRef: e,
    pdfManager: n,
    newAnnotationsByPage: a
  }) {
    if (!(e instanceof le))
      return F("Cannot save the struct tree: no catalog reference."), !1;
    let i = 0, s = !0;
    for (const [r, o] of a) {
      const {
        ref: c
      } = await n.getPage(r);
      if (!(c instanceof le)) {
        F(`Cannot save the struct tree: page ${r} has no ref.`), s = !0;
        break;
      }
      for (const l of o)
        l.accessibilityData?.type && (l.parentTreeId = i++, s = !1);
    }
    if (s) {
      for (const r of a.values())
        for (const o of r)
          delete o.parentTreeId;
      return !1;
    }
    return !0;
  }
  static async createStructureTree({
    newAnnotationsByPage: e,
    xref: n,
    catalogRef: a,
    pdfManager: i,
    changes: s
  }) {
    const r = await i.ensureCatalog("cloneDict"), o = new un();
    o.put(a, r);
    const c = n.getNewTemporaryRef();
    r.set("StructTreeRoot", c);
    const l = new B(n);
    l.set("Type", Z.get("StructTreeRoot"));
    const h = n.getNewTemporaryRef();
    l.set("ParentTree", h);
    const f = [];
    l.set("K", f), o.put(c, l);
    const d = new B(n), u = [];
    d.set("Nums", u);
    const x = await this.#t({
      newAnnotationsByPage: e,
      structTreeRootRef: c,
      structTreeRoot: null,
      kids: f,
      nums: u,
      xref: n,
      pdfManager: i,
      changes: s,
      cache: o
    });
    l.set("ParentTreeNextKey", x), o.put(h, d);
    for (const [g, p] of o.items())
      s.put(g, {
        data: p
      });
  }
  async canUpdateStructTree({
    pdfManager: e,
    newAnnotationsByPage: n
  }) {
    if (!this.ref)
      return F("Cannot update the struct tree: no root reference."), !1;
    let a = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(a) || a < 0)
      return F("Cannot update the struct tree: invalid next key."), !1;
    const i = this.dict.get("ParentTree");
    if (!(i instanceof B))
      return F("Cannot update the struct tree: ParentTree isn't a dict."), !1;
    const s = i.get("Nums");
    if (!Array.isArray(s))
      return F("Cannot update the struct tree: nums isn't an array."), !1;
    const r = new zr(i, this.xref);
    for (const c of n.keys()) {
      const {
        pageDict: l
      } = await e.getPage(c);
      if (!l.has("StructParents"))
        continue;
      const h = l.get("StructParents");
      if (!Number.isInteger(h) || !Array.isArray(r.get(h)))
        return F(`Cannot save the struct tree: page ${c} has a wrong id.`), !1;
    }
    let o = !0;
    for (const [c, l] of n) {
      const {
        pageDict: h
      } = await e.getPage(c);
      Pa.#a({
        elements: l,
        xref: this.xref,
        pageDict: h,
        numberTree: r
      });
      for (const f of l)
        f.accessibilityData?.type && (f.accessibilityData.structParent >= 0 || (f.parentTreeId = a++), o = !1);
    }
    if (o) {
      for (const c of n.values())
        for (const l of c)
          delete l.parentTreeId, delete l.structTreeParent;
      return !1;
    }
    return !0;
  }
  async updateStructureTree({
    newAnnotationsByPage: e,
    pdfManager: n,
    changes: a
  }) {
    const {
      ref: i,
      xref: s
    } = this, r = this.dict.clone(), o = new un();
    o.put(i, r);
    let c = r.getRaw("ParentTree"), l;
    c instanceof le ? l = s.fetch(c) : (l = c, c = s.getNewTemporaryRef(), r.set("ParentTree", c)), l = l.clone(), o.put(c, l);
    let h = l.getRaw("Nums"), f = null;
    h instanceof le && (f = h, h = s.fetch(f)), h = h.slice(), f || l.set("Nums", h);
    const d = await Pa.#t({
      newAnnotationsByPage: e,
      structTreeRootRef: i,
      structTreeRoot: this,
      kids: null,
      nums: h,
      xref: s,
      pdfManager: n,
      changes: a,
      cache: o
    });
    if (d !== -1) {
      r.set("ParentTreeNextKey", d), f && o.put(f, h);
      for (const [u, x] of o.items())
        a.put(u, {
          data: x
        });
    }
  }
  static async #t({
    newAnnotationsByPage: e,
    structTreeRootRef: n,
    structTreeRoot: a,
    kids: i,
    nums: s,
    xref: r,
    pdfManager: o,
    changes: c,
    cache: l
  }) {
    const h = Z.get("OBJR");
    let f = -1, d;
    for (const [u, x] of e) {
      const g = await o.getPage(u), {
        ref: p
      } = g, m = p instanceof le;
      for (const {
        accessibilityData: b,
        ref: y,
        parentTreeId: w,
        structTreeParent: S
      } of x) {
        if (!b?.type)
          continue;
        const {
          structParent: v
        } = b;
        if (a && Number.isInteger(v) && v >= 0) {
          let T = (d ||= /* @__PURE__ */ new Map()).get(u);
          T === void 0 && (T = new q1(a, g.pageDict).collectObjects(p), d.set(u, T));
          const M = T?.get(v);
          if (M) {
            const O = r.fetch(M).clone();
            Pa.#n(O, b), c.put(M, {
              data: O
            });
            continue;
          }
        }
        f = Math.max(f, w);
        const k = r.getNewTemporaryRef(), A = new B(r);
        Pa.#n(A, b), await this.#s({
          structTreeParent: S,
          tagDict: A,
          newTagRef: k,
          structTreeRootRef: n,
          fallbackKids: i,
          xref: r,
          cache: l
        });
        const C = new B(r);
        A.set("K", C), C.set("Type", h), m && C.set("Pg", p), C.set("Obj", y), l.put(k, A), s.push(w, k);
      }
    }
    return f + 1;
  }
  static #n(e, {
    type: n,
    title: a,
    lang: i,
    alt: s,
    expanded: r,
    actualText: o
  }) {
    e.set("S", Z.get(n)), a && e.set("T", kn(a)), i && e.set("Lang", kn(i)), s && e.set("Alt", kn(s)), r && e.set("E", kn(r)), o && e.set("ActualText", kn(o));
  }
  static #a({
    elements: e,
    xref: n,
    pageDict: a,
    numberTree: i
  }) {
    const s = /* @__PURE__ */ new Map();
    for (const l of e)
      if (l.structTreeParentId) {
        const h = parseInt(l.structTreeParentId.split("_mc")[1], 10);
        let f = s.get(h);
        f || (f = [], s.set(h, f)), f.push(l);
      }
    const r = a.get("StructParents");
    if (!Number.isInteger(r))
      return;
    const o = i.get(r), c = (l, h, f) => {
      const d = s.get(l);
      if (d) {
        const u = h.getRaw("P"), x = n.fetchIfRef(u);
        if (u instanceof le && x instanceof B) {
          const g = {
            ref: f,
            dict: h
          };
          for (const p of d)
            p.structTreeParent = g;
        }
        return !0;
      }
      return !1;
    };
    for (const l of o) {
      if (!(l instanceof le))
        continue;
      const h = n.fetch(l), f = h.get("K");
      if (Number.isInteger(f)) {
        c(f, h, l);
        continue;
      }
      if (Array.isArray(f))
        for (let d of f) {
          if (d = n.fetchIfRef(d), Number.isInteger(d) && c(d, h, l))
            break;
          if (!(d instanceof B))
            continue;
          if (!dt(d.get("Type"), "MCR"))
            break;
          const u = d.get("MCID");
          if (Number.isInteger(u) && c(u, h, l))
            break;
        }
    }
  }
  static async #s({
    structTreeParent: e,
    tagDict: n,
    newTagRef: a,
    structTreeRootRef: i,
    fallbackKids: s,
    xref: r,
    cache: o
  }) {
    let c = null, l;
    e ? ({
      ref: c
    } = e, l = e.dict.getRaw("P") || i) : l = i, n.set("P", l);
    const h = r.fetchIfRef(l);
    if (!h) {
      s.push(a);
      return;
    }
    let f = o.get(l);
    f || (f = h.clone(), o.put(l, f));
    const d = f.getRaw("K");
    let u = d instanceof le ? o.get(d) : null;
    if (!u) {
      u = r.fetchIfRef(d), u = Array.isArray(u) ? u.slice() : [d];
      const g = r.getNewTemporaryRef();
      f.set("K", g), o.put(g, u);
    }
    const x = u.indexOf(c);
    u.splice(x >= 0 ? x + 1 : u.length, 0, a);
  }
}
class vx {
  constructor(e, n) {
    this.tree = e, this.xref = e.xref, this.dict = n, this.kids = [], this.parseKids();
  }
  get role() {
    const e = this.dict.get("S"), n = e instanceof Z ? e.name : "", {
      root: a
    } = this.tree;
    return a.roleMap.get(n) ?? n;
  }
  parseKids() {
    let e = null;
    const n = this.dict.getRaw("Pg");
    n instanceof le && (e = n.toString());
    const a = this.dict.get("K");
    if (Array.isArray(a))
      for (const i of a) {
        const s = this.parseKid(e, this.xref.fetchIfRef(i));
        s && this.kids.push(s);
      }
    else {
      const i = this.parseKid(e, a);
      i && this.kids.push(i);
    }
  }
  parseKid(e, n) {
    if (Number.isInteger(n))
      return this.tree.pageDict.objId !== e ? null : new vr({
        type: Rn.PAGE_CONTENT,
        mcid: n,
        pageObjId: e
      });
    if (!(n instanceof B))
      return null;
    const a = n.getRaw("Pg");
    a instanceof le && (e = a.toString());
    const i = n.get("Type") instanceof Z ? n.get("Type").name : null;
    if (i === "MCR") {
      if (this.tree.pageDict.objId !== e)
        return null;
      const s = n.getRaw("Stm");
      return new vr({
        type: Rn.STREAM_CONTENT,
        refObjId: s instanceof le ? s.toString() : null,
        pageObjId: e,
        mcid: n.get("MCID")
      });
    }
    if (i === "OBJR") {
      if (this.tree.pageDict.objId !== e)
        return null;
      const s = n.getRaw("Obj");
      return new vr({
        type: Rn.OBJECT,
        refObjId: s instanceof le ? s.toString() : null,
        pageObjId: e
      });
    }
    return new vr({
      type: Rn.ELEMENT,
      dict: n
    });
  }
}
class vr {
  constructor({
    type: e,
    dict: n = null,
    mcid: a = null,
    pageObjId: i = null,
    refObjId: s = null
  }) {
    this.type = e, this.dict = n, this.mcid = a, this.pageObjId = i, this.refObjId = s, this.parentNode = null;
  }
}
class q1 {
  constructor(e, n) {
    this.root = e, this.xref = e?.xref ?? null, this.rootDict = e?.dict ?? null, this.pageDict = n, this.nodes = [];
  }
  collectObjects(e) {
    if (!this.root || !this.rootDict || !(e instanceof le))
      return null;
    const n = this.rootDict.get("ParentTree");
    if (!n)
      return null;
    const a = this.root.structParentIds?.get(e);
    if (!a)
      return null;
    const i = /* @__PURE__ */ new Map(), s = new zr(n, this.xref);
    for (const [r] of a) {
      const o = s.getRaw(r);
      o instanceof le && i.set(r, o);
    }
    return i;
  }
  parse(e) {
    if (!this.root || !this.rootDict || !(e instanceof le))
      return;
    const n = this.rootDict.get("ParentTree");
    if (!n)
      return;
    const a = this.pageDict.get("StructParents"), i = this.root.structParentIds?.get(e);
    if (!Number.isInteger(a) && !i)
      return;
    const s = /* @__PURE__ */ new Map(), r = new zr(n, this.xref);
    if (Number.isInteger(a)) {
      const o = r.get(a);
      if (Array.isArray(o))
        for (const c of o)
          c instanceof le && this.addNode(this.xref.fetch(c), s);
    }
    if (i)
      for (const [o, c] of i) {
        const l = r.get(o);
        if (l) {
          const h = this.addNode(this.xref.fetchIfRef(l), s);
          h?.kids?.length === 1 && h.kids[0].type === Rn.OBJECT && (h.kids[0].type = c);
        }
      }
  }
  addNode(e, n, a = 0) {
    if (a > El)
      return F("StructTree MAX_DEPTH reached."), null;
    if (!(e instanceof B))
      return null;
    if (n.has(e))
      return n.get(e);
    const i = new vx(this, e);
    n.set(e, i);
    const s = e.get("P");
    if (!(s instanceof B) || dt(s.get("Type"), "StructTreeRoot"))
      return this.addTopLevelNode(e, i) || n.delete(e), i;
    const r = this.addNode(s, n, a + 1);
    if (!r)
      return i;
    let o = !1;
    for (const c of r.kids)
      c.type === Rn.ELEMENT && c.dict === e && (c.parentNode = i, o = !0);
    return o || n.delete(e), i;
  }
  addTopLevelNode(e, n) {
    const a = this.rootDict.get("K");
    if (!a)
      return !1;
    if (a instanceof B)
      return a.objId !== e.objId ? !1 : (this.nodes[0] = n, !0);
    if (!Array.isArray(a))
      return !0;
    let i = !1;
    for (let s = 0; s < a.length; s++)
      a[s]?.toString() === e.objId && (this.nodes[s] = n, i = !0);
    return i;
  }
  get serializable() {
    function e(a, i, s = 0) {
      if (s > El) {
        F("StructTree too deep to be fully serialized.");
        return;
      }
      const r = /* @__PURE__ */ Object.create(null);
      r.role = a.role, r.children = [], i.children.push(r);
      let o = a.dict.get("Alt");
      typeof o != "string" && (o = a.dict.get("ActualText")), typeof o == "string" && (r.alt = Ve(o));
      const c = a.dict.get("A");
      if (c instanceof B) {
        const h = ma(c.getArray("BBox"), null);
        if (h)
          r.bbox = h;
        else {
          const f = c.get("Width"), d = c.get("Height");
          typeof f == "number" && f > 0 && typeof d == "number" && d > 0 && (r.bbox = [0, 0, f, d]);
        }
      }
      const l = a.dict.get("Lang");
      typeof l == "string" && (r.lang = Ve(l));
      for (const h of a.kids) {
        const f = h.type === Rn.ELEMENT ? h.parentNode : null;
        if (f) {
          e(f, r, s + 1);
          continue;
        } else h.type === Rn.PAGE_CONTENT || h.type === Rn.STREAM_CONTENT ? r.children.push({
          type: "content",
          id: `p${h.pageObjId}_mc${h.mcid}`
        }) : h.type === Rn.OBJECT ? r.children.push({
          type: "object",
          id: h.refObjId
        }) : h.type === Rn.ANNOTATION && r.children.push({
          type: "annotation",
          id: `${nf}${h.refObjId}`
        });
      }
    }
    const n = /* @__PURE__ */ Object.create(null);
    n.children = [], n.role = "Root";
    for (const a of this.nodes)
      a && e(a, n);
    return n;
  }
}
const Sx = (t) => t instanceof le, _r = af.bind(null, Sx, dt);
function j0(t) {
  return t instanceof B && (t = t.get("D")), _r(t) ? t : null;
}
function Fl(t) {
  let e = t.get("D");
  if (e) {
    if (e instanceof Z && (e = e.name), typeof e == "string")
      return Ve(e, !0);
    if (_r(e))
      return JSON.stringify(e);
  }
  return null;
}
class ji {
  #e = null;
  #t = null;
  builtInCMapCache = /* @__PURE__ */ new Map();
  fontCache = new un();
  globalColorSpaceCache = new X2();
  globalImageCache = new Ci();
  nonBlendModesSet = new St();
  pageDictCache = new un();
  pageIndexCache = new un();
  pageKidsCountCache = new un();
  standardFontDataCache = /* @__PURE__ */ new Map();
  systemFontCache = /* @__PURE__ */ new Map();
  constructor(e, n) {
    if (this.pdfManager = e, this.xref = n, this.#t = n.getCatalogObj(), !(this.#t instanceof B))
      throw new W("Catalog object is not a dictionary.");
    this.toplevelPagesDict;
  }
  cloneDict() {
    return this.#t.clone();
  }
  get version() {
    const e = this.#t.get("Version");
    if (e instanceof Z) {
      if (r1.test(e.name))
        return ae(this, "version", e.name);
      F(`Invalid PDF catalog version: ${e.name}`);
    }
    return ae(this, "version", null);
  }
  get lang() {
    const e = this.#t.get("Lang");
    return ae(this, "lang", e && typeof e == "string" ? Ve(e) : null);
  }
  get needsRendering() {
    const e = this.#t.get("NeedsRendering");
    return ae(this, "needsRendering", typeof e == "boolean" ? e : !1);
  }
  get collection() {
    let e = null;
    try {
      const n = this.#t.get("Collection");
      n instanceof B && n.size > 0 && (e = n);
    } catch (n) {
      if (n instanceof ht)
        throw n;
      Ue("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return ae(this, "collection", e);
  }
  get acroForm() {
    let e = null;
    try {
      const n = this.#t.get("AcroForm");
      n instanceof B && n.size > 0 && (e = n);
    } catch (n) {
      if (n instanceof ht)
        throw n;
      Ue("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return ae(this, "acroForm", e);
  }
  get acroFormRef() {
    const e = this.#t.getRaw("AcroForm");
    return ae(this, "acroFormRef", e instanceof le ? e : null);
  }
  get metadata() {
    const e = this.#t.getRaw("Metadata");
    if (!(e instanceof le))
      return ae(this, "metadata", null);
    let n = null;
    try {
      const a = this.xref.fetch(e, !this.xref.encrypt?.encryptMetadata);
      if (a instanceof Ne && a.dict instanceof B) {
        const i = a.dict.get("Type"), s = a.dict.get("Subtype");
        if (dt(i, "Metadata") && dt(s, "XML")) {
          const r = Es(a.getString());
          r && (n = new wx(r).serializable);
        }
      }
    } catch (a) {
      if (a instanceof ht)
        throw a;
      Ue(`Skipping invalid Metadata: "${a}".`);
    }
    return ae(this, "metadata", n);
  }
  get markInfo() {
    let e = null;
    try {
      e = this.#n();
    } catch (n) {
      if (n instanceof ht)
        throw n;
      F("Unable to read mark info.");
    }
    return ae(this, "markInfo", e);
  }
  #n() {
    const e = this.#t.get("MarkInfo");
    if (!(e instanceof B))
      return null;
    const n = {
      Marked: !1,
      UserProperties: !1,
      Suspects: !1
    };
    for (const a in n) {
      const i = e.get(a);
      typeof i == "boolean" && (n[a] = i);
    }
    return n;
  }
  get structTreeRoot() {
    let e = null;
    try {
      e = this.#a();
    } catch (n) {
      if (n instanceof ht)
        throw n;
      F("Unable read to structTreeRoot info.");
    }
    return ae(this, "structTreeRoot", e);
  }
  #a() {
    const e = this.#t.getRaw("StructTreeRoot"), n = this.xref.fetchIfRef(e);
    if (!(n instanceof B))
      return null;
    const a = new Pa(this.xref, n, e);
    return a.init(), a;
  }
  get toplevelPagesDict() {
    const e = this.#t.get("Pages");
    if (!(e instanceof B))
      throw new W("Invalid top-level pages dictionary.");
    return ae(this, "toplevelPagesDict", e);
  }
  get documentOutline() {
    let e = null;
    try {
      e = this.#s();
    } catch (n) {
      if (n instanceof ht)
        throw n;
      F("Unable to read document outline.");
    }
    return ae(this, "documentOutline", e);
  }
  #s() {
    let e = this.#t.get("Outlines");
    if (!(e instanceof B) || (e = e.getRaw("First"), !(e instanceof le)))
      return null;
    const n = {
      items: []
    }, a = [{
      obj: e,
      parent: n
    }], i = new St();
    i.put(e);
    const s = this.xref, r = new Uint8ClampedArray(3);
    for (; a.length > 0; ) {
      const o = a.shift(), c = s.fetchIfRef(o.obj);
      if (c === null)
        continue;
      c.has("Title") || F("Invalid outline item encountered.");
      const l = {
        url: null,
        dest: null,
        action: null
      };
      ji.parseDestDictionary({
        destDict: c,
        resultObj: l,
        docBaseUrl: this.baseUrl,
        docAttachments: this.attachments
      });
      const h = c.get("Title"), f = c.get("F") || 0, d = c.getArray("C"), u = c.get("Count");
      let x = r;
      an(d, 3) && (d[0] !== 0 || d[1] !== 0 || d[2] !== 0) && (x = Ye.rgb.getRgb(d, 0));
      const g = {
        action: l.action,
        attachment: l.attachment,
        dest: l.dest,
        url: l.url,
        unsafeUrl: l.unsafeUrl,
        newWindow: l.newWindow,
        setOCGState: l.setOCGState,
        title: typeof h == "string" ? Ve(h) : "",
        color: x,
        count: Number.isInteger(u) ? u : void 0,
        bold: !!(f & 2),
        italic: !!(f & 1),
        items: []
      };
      o.parent.items.push(g), e = c.getRaw("First"), e instanceof le && !i.has(e) && (a.push({
        obj: e,
        parent: g
      }), i.put(e)), e = c.getRaw("Next"), e instanceof le && !i.has(e) && (a.push({
        obj: e,
        parent: o.parent
      }), i.put(e));
    }
    return n.items.length > 0 ? n.items : null;
  }
  get permissions() {
    let e = null;
    try {
      e = this.#r();
    } catch (n) {
      if (n instanceof ht)
        throw n;
      F("Unable to read permissions.");
    }
    return ae(this, "permissions", e);
  }
  #r() {
    const e = this.xref.trailer.get("Encrypt");
    if (!(e instanceof B))
      return null;
    let n = e.get("P");
    if (typeof n != "number")
      return null;
    n += 2 ** 32;
    const a = [];
    for (const i in bc) {
      const s = bc[i];
      n & s && a.push(s);
    }
    return a;
  }
  get optionalContentConfig() {
    let e = null;
    try {
      const n = this.#t.get("OCProperties");
      if (!n)
        return ae(this, "optionalContentConfig", null);
      const a = n.get("D");
      if (!a)
        return ae(this, "optionalContentConfig", null);
      const i = n.get("OCGs");
      if (!Array.isArray(i))
        return ae(this, "optionalContentConfig", null);
      const s = new un();
      for (const r of i)
        !(r instanceof le) || s.has(r) || s.put(r, this.#c(r));
      e = this.#i(a, s);
    } catch (n) {
      if (n instanceof ht)
        throw n;
      F(`Unable to read optional content config: ${n}`);
    }
    return ae(this, "optionalContentConfig", e);
  }
  #c(e) {
    const n = this.xref.fetch(e), a = {
      id: e.toString(),
      name: null,
      intent: null,
      usage: {
        print: null,
        view: null
      },
      rbGroups: []
    }, i = n.get("Name");
    typeof i == "string" && (a.name = Ve(i));
    let s = n.getArray("Intent");
    Array.isArray(s) || (s = [s]), s.every((h) => h instanceof Z) && (a.intent = s.map((h) => h.name));
    const r = n.get("Usage");
    if (!(r instanceof B))
      return a;
    const o = a.usage, c = r.get("Print");
    if (c instanceof B) {
      const h = c.get("PrintState");
      if (h instanceof Z)
        switch (h.name) {
          case "ON":
          case "OFF":
            o.print = {
              printState: h.name
            };
        }
    }
    const l = r.get("View");
    if (l instanceof B) {
      const h = l.get("ViewState");
      if (h instanceof Z)
        switch (h.name) {
          case "ON":
          case "OFF":
            o.view = {
              viewState: h.name
            };
        }
    }
    return a;
  }
  #i(e, n) {
    function a(h) {
      const f = [];
      if (Array.isArray(h))
        for (const d of h)
          d instanceof le && n.has(d) && f.push(d.toString());
      return f;
    }
    function i(h, f = 0) {
      if (!Array.isArray(h))
        return null;
      const d = [];
      for (const x of h) {
        if (x instanceof le && n.has(x)) {
          c.put(x), d.push(x.toString());
          continue;
        }
        const g = s(x, f);
        g && d.push(g);
      }
      if (f > 0)
        return d;
      const u = [];
      for (const [x] of n.items())
        c.has(x) || u.push(x.toString());
      return u.length && d.push({
        name: null,
        order: u
      }), d;
    }
    function s(h, f) {
      if (++f > l)
        return F("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
      const d = o.fetchIfRef(h);
      if (!Array.isArray(d))
        return null;
      const u = o.fetchIfRef(d[0]);
      if (typeof u != "string")
        return null;
      const x = i(d.slice(1), f);
      return x?.length ? {
        name: Ve(u),
        order: x
      } : null;
    }
    function r(h) {
      if (Array.isArray(h))
        for (const f of h) {
          const d = o.fetchIfRef(f);
          if (!Array.isArray(d) || !d.length)
            continue;
          const u = /* @__PURE__ */ new Set();
          for (const x of d)
            x instanceof le && n.has(x) && !u.has(x.toString()) && (u.add(x.toString()), n.get(x).rbGroups.push(u));
        }
    }
    const o = this.xref, c = new St(), l = 10;
    return r(e.get("RBGroups")), {
      name: typeof e.get("Name") == "string" ? Ve(e.get("Name")) : null,
      creator: typeof e.get("Creator") == "string" ? Ve(e.get("Creator")) : null,
      baseState: e.get("BaseState") instanceof Z ? e.get("BaseState").name : null,
      on: a(e.get("ON")),
      off: a(e.get("OFF")),
      order: i(e.get("Order")),
      groups: [...n]
    };
  }
  setActualNumPages(e = null) {
    this.#e = e;
  }
  get hasActualNumPages() {
    return this.#e !== null;
  }
  get _pagesCount() {
    const e = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(e))
      throw new W("Page count in top-level pages dictionary is not an integer.");
    return ae(this, "_pagesCount", e);
  }
  get numPages() {
    return this.#e ?? this._pagesCount;
  }
  get destinations() {
    const e = this.#o(), n = /* @__PURE__ */ Object.create(null);
    for (const a of e)
      if (a instanceof wi)
        for (const [i, s] of a.getAll()) {
          const r = j0(s);
          r && (n[Ve(i, !0)] = r);
        }
      else if (a instanceof B)
        for (const [i, s] of a) {
          const r = j0(s);
          r && (n[Ve(i, !0)] ||= r);
        }
    return ae(this, "destinations", n);
  }
  getDestination(e) {
    if (this.hasOwnProperty("destinations"))
      return this.destinations[e] ?? null;
    const n = this.#o();
    for (const a of n)
      if (a instanceof wi || a instanceof B) {
        const i = j0(a.get(e));
        if (i)
          return i;
      }
    if (n.length) {
      const a = this.destinations[e];
      if (a)
        return a;
    }
    return null;
  }
  #o() {
    const e = this.#t.get("Names"), n = [];
    return e?.has("Dests") && n.push(new wi(e.getRaw("Dests"), this.xref)), this.#t.has("Dests") && n.push(this.#t.get("Dests")), n;
  }
  get pageLabels() {
    let e = null;
    try {
      e = this.#l();
    } catch (n) {
      if (n instanceof ht)
        throw n;
      F("Unable to read page labels.");
    }
    return ae(this, "pageLabels", e);
  }
  #l() {
    const e = this.#t.getRaw("PageLabels");
    if (!e)
      return null;
    const n = new Array(this.numPages);
    let a = null, i = "";
    const r = new zr(e, this.xref).getAll();
    let o = "", c = 1;
    for (let l = 0, h = this.numPages; l < h; l++) {
      const f = r.get(l);
      if (f !== void 0) {
        if (!(f instanceof B))
          throw new W("PageLabel is not a dictionary.");
        if (f.has("Type") && !dt(f.get("Type"), "PageLabel"))
          throw new W("Invalid type in PageLabel dictionary.");
        if (f.has("S")) {
          const d = f.get("S");
          if (!(d instanceof Z))
            throw new W("Invalid style in PageLabel dictionary.");
          a = d.name;
        } else
          a = null;
        if (f.has("P")) {
          const d = f.get("P");
          if (typeof d != "string")
            throw new W("Invalid prefix in PageLabel dictionary.");
          i = Ve(d);
        } else
          i = "";
        if (f.has("St")) {
          const d = f.get("St");
          if (!(Number.isInteger(d) && d >= 1))
            throw new W("Invalid start in PageLabel dictionary.");
          c = d;
        } else
          c = 1;
      }
      switch (a) {
        case "D":
          o = c;
          break;
        case "R":
        case "r":
          o = hf(c, a === "r");
          break;
        case "A":
        case "a":
          const d = 26, g = a === "a" ? 97 : 65, p = c - 1;
          o = String.fromCharCode(g + p % d).repeat(Math.floor(p / d) + 1);
          break;
        default:
          if (a)
            throw new W(`Invalid style "${a}" in PageLabel dictionary.`);
          o = "";
      }
      n[l] = i + o, c++;
    }
    return n;
  }
  get pageLayout() {
    const e = this.#t.get("PageLayout");
    let n = "";
    if (e instanceof Z)
      switch (e.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          n = e.name;
      }
    return ae(this, "pageLayout", n);
  }
  get pageMode() {
    const e = this.#t.get("PageMode");
    let n = "UseNone";
    if (e instanceof Z)
      switch (e.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          n = e.name;
      }
    return ae(this, "pageMode", n);
  }
  get viewerPreferences() {
    const e = this.#t.get("ViewerPreferences");
    if (!(e instanceof B))
      return ae(this, "viewerPreferences", null);
    let n = null;
    for (const [a, i] of e) {
      let s;
      switch (a) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          typeof i == "boolean" && (s = i);
          break;
        case "NonFullScreenPageMode":
          if (i instanceof Z)
            switch (i.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                s = i.name;
                break;
              default:
                s = "UseNone";
            }
          break;
        case "Direction":
          if (i instanceof Z)
            switch (i.name) {
              case "L2R":
              case "R2L":
                s = i.name;
                break;
              default:
                s = "L2R";
            }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (i instanceof Z)
            switch (i.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                s = i.name;
                break;
              default:
                s = "CropBox";
            }
          break;
        case "PrintScaling":
          if (i instanceof Z)
            switch (i.name) {
              case "None":
              case "AppDefault":
                s = i.name;
                break;
              default:
                s = "AppDefault";
            }
          break;
        case "Duplex":
          if (i instanceof Z)
            switch (i.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                s = i.name;
                break;
              default:
                s = "None";
            }
          break;
        case "PrintPageRange":
          Array.isArray(i) && i.length % 2 === 0 && i.every((o, c, l) => Number.isInteger(o) && o > 0 && (c === 0 || o >= l[c - 1]) && o <= this.numPages) && (s = i);
          break;
        case "NumCopies":
          Number.isInteger(i) && i > 0 && (s = i);
          break;
        default:
          F(`Ignoring non-standard key in ViewerPreferences: ${a}.`);
          continue;
      }
      if (s === void 0) {
        F(`Bad value, for key "${a}", in ViewerPreferences: ${i}.`);
        continue;
      }
      n ??= /* @__PURE__ */ Object.create(null), n[a] = s;
    }
    return ae(this, "viewerPreferences", n);
  }
  get openAction() {
    const e = this.#t.get("OpenAction"), n = /* @__PURE__ */ Object.create(null);
    if (e instanceof B) {
      const a = new B(this.xref);
      a.set("A", e);
      const i = {
        url: null,
        dest: null,
        action: null
      };
      ji.parseDestDictionary({
        destDict: a,
        resultObj: i
      }), Array.isArray(i.dest) ? n.dest = i.dest : i.action && (n.action = i.action);
    } else _r(e) && (n.dest = e);
    return ae(this, "openAction", Mo(n) > 0 ? n : null);
  }
  get attachments() {
    const e = this.#t.get("Names");
    let n = null;
    if (e instanceof B && e.has("EmbeddedFiles")) {
      const a = new wi(e.getRaw("EmbeddedFiles"), this.xref);
      for (const [i, s] of a.getAll()) {
        const r = new yo(s, this.xref);
        n ??= /* @__PURE__ */ Object.create(null), n[Ve(i, !0)] = r.serializable;
      }
    }
    return ae(this, "attachments", n);
  }
  get xfaImages() {
    const e = this.#t.get("Names");
    let n = null;
    if (e instanceof B && e.has("XFAImages")) {
      const a = new wi(e.getRaw("XFAImages"), this.xref);
      for (const [i, s] of a.getAll())
        s instanceof Ne && (n ??= /* @__PURE__ */ new Map(), n.set(Ve(i, !0), s.getBytes()));
    }
    return ae(this, "xfaImages", n);
  }
  #h() {
    const e = this.#t.get("Names");
    let n = null;
    function a(s, r) {
      if (!(r instanceof B) || !dt(r.get("S"), "JavaScript"))
        return;
      let o = r.get("JS");
      if (o instanceof Ne)
        o = o.getString();
      else if (typeof o != "string")
        return;
      o = Ve(o, !0).replaceAll("\0", ""), o && (n ||= /* @__PURE__ */ new Map()).set(s, o);
    }
    if (e instanceof B && e.has("JavaScript")) {
      const s = new wi(e.getRaw("JavaScript"), this.xref);
      for (const [r, o] of s.getAll())
        a(Ve(r, !0), o);
    }
    const i = this.#t.get("OpenAction");
    return i && a("OpenAction", i), n;
  }
  get jsActions() {
    const e = this.#h();
    let n = a0(this.xref, this.#t, Xh);
    if (e) {
      n ||= /* @__PURE__ */ Object.create(null);
      for (const [a, i] of e)
        a in n ? n[a].push(i) : n[a] = [i];
    }
    return ae(this, "jsActions", n);
  }
  async cleanup(e = !1) {
    Jo(), this.globalColorSpaceCache.clear(), this.globalImageCache.clear(e), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
    for (const {
      dict: n
    } of await Promise.all(this.fontCache))
      delete n.cacheKey;
    this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
  }
  async getPageDict(e) {
    const n = [this.toplevelPagesDict], a = new St(), i = this.#t.getRaw("Pages");
    i instanceof le && a.put(i);
    const s = this.xref, r = this.pageKidsCountCache, o = this.pageIndexCache, c = this.pageDictCache;
    let l = 0;
    for (; n.length; ) {
      const h = n.pop();
      if (h instanceof le) {
        const x = r.get(h);
        if (x >= 0 && l + x <= e) {
          l += x;
          continue;
        }
        if (a.has(h))
          throw new W("Pages tree contains circular reference.");
        a.put(h);
        const g = await (c.get(h) || s.fetchAsync(h));
        if (g instanceof B) {
          let p = g.getRaw("Type");
          if (p instanceof le && (p = await s.fetchAsync(p)), dt(p, "Page") || !g.has("Kids")) {
            if (r.has(h) || r.put(h, 1), o.has(h) || o.put(h, l), l === e)
              return [g, h];
            l++;
            continue;
          }
        }
        n.push(g);
        continue;
      }
      if (!(h instanceof B))
        throw new W("Page dictionary kid reference points to wrong type of object.");
      const {
        objId: f
      } = h;
      let d = h.getRaw("Count");
      if (d instanceof le && (d = await s.fetchAsync(d)), Number.isInteger(d) && d >= 0 && (f && !r.has(f) && r.put(f, d), l + d <= e)) {
        l += d;
        continue;
      }
      let u = h.getRaw("Kids");
      if (u instanceof le && (u = await s.fetchAsync(u)), !Array.isArray(u)) {
        let x = h.getRaw("Type");
        if (x instanceof le && (x = await s.fetchAsync(x)), dt(x, "Page") || !h.has("Kids")) {
          if (l === e)
            return [h, null];
          l++;
          continue;
        }
        throw new W("Page dictionary kids object is not an array.");
      }
      for (let x = u.length - 1; x >= 0; x--) {
        const g = u[x];
        n.push(g), h === this.toplevelPagesDict && g instanceof le && !c.has(g) && c.put(g, s.fetchAsync(g));
      }
    }
    throw new Error(`Page index ${e} not found.`);
  }
  async getAllPageDicts(e = !1) {
    const {
      ignoreErrors: n
    } = this.pdfManager.evaluatorOptions, a = [{
      currentNode: this.toplevelPagesDict,
      posInKids: 0
    }], i = new St(), s = this.#t.getRaw("Pages");
    s instanceof le && i.put(s);
    const r = /* @__PURE__ */ new Map(), o = this.xref, c = this.pageIndexCache;
    let l = 0;
    function h(d, u) {
      u && !c.has(u) && c.put(u, l), r.set(l++, [d, u]);
    }
    function f(d) {
      if (d instanceof Ea && !e)
        throw d;
      e && n && l === 0 && (F(`getAllPageDicts - Skipping invalid first page: "${d}".`), d = B.empty), r.set(l++, [d, null]);
    }
    for (; a.length > 0; ) {
      const d = a.at(-1), {
        currentNode: u,
        posInKids: x
      } = d;
      let g = u.getRaw("Kids");
      if (g instanceof le)
        try {
          g = await o.fetchAsync(g);
        } catch (y) {
          f(y);
          break;
        }
      if (!Array.isArray(g)) {
        f(new W("Page dictionary kids object is not an array."));
        break;
      }
      if (x >= g.length) {
        a.pop();
        continue;
      }
      const p = g[x];
      let m;
      if (p instanceof le) {
        if (i.has(p)) {
          f(new W("Pages tree contains circular reference."));
          break;
        }
        i.put(p);
        try {
          m = await o.fetchAsync(p);
        } catch (y) {
          f(y);
          break;
        }
      } else
        m = p;
      if (!(m instanceof B)) {
        f(new W("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let b = m.getRaw("Type");
      if (b instanceof le)
        try {
          b = await o.fetchAsync(b);
        } catch (y) {
          f(y);
          break;
        }
      dt(b, "Page") || !m.has("Kids") ? h(m, p instanceof le ? p : null) : a.push({
        currentNode: m,
        posInKids: 0
      }), d.posInKids++;
    }
    return r;
  }
  getPageIndex(e) {
    const n = this.pageIndexCache.get(e);
    if (n !== void 0)
      return Promise.resolve(n);
    const a = this.xref;
    function i(o) {
      let c = 0, l;
      return a.fetchAsync(o).then(function(h) {
        if (Dr(o, e) && !s1(h, "Page") && !(h instanceof B && !h.has("Type") && h.has("Contents")))
          throw new W("The reference does not point to a /Page dictionary.");
        if (!h)
          return null;
        if (!(h instanceof B))
          throw new W("Node must be a dictionary.");
        return l = h.getRaw("Parent"), h.getAsync("Parent");
      }).then(function(h) {
        if (!h)
          return null;
        if (!(h instanceof B))
          throw new W("Parent must be a dictionary.");
        return h.getAsync("Kids");
      }).then(function(h) {
        if (!h)
          return null;
        const f = [];
        let d = !1;
        for (const u of h) {
          if (!(u instanceof le))
            throw new W("Kid must be a reference.");
          if (Dr(u, o)) {
            d = !0;
            break;
          }
          f.push(a.fetchAsync(u).then(function(x) {
            if (!(x instanceof B))
              throw new W("Kid node must be a dictionary.");
            x.has("Count") ? c += x.get("Count") : c++;
          }));
        }
        if (!d)
          throw new W("Kid reference not found in parent's kids.");
        return Promise.all(f).then(() => [c, l]);
      });
    }
    let s = 0;
    const r = (o) => i(o).then((c) => {
      if (!c)
        return this.pageIndexCache.put(e, s), s;
      const [l, h] = c;
      return s += l, r(h);
    });
    return r(e);
  }
  get baseUrl() {
    const e = this.#t.get("URI");
    if (e instanceof B) {
      const n = e.get("Base");
      if (typeof n == "string") {
        const a = Nr(n, null, {
          tryConvertEncoding: !0
        });
        if (a)
          return ae(this, "baseUrl", a.href);
      }
    }
    return ae(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({
    destDict: e,
    resultObj: n,
    docBaseUrl: a = null,
    docAttachments: i = null
  }) {
    if (!(e instanceof B)) {
      F("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let s = e.get("A"), r, o;
    if (s instanceof B || (e.has("Dest") ? s = e.get("Dest") : (s = e.get("AA"), s instanceof B && (s.has("D") ? s = s.get("D") : s.has("U") && (s = s.get("U"))))), s instanceof B) {
      const c = s.get("S");
      if (!(c instanceof Z)) {
        F("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const l = c.name;
      switch (l) {
        case "ResetForm":
          const h = s.get("Flags"), f = ((typeof h == "number" ? h : 0) & 1) === 0, d = [], u = [];
          for (const T of s.get("Fields") || [])
            T instanceof le ? u.push(T.toString()) : typeof T == "string" && d.push(Ve(T));
          n.resetForm = {
            fields: d,
            refs: u,
            include: f
          };
          break;
        case "URI":
          r = s.get("URI"), r instanceof Z && (r = "/" + r.name);
          break;
        case "GoTo":
          o = s.get("D");
          break;
        case "Launch":
        case "GoToR":
          const x = s.get("F");
          if (x instanceof B) {
            const T = new yo(x, null, !0), {
              rawFilename: M
            } = T.serializable;
            r = M;
          } else typeof x == "string" && (r = x);
          const g = Fl(s);
          g && typeof r == "string" && (r = r.split("#", 1)[0] + "#" + g);
          const p = s.get("NewWindow");
          typeof p == "boolean" && (n.newWindow = p);
          break;
        case "GoToE":
          const m = s.get("T");
          let b;
          if (i && m instanceof B) {
            const T = m.get("R"), M = m.get("N");
            dt(T, "C") && typeof M == "string" && (b = i[Ve(M, !0)]);
          }
          if (b) {
            n.attachment = b;
            const T = Fl(s);
            T && (n.attachmentDest = T);
          } else
            F('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const y = s.get("N");
          y instanceof Z && (n.action = y.name);
          break;
        case "SetOCGState":
          const w = s.get("State"), S = s.get("PreserveRB");
          if (!Array.isArray(w) || w.length === 0)
            break;
          const v = [];
          for (const T of w)
            if (T instanceof Z)
              switch (T.name) {
                case "ON":
                case "OFF":
                case "Toggle":
                  v.push(T.name);
                  break;
              }
            else T instanceof le && v.push(T.toString());
          if (v.length !== w.length)
            break;
          n.setOCGState = {
            state: v,
            preserveRB: typeof S == "boolean" ? S : !0
          };
          break;
        case "JavaScript":
          const k = s.get("JS");
          let A;
          k instanceof Ne ? A = k.getString() : typeof k == "string" && (A = k);
          const C = A && l1(Ve(A, !0));
          if (C) {
            r = C.url, n.newWindow = C.newWindow;
            break;
          }
        default:
          if (l === "JavaScript" || l === "SubmitForm")
            break;
          F(`parseDestDictionary - unsupported action: "${l}".`);
          break;
      }
    } else e.has("Dest") && (o = e.get("Dest"));
    if (typeof r == "string") {
      const c = Nr(r, a, {
        addDefaultProtocol: !0,
        tryConvertEncoding: !0
      });
      c && (n.url = c.href), n.unsafeUrl = r;
    }
    o && (o instanceof Z && (o = o.name), typeof o == "string" ? n.dest = Ve(o, !0) : _r(o) && (n.dest = o));
  }
}
function kx(t) {
  return t instanceof le || t instanceof B || t instanceof Ne || Array.isArray(t);
}
function Ax(t, e) {
  if (t instanceof B)
    t = t.getRawValues();
  else if (t instanceof Ne)
    t = t.dict.getRawValues();
  else if (!Array.isArray(t))
    return;
  for (const n of t)
    kx(n) && e.push(n);
}
class Hi {
  refSet = new St();
  constructor(e, n, a) {
    this.dict = e, this.keys = n, this.xref = a;
  }
  async load() {
    const {
      keys: e,
      dict: n
    } = this, a = [];
    for (const i of e) {
      const s = n.getRaw(i);
      s !== void 0 && a.push(s);
    }
    await this.#e(a), this.refSet = null;
  }
  async #e(e) {
    const n = [], a = [];
    for (; e.length; ) {
      let i = e.pop();
      if (i instanceof le) {
        if (this.refSet.has(i))
          continue;
        try {
          this.refSet.put(i), i = this.xref.fetch(i);
        } catch (s) {
          if (!(s instanceof ht)) {
            F(`ObjectLoader.#walk - requesting all data: "${s}".`), await this.xref.stream.manager.requestAllChunks();
            return;
          }
          n.push(i), a.push({
            begin: s.begin,
            end: s.end
          });
        }
      }
      if (i instanceof Ne) {
        const s = i.getBaseStreams();
        if (s) {
          let r = !1;
          for (const o of s)
            o.isDataLoaded || (r = !0, a.push({
              begin: o.start,
              end: o.end
            }));
          r && n.push(i);
        }
      }
      Ax(i, e);
    }
    if (a.length) {
      await this.xref.stream.manager.requestRanges(a);
      for (const i of n)
        i instanceof le && this.refSet.remove(i);
      await this.#e(n);
    }
  }
  static async load(e, n, a) {
    if (a.stream.isDataLoaded)
      return;
    await new Hi(e, n, a).load();
  }
}
const c0 = Symbol(), ai = Symbol(), gt = Symbol(), Ua = Symbol(), Pn = Symbol(), Ii = Symbol(), Br = Symbol(), jn = Symbol(), Zn = Symbol(), q = Symbol("content"), Mn = Symbol("data"), $i = Symbol(), $ = Symbol("extra"), st = Symbol(), qs = Symbol(), wo = Symbol(), K1 = Symbol(), ii = Symbol(), l0 = Symbol(), Hs = Symbol(), vs = Symbol(), Zo = Symbol(), Xt = Symbol(), Ss = Symbol(), Ut = Symbol(), Gi = Symbol(), ca = Symbol(), kt = Symbol(), Me = Symbol(), wt = Symbol(), it = Symbol(), $s = Symbol(), Ai = Symbol(), vo = Symbol(), Mr = Symbol(), Qo = Symbol(), di = Symbol(), Ti = Symbol(), Ta = Symbol(), ks = Symbol(), ga = Symbol(), ba = Symbol(), Gs = Symbol(), zs = Symbol(), Cx = Symbol(), vt = Symbol("namespaceId"), qe = Symbol("nodeName"), ei = Symbol(), ea = Symbol(), So = Symbol(), pa = Symbol(), ia = Symbol(), dn = Symbol(), Xi = Symbol(), Na = Symbol(), Y1 = Symbol("root"), gs = Symbol(), fa = Symbol(), ko = Symbol(), J1 = Symbol(), pn = Symbol(), Ln = Symbol(), Ft = Symbol(), Z1 = Symbol(), Ie = Symbol(), As = Symbol(), Xe = Symbol(), et = Symbol("uid");
We(531);
const zn = Symbol(), At = {
  config: {
    id: 0,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xci/")
  },
  connectionSet: {
    id: 1,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
  },
  datasets: {
    id: 2,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-data/")
  },
  form: {
    id: 3,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-form/")
  },
  localeSet: {
    id: 4,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
  },
  pdf: {
    id: 5,
    check: (t) => t === "http://ns.adobe.com/xdp/pdf/"
  },
  signature: {
    id: 6,
    check: (t) => t === "http://www.w3.org/2000/09/xmldsig#"
  },
  sourceSet: {
    id: 7,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-source-set/")
  },
  stylesheet: {
    id: 8,
    check: (t) => t === "http://www.w3.org/1999/XSL/Transform"
  },
  template: {
    id: 9,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-template/")
  },
  xdc: {
    id: 10,
    check: (t) => t.startsWith("http://www.xfa.org/schema/xdc/")
  },
  xdp: {
    id: 11,
    check: (t) => t === "http://ns.adobe.com/xdp/"
  },
  xfdf: {
    id: 12,
    check: (t) => t === "http://ns.adobe.com/xfdf/"
  },
  xhtml: {
    id: 13,
    check: (t) => t === "http://www.w3.org/1999/xhtml"
  },
  xmpmeta: {
    id: 14,
    check: (t) => t === "http://ns.adobe.com/xmpmeta/"
  }
}, Ix = {
  pt: (t) => t,
  cm: (t) => t / 2.54 * 72,
  mm: (t) => t / (10 * 2.54) * 72,
  in: (t) => t * 72,
  px: (t) => t
}, Tx = /([+-]?\d+\.?\d*)(.*)/;
function h0(t) {
  return t.startsWith("'") || t.startsWith('"') ? t.slice(1, -1) : t;
}
function Be({
  data: t,
  defaultValue: e,
  validate: n
}) {
  if (!t)
    return e;
  t = t.trim();
  const a = parseInt(t, 10);
  return !isNaN(a) && n(a) ? a : e;
}
function Wr({
  data: t,
  defaultValue: e,
  validate: n
}) {
  if (!t)
    return e;
  t = t.trim();
  const a = parseFloat(t);
  return !isNaN(a) && n(a) ? a : e;
}
function f0({
  data: t,
  defaultValue: e,
  validate: n
}) {
  return t ? (t = t.trim(), n(t) ? t : e) : e;
}
function Y(t, e) {
  return f0({
    data: t,
    defaultValue: e[0],
    validate: (n) => e.includes(n)
  });
}
function pe(t, e = "0") {
  if (e ||= "0", !t)
    return pe(e);
  const n = t.trim().match(Tx);
  if (!n)
    return pe(e);
  const [, a, i] = n, s = parseFloat(a);
  if (isNaN(s))
    return pe(e);
  if (s === 0)
    return 0;
  const r = Ix[i];
  return r ? r(s) : s;
}
function Rl(t) {
  if (!t)
    return {
      num: 1,
      den: 1
    };
  const e = t.split(":", 2).map((i) => parseFloat(i.trim())).filter((i) => !isNaN(i));
  if (e.length === 1 && e.push(1), e.length === 0)
    return {
      num: 1,
      den: 1
    };
  const [n, a] = e;
  return {
    num: n,
    den: a
  };
}
function _n(t) {
  return t ? t.trim().split(/\s+/).map((e) => ({
    excluded: e[0] === "-",
    viewname: e.substring(1)
  })) : [];
}
function Ex(t, e = [0, 0, 0]) {
  let [n, a, i] = e;
  if (!t)
    return {
      r: n,
      g: a,
      b: i
    };
  const s = t.split(",", 3).map((r) => Lt(parseInt(r.trim(), 10), 0, 255)).map((r) => isNaN(r) ? 0 : r);
  return s.length < 3 ? {
    r: n,
    g: a,
    b: i
  } : ([n, a, i] = s, {
    r: n,
    g: a,
    b: i
  });
}
function Fx(t) {
  if (!t)
    return {
      x: -1,
      y: -1,
      width: -1,
      height: -1
    };
  const n = t.split(",", 4).map((o) => pe(o.trim(), "-1"));
  if (n.length < 4 || n[2] < 0 || n[3] < 0)
    return {
      x: -1,
      y: -1,
      width: -1,
      height: -1
    };
  const [a, i, s, r] = n;
  return {
    x: a,
    y: i,
    width: s,
    height: r
  };
}
class Se {
  static get FAILURE() {
    return ae(this, "FAILURE", new Se(!1, null, null, null));
  }
  static get EMPTY() {
    return ae(this, "EMPTY", new Se(!0, null, null, null));
  }
  constructor(e, n, a, i) {
    this.success = e, this.html = n, this.bbox = a, this.breakNode = i;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(e) {
    return new Se(!1, null, null, e);
  }
  static success(e, n = null) {
    return new Se(!0, e, n, null);
  }
}
class Rx {
  constructor(e) {
    this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(e);
  }
  add(e, n = null) {
    for (const i of e)
      this.addPdfFont(i);
    for (const i of this.fonts.values())
      i.regular || (i.regular = i.italic || i.bold || i.bolditalic);
    if (!n || n.size === 0)
      return;
    const a = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const i of n)
      this.fonts.set(i, a);
  }
  addPdfFont(e) {
    const n = e.cssFontInfo, a = n.fontFamily;
    let i = this.fonts.get(a);
    i || (i = /* @__PURE__ */ Object.create(null), this.fonts.set(a, i), this.defaultFont || (this.defaultFont = i));
    let s = "";
    const r = parseFloat(n.fontWeight);
    parseFloat(n.italicAngle) !== 0 ? s = r >= 700 ? "bolditalic" : "italic" : r >= 700 && (s = "bold"), s || ((e.name.includes("Bold") || e.psName?.includes("Bold")) && (s = "bold"), (e.name.includes("Italic") || e.name.endsWith("It") || e.psName?.includes("Italic") || e.psName?.endsWith("It")) && (s += "italic")), s || (s = "regular"), i[s] = e;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(e, n = !0) {
    let a = this.fonts.get(e) || this.cache.get(e);
    if (a)
      return a;
    const i = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let s = e.replaceAll(i, "");
    if (a = this.fonts.get(s), a)
      return this.cache.set(e, a), a;
    s = s.toLowerCase();
    const r = [];
    for (const [o, c] of this.fonts.entries())
      o.replaceAll(i, "").toLowerCase().startsWith(s) && r.push(c);
    if (r.length === 0)
      for (const [, o] of this.fonts.entries())
        o.regular.name?.replaceAll(i, "").toLowerCase().startsWith(s) && r.push(o);
    if (r.length === 0) {
      s = s.replaceAll(/psmt|mt/gi, "");
      for (const [o, c] of this.fonts.entries())
        o.replaceAll(i, "").toLowerCase().startsWith(s) && r.push(c);
    }
    if (r.length === 0)
      for (const o of this.fonts.values())
        o.regular.name?.replaceAll(i, "").toLowerCase().startsWith(s) && r.push(o);
    return r.length >= 1 ? (r.length !== 1 && n && F(`XFA - Too many choices to guess the correct font: ${e}`), this.cache.set(e, r[0]), r[0]) : (n && !this.warned.has(e) && (this.warned.add(e), F(`XFA - Cannot find the font: ${e}`)), null);
  }
}
function ec(t, e) {
  return t.posture === "italic" ? t.weight === "bold" ? e.bolditalic : e.italic : t.weight === "bold" ? e.bold : e.regular;
}
function Ox(t, e = !1) {
  let n = null;
  if (t) {
    const r = h0(t.typeface), o = t[it].fontFinder.find(r);
    n = ec(t, o);
  }
  if (!n)
    return {
      lineHeight: 12,
      lineGap: 2,
      lineNoGap: 10
    };
  const a = t.size || 10, i = n.lineHeight ? Math.max(e ? 0 : 1.2, n.lineHeight) : 1.2, s = n.lineGap === void 0 ? 0.2 : n.lineGap;
  return {
    lineHeight: i * a,
    lineGap: s * a,
    lineNoGap: Math.max(1, i - s) * a
  };
}
const Bx = 1.02;
class Ol {
  constructor(e, n, a, i) {
    if (this.lineHeight = a, this.paraMargin = n || {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, !e) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(i);
      return;
    }
    this.xfaFont = {
      typeface: e.typeface,
      posture: e.posture,
      weight: e.weight,
      size: e.size,
      letterSpacing: e.letterSpacing
    };
    const s = i.find(e.typeface);
    if (!s) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(i);
      return;
    }
    this.pdfFont = ec(e, s), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(i));
  }
  defaultFont(e) {
    const n = e.find("Helvetica", !1) || e.find("Myriad Pro", !1) || e.find("Arial", !1) || e.getDefault();
    if (n?.regular) {
      const i = n.regular, r = {
        typeface: i.cssFontInfo.fontFamily,
        posture: "normal",
        weight: "normal",
        size: 10,
        letterSpacing: 0
      };
      return [i, r];
    }
    return [null, {
      typeface: "Courier",
      posture: "normal",
      weight: "normal",
      size: 10,
      letterSpacing: 0
    }];
  }
}
class Mx {
  constructor(e, n, a, i) {
    this.fontFinder = i, this.stack = [new Ol(e, n, a, i)];
  }
  pushData(e, n, a) {
    const i = this.stack.at(-1);
    for (const r of ["typeface", "posture", "weight", "size", "letterSpacing"])
      e[r] || (e[r] = i.xfaFont[r]);
    for (const r of ["top", "bottom", "left", "right"])
      isNaN(n[r]) && (n[r] = i.paraMargin[r]);
    const s = new Ol(e, n, a || i.lineHeight, this.fontFinder);
    s.pdfFont || (s.pdfFont = i.pdfFont), this.stack.push(s);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class Px {
  constructor(e, n, a, i) {
    this.glyphs = [], this.fontSelector = new Mx(e, n, a, i), this.extraHeight = 0;
  }
  pushData(e, n, a) {
    this.fontSelector.pushData(e, n, a);
  }
  popFont(e) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const e = this.fontSelector.topFont();
    this.extraHeight += e.paraMargin.top + e.paraMargin.bottom;
  }
  addString(e) {
    if (!e)
      return;
    const n = this.fontSelector.topFont(), a = n.xfaFont.size;
    if (n.pdfFont) {
      const i = n.xfaFont.letterSpacing, s = n.pdfFont, r = s.lineHeight || 1.2, o = n.lineHeight || Math.max(1.2, r) * a, c = s.lineGap === void 0 ? 0.2 : s.lineGap, l = r - c, h = Math.max(1, l) * a, f = a / 1e3, d = s.defaultWidth || s.charsToGlyphs(" ")[0].width;
      for (const u of e.split(/[\u2029\n]/)) {
        const x = s.encodeString(u).join(""), g = s.charsToGlyphs(x);
        for (const p of g) {
          const m = p.width || d;
          this.glyphs.push([m * f + i, o, h, p.unicode, !1]);
        }
        this.glyphs.push([0, 0, 0, `
`, !0]);
      }
      this.glyphs.pop();
      return;
    }
    for (const i of e.split(/[\u2029\n]/)) {
      for (const s of i.split(""))
        this.glyphs.push([a, 1.2 * a, a, s, !1]);
      this.glyphs.push([0, 0, 0, `
`, !0]);
    }
    this.glyphs.pop();
  }
  compute(e) {
    let n = -1, a = 0, i = 0, s = 0, r = 0, o = 0, c = !1, l = !0;
    for (let h = 0, f = this.glyphs.length; h < f; h++) {
      const [d, u, x, g, p] = this.glyphs[h], m = g === " ", b = l ? x : u;
      if (p) {
        i = Math.max(i, r), r = 0, s += o, o = b, n = -1, a = 0, l = !1;
        continue;
      }
      if (m) {
        r + d > e ? (i = Math.max(i, r), r = 0, s += o, o = b, n = -1, a = 0, c = !0, l = !1) : (o = Math.max(b, o), a = r, r += d, n = h);
        continue;
      }
      if (r + d > e) {
        s += o, o = b, n !== -1 ? (h = n, i = Math.max(i, a), r = 0, n = -1, a = 0) : (i = Math.max(i, r), r = d), c = !0, l = !1;
        continue;
      }
      r += d, o = Math.max(b, o);
    }
    return i = Math.max(i, r), s += o + this.extraHeight, {
      width: Bx * i,
      height: s,
      isBroken: c
    };
  }
}
const Bl = /^[^.[]+/, Nx = /^[^\]]+/, Sn = {
  dot: 0,
  dotDot: 1,
  dotHash: 2,
  dotBracket: 3,
  dotParen: 4
}, Q1 = /* @__PURE__ */ new Map([["$data", (t, e) => t.datasets ? t.datasets.data : t], ["$record", (t, e) => (t.datasets ? t.datasets.data : t)[Ut]()[0]], ["$template", (t, e) => t.template], ["$connectionSet", (t, e) => t.connectionSet], ["$form", (t, e) => t.form], ["$layout", (t, e) => t.layout], ["$host", (t, e) => t.host], ["$dataWindow", (t, e) => t.dataWindow], ["$event", (t, e) => t.event], ["!", (t, e) => t.datasets], ["$xfa", (t, e) => t], ["xfa", (t, e) => t], ["$", (t, e) => e]]), Ml = /* @__PURE__ */ new WeakMap();
function Dx(t) {
  return t = t.trim(), t === "*" ? 1 / 0 : parseInt(t, 10) || 0;
}
function eh(t, e, n = !0) {
  let a = t.match(Bl);
  if (!a)
    return null;
  let [i] = a;
  const s = [{
    name: i,
    cacheName: "." + i,
    index: 0,
    js: null,
    formCalc: null,
    operator: Sn.dot
  }];
  let r = i.length;
  for (; r < t.length; ) {
    const o = r;
    if (t.charAt(r++) === "[") {
      if (a = t.slice(r).match(Nx), !a)
        return F("XFA - Invalid index in SOM expression"), null;
      s.at(-1).index = Dx(a[0]), r += a[0].length + 1;
      continue;
    }
    let l;
    switch (t.charAt(r)) {
      case ".":
        if (!e)
          return null;
        r++, l = Sn.dotDot;
        break;
      case "#":
        r++, l = Sn.dotHash;
        break;
      case "[":
        if (n)
          return F("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        l = Sn.dotBracket;
        break;
      case "(":
        if (n)
          return F("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        l = Sn.dotParen;
        break;
      default:
        l = Sn.dot;
        break;
    }
    if (a = t.slice(r).match(Bl), !a)
      break;
    [i] = a, r += i.length, s.push({
      name: i,
      cacheName: t.slice(o, r),
      operator: l,
      index: 0,
      js: null,
      formCalc: null
    });
  }
  return s;
}
function Ca(t, e, n, a = !0, i = !0) {
  const s = eh(n, a);
  if (!s)
    return null;
  const r = Q1.get(s[0].name);
  let o = 0, c;
  r ? (c = !0, t = [r(t, e)], o = 1) : (c = e === null, t = [e || t]);
  for (let l = s.length; o < l; o++) {
    const {
      name: h,
      cacheName: f,
      operator: d,
      index: u
    } = s[o], x = [];
    for (const g of t) {
      if (!g.isXFAObject)
        continue;
      let p, m;
      if (i && (m = Ml.get(g), m || (m = /* @__PURE__ */ new Map(), Ml.set(g, m)), p = m.get(f)), !p) {
        switch (d) {
          case Sn.dot:
            p = g[Hs](h, !1);
            break;
          case Sn.dotDot:
            p = g[Hs](h, !0);
            break;
          case Sn.dotHash:
            p = g[l0](h), p = p.isXFAObjectArray ? p.children : [p];
            break;
        }
        i && m.set(f, p);
      }
      p.length > 0 && x.push(p);
    }
    if (x.length === 0 && !c && o === 0) {
      if (e = e[Me](), !e)
        return null;
      o = -1, t = [e];
      continue;
    }
    t = isFinite(u) ? x.filter((g) => u < g.length).map((g) => g[u]) : x.flat();
  }
  return t.length === 0 ? null : t;
}
function Lx(t, e, n) {
  const a = eh(n);
  if (!a || a.some((r) => r.operator === Sn.dotDot))
    return null;
  const i = Q1.get(a[0].name);
  let s = 0;
  i ? (t = i(t, e), s = 1) : t = e || t;
  for (let r = a.length; s < r; s++) {
    const {
      name: o,
      operator: c,
      index: l
    } = a[s];
    if (!isFinite(l))
      return a[s].index = 0, t.createNodes(a.slice(s));
    let h;
    switch (c) {
      case Sn.dot:
        h = t[Hs](o, !1);
        break;
      case Sn.dotDot:
        h = t[Hs](o, !0);
        break;
      case Sn.dotHash:
        h = t[l0](o), h = h.isXFAObjectArray ? h.children : [h];
        break;
    }
    if (h.length === 0)
      return t.createNodes(a.slice(s));
    if (l < h.length) {
      const f = h[l];
      if (!f.isXFAObject)
        return F("XFA - Cannot create a node."), null;
      t = f;
    } else
      return a[s].index = l - h.length, t.createNodes(a.slice(s));
  }
  return null;
}
const Sr = Symbol(), Va = Symbol(), vi = Symbol(), Le = Symbol("_children"), H0 = Symbol(), va = Symbol(), $0 = Symbol(), Pl = Symbol(), G0 = Symbol(), Nl = Symbol(), z0 = Symbol(), ps = Symbol(), kr = Symbol(), Fn = Symbol("parent"), ls = Symbol(), hs = Symbol(), _0 = Symbol();
let Ao = 0;
const th = At.datasets.id;
class z {
  constructor(e, n, a = !1) {
    this[vt] = e, this[qe] = n, this[z0] = a, this[Fn] = null, this[Le] = [], this[et] = `${n}${Ao++}`, this[it] = null;
  }
  get isXFAObject() {
    return !0;
  }
  get isXFAObjectArray() {
    return !1;
  }
  createNodes(e) {
    let n = this, a = null;
    for (const {
      name: i,
      index: s
    } of e) {
      for (let r = 0, o = isFinite(s) ? s : 0; r <= o; r++) {
        const c = n[vt] === th ? -1 : n[vt];
        a = new ta(c, i), n[gt](a);
      }
      n = a;
    }
    return a;
  }
  [ea](e) {
    if (!this[z0] || !this[So](e))
      return !1;
    const n = e[qe], a = this[n];
    if (a instanceof E) {
      if (a.push(e))
        return this[gt](e), !0;
    } else
      return a !== null && this[Na](a), this[n] = e, this[gt](e), !0;
    let i = "";
    return this.id ? i = ` (id: ${this.id})` : this.name && (i = ` (name: ${this.name} ${this.h.value})`), F(`XFA - node "${this[qe]}"${i} has already enough "${n}"!`), !1;
  }
  [So](e) {
    return this.hasOwnProperty(e[qe]) && e[vt] === this[vt];
  }
  [ks]() {
    return !1;
  }
  [c0]() {
    return !1;
  }
  [Qo]() {
    return !1;
  }
  [di]() {
    return !1;
  }
  [dn]() {
    this.para && this[wt]()[$].paraStack.pop();
  }
  [Xi]() {
    this[wt]()[$].paraStack.push(this.para);
  }
  [ko](e) {
    this.id && this[vt] === At.template.id && e.set(this.id, this);
  }
  [wt]() {
    return this[it].template;
  }
  [ga]() {
    return !1;
  }
  [ba]() {
    return !1;
  }
  [gt](e) {
    e[Fn] = this, this[Le].push(e), !e[it] && this[it] && (e[it] = this[it]);
  }
  [Na](e) {
    const n = this[Le].indexOf(e);
    this[Le].splice(n, 1);
  }
  [$s]() {
    return this.hasOwnProperty("value");
  }
  [pn](e) {
  }
  [pa](e) {
  }
  [st]() {
  }
  [Pn](e) {
    delete this[z0], this[Br] && (e.clean(this[Br]), delete this[Br]);
  }
  [vo](e) {
    return this[Le].indexOf(e);
  }
  [Mr](e, n) {
    n[Fn] = this, this[Le].splice(e, 0, n), !n[it] && this[it] && (n[it] = this[it]);
  }
  [Gs]() {
    return !this.name;
  }
  [Cx]() {
    return "";
  }
  [Ft]() {
    return this[Le].length === 0 ? this[q] : this[Le].map((e) => e[Ft]()).join("");
  }
  get [vi]() {
    const e = Object.getPrototypeOf(this);
    if (!e._attributes) {
      const n = e._attributes = /* @__PURE__ */ new Set();
      for (const a of Object.getOwnPropertyNames(this)) {
        if (this[a] === null || this[a] instanceof z || this[a] instanceof E)
          break;
        n.add(a);
      }
    }
    return ae(this, vi, e._attributes);
  }
  [Ta](e) {
    let n = this;
    for (; n; ) {
      if (n === e)
        return !0;
      n = n[Me]();
    }
    return !1;
  }
  [Me]() {
    return this[Fn];
  }
  [kt]() {
    return this[Me]();
  }
  [Ut](e = null) {
    return e ? this[e] : this[Le];
  }
  [$i]() {
    const e = /* @__PURE__ */ Object.create(null);
    this[q] && (e.$content = this[q]);
    for (const n of Object.getOwnPropertyNames(this)) {
      const a = this[n];
      a !== null && (a instanceof z ? e[n] = a[$i]() : a instanceof E ? a.isEmpty() || (e[n] = a.dump()) : e[n] = a);
    }
    return e;
  }
  [Xe]() {
    return null;
  }
  [Ie]() {
    return Se.EMPTY;
  }
  *[Gi]() {
    for (const e of this[Ut]())
      yield e;
  }
  *[Pl](e, n) {
    for (const a of this[Gi]())
      if (!e || n === e.has(a[qe])) {
        const i = this[ii](), s = a[Ie](i);
        s.success || (this[$].failingNode = a), yield s;
      }
  }
  [qs]() {
    return null;
  }
  [ai](e, n) {
    this[$].children.push(e);
  }
  [ii]() {
  }
  [Ua]({
    filter: e = null,
    include: n = !0
  }) {
    if (!this[$].generator)
      this[$].generator = this[Pl](e, n);
    else {
      const a = this[ii](), i = this[$].failingNode[Ie](a);
      if (!i.success)
        return i;
      i.html && this[ai](i.html, i.bbox), delete this[$].failingNode;
    }
    for (; ; ) {
      const a = this[$].generator.next();
      if (a.done)
        break;
      const i = a.value;
      if (!i.success)
        return i;
      i.html && this[ai](i.html, i.bbox);
    }
    return this[$].generator = null, Se.EMPTY;
  }
  [J1](e) {
    this[hs] = new Set(Object.keys(e));
  }
  [Nl](e) {
    const n = this[vi], a = this[hs];
    return [...e].filter((i) => n.has(i) && !a.has(i));
  }
  [gs](e, n = /* @__PURE__ */ new Set()) {
    for (const a of this[Le])
      a[ls](e, n);
  }
  [ls](e, n) {
    const a = this[G0](e, n);
    a ? this[Sr](a, e, n) : this[gs](e, n);
  }
  [G0](e, n) {
    const {
      use: a,
      usehref: i
    } = this;
    if (!a && !i)
      return null;
    let s = null, r = null, o = null, c = a;
    if (i ? (c = i, i.startsWith("#som(") && i.endsWith(")") ? r = i.slice(5, -1) : i.startsWith(".#som(") && i.endsWith(")") ? r = i.slice(6, -1) : i.startsWith("#") ? o = i.slice(1) : i.startsWith(".#") && (o = i.slice(2))) : a.startsWith("#") ? o = a.slice(1) : r = a, this.use = this.usehref = "", o ? s = e.get(o) : (s = Ca(e.get(Y1), this, r, !0, !1), s && (s = s[0])), !s)
      return F(`XFA - Invalid prototype reference: ${c}.`), null;
    if (s[qe] !== this[qe])
      return F(`XFA - Incompatible prototype: ${s[qe]} !== ${this[qe]}.`), null;
    if (n.has(s))
      return F("XFA - Cycle detected in prototypes use."), null;
    n.add(s);
    const l = s[G0](e, n);
    return l && s[Sr](l, e, n), s[gs](e, n), n.delete(s), s;
  }
  [Sr](e, n, a) {
    if (a.has(e)) {
      F("XFA - Cycle detected in prototypes use.");
      return;
    }
    !this[q] && e[q] && (this[q] = e[q]), new Set(a).add(e);
    for (const s of this[Nl](e[hs]))
      this[s] = e[s], this[hs] && this[hs].add(s);
    for (const s of Object.getOwnPropertyNames(this)) {
      if (this[vi].has(s))
        continue;
      const r = this[s], o = e[s];
      if (r instanceof E) {
        for (const c of r[Le])
          c[ls](n, a);
        for (let c = r[Le].length, l = o[Le].length; c < l; c++) {
          const h = e[Le][c][jn]();
          if (r.push(h))
            h[Fn] = this, this[Le].push(h), h[ls](n, a);
          else
            break;
        }
        continue;
      }
      if (r !== null) {
        r[gs](n, a), o && r[Sr](o, n, a);
        continue;
      }
      if (o !== null) {
        const c = o[jn]();
        c[Fn] = this, this[s] = c, this[Le].push(c), c[ls](n, a);
      }
    }
  }
  static [H0](e) {
    return Array.isArray(e) ? e.map((n) => z[H0](n)) : typeof e == "object" && e !== null ? Object.assign({}, e) : e;
  }
  [jn]() {
    const e = Object.create(Object.getPrototypeOf(this));
    for (const n of Object.getOwnPropertySymbols(this))
      try {
        e[n] = this[n];
      } catch {
        ae(e, n, this[n]);
      }
    e[et] = `${e[qe]}${Ao++}`, e[Le] = [];
    for (const n of Object.getOwnPropertyNames(this)) {
      if (this[vi].has(n)) {
        e[n] = z[H0](this[n]);
        continue;
      }
      const a = this[n];
      e[n] = a instanceof E ? new E(a[ps]) : null;
    }
    for (const n of this[Le]) {
      const a = n[qe], i = n[jn]();
      e[Le].push(i), i[Fn] = e, e[a] === null ? e[a] = i : e[a][Le].push(i);
    }
    return e;
  }
  [Ut](e = null) {
    return e ? this[Le].filter((n) => n[qe] === e) : this[Le];
  }
  [l0](e) {
    return this[e];
  }
  [Hs](e, n, a = !0) {
    return Array.from(this[vs](e, n, a));
  }
  *[vs](e, n, a = !0) {
    if (e === "parent") {
      yield this[Fn];
      return;
    }
    for (const i of this[Le])
      i[qe] === e && (yield i), i.name === e && (yield i), (n || i[Gs]()) && (yield* i[vs](e, n, !1));
    a && this[vi].has(e) && (yield new tc(this, e, this[e]));
  }
}
class E {
  constructor(e = 1 / 0) {
    this[ps] = e, this[Le] = [];
  }
  get isXFAObject() {
    return !1;
  }
  get isXFAObjectArray() {
    return !0;
  }
  push(e) {
    return this[Le].length <= this[ps] ? (this[Le].push(e), !0) : (F(`XFA - node "${e[qe]}" accepts no more than ${this[ps]} children`), !1);
  }
  isEmpty() {
    return this[Le].length === 0;
  }
  dump() {
    return this[Le].length === 1 ? this[Le][0][$i]() : this[Le].map((e) => e[$i]());
  }
  [jn]() {
    const e = new E(this[ps]);
    return e[Le] = this[Le].map((n) => n[jn]()), e;
  }
  get children() {
    return this[Le];
  }
  clear() {
    this[Le].length = 0;
  }
}
class tc {
  constructor(e, n, a) {
    this[Fn] = e, this[qe] = n, this[q] = a, this[Zn] = !1, this[et] = `attribute${Ao++}`;
  }
  [Me]() {
    return this[Fn];
  }
  [Ti]() {
    return !0;
  }
  [Zo]() {
    return this[q].trim();
  }
  [pn](e) {
    e = e.value || "", this[q] = e.toString();
  }
  [Ft]() {
    return this[q];
  }
  [Ta](e) {
    return this[Fn] === e || this[Fn][Ta](e);
  }
}
class ta extends z {
  constructor(e, n, a = {}) {
    if (super(e, n), this[q] = "", this[va] = null, n !== "#text") {
      const i = /* @__PURE__ */ new Map();
      this[Va] = i;
      for (const [s, r] of Object.entries(a))
        i.set(s, new tc(this, s, r));
      if (a.hasOwnProperty(ei)) {
        const s = a[ei].xfa.dataNode;
        s !== void 0 && (s === "dataGroup" ? this[va] = !1 : s === "dataValue" && (this[va] = !0));
      }
    }
    this[Zn] = !1;
  }
  [As](e) {
    const n = this[qe];
    if (n === "#text") {
      e.push(Oi(this[q]));
      return;
    }
    const a = Y0(n), i = this[vt] === th ? "xfa:" : "";
    e.push(`<${i}${a}`);
    for (const [s, r] of this[Va].entries()) {
      const o = Y0(s);
      e.push(` ${o}="${Oi(r[q])}"`);
    }
    if (this[va] !== null && (this[va] ? e.push(' xfa:dataNode="dataValue"') : e.push(' xfa:dataNode="dataGroup"')), !this[q] && this[Le].length === 0) {
      e.push("/>");
      return;
    }
    if (e.push(">"), this[q])
      typeof this[q] == "string" ? e.push(Oi(this[q])) : this[q][As](e);
    else
      for (const s of this[Le])
        s[As](e);
    e.push(`</${i}${a}>`);
  }
  [ea](e) {
    if (this[q]) {
      const n = new ta(this[vt], "#text");
      this[gt](n), n[q] = this[q], this[q] = "";
    }
    return this[gt](e), !0;
  }
  [pa](e) {
    this[q] += e;
  }
  [st]() {
    if (this[q] && this[Le].length > 0) {
      const e = new ta(this[vt], "#text");
      this[gt](e), e[q] = this[q], delete this[q];
    }
  }
  [Ie]() {
    return this[qe] === "#text" ? Se.success({
      name: "#text",
      value: this[q]
    }) : Se.EMPTY;
  }
  [Ut](e = null) {
    return e ? this[Le].filter((n) => n[qe] === e) : this[Le];
  }
  [K1]() {
    return this[Va];
  }
  [l0](e) {
    const n = this[Va].get(e);
    return n !== void 0 ? n : this[Ut](e);
  }
  *[vs](e, n) {
    const a = this[Va].get(e);
    a && (yield a);
    for (const i of this[Le])
      i[qe] === e && (yield i), n && (yield* i[vs](e, n));
  }
  *[wo](e, n) {
    const a = this[Va].get(e);
    a && (!n || !a[Zn]) && (yield a);
    for (const i of this[Le])
      yield* i[wo](e, n);
  }
  *[Ss](e, n, a) {
    for (const i of this[Le])
      i[qe] === e && (!a || !i[Zn]) && (yield i), n && (yield* i[Ss](e, n, a));
  }
  [Ti]() {
    return this[va] === null ? this[Le].length === 0 || this[Le][0][vt] === At.xhtml.id : this[va];
  }
  [Zo]() {
    return this[va] === null ? this[Le].length === 0 ? this[q].trim() : this[Le][0][vt] === At.xhtml.id ? this[Le][0][Ft]().trim() : null : this[q].trim();
  }
  [pn](e) {
    e = e.value || "", this[q] = e.toString();
  }
  [$i](e = !1) {
    const n = /* @__PURE__ */ Object.create(null);
    e && (n.$ns = this[vt]), this[q] && (n.$content = this[q]), n.$name = this[qe], n.children = [];
    for (const a of this[Le])
      n.children.push(a[$i](e));
    n.attributes = /* @__PURE__ */ Object.create(null);
    for (const [a, i] of this[Va])
      n.attributes[a] = i[q];
    return n;
  }
}
class mt extends z {
  constructor(e, n) {
    super(e, n), this[q] = "";
  }
  [pa](e) {
    this[q] += e;
  }
  [st]() {
  }
}
class tt extends mt {
  constructor(e, n, a) {
    super(e, n), this[kr] = a;
  }
  [st]() {
    this[q] = f0({
      data: this[q],
      defaultValue: this[kr][0],
      validate: (e) => this[kr].includes(e)
    });
  }
  [Pn](e) {
    super[Pn](e), delete this[kr];
  }
}
class $e extends mt {
  [st]() {
    this[q] = this[q].trim();
  }
}
class Wn extends mt {
  constructor(e, n, a, i) {
    super(e, n), this[$0] = a, this[_0] = i;
  }
  [st]() {
    this[q] = Be({
      data: this[q],
      defaultValue: this[$0],
      validate: this[_0]
    });
  }
  [Pn](e) {
    super[Pn](e), delete this[$0], delete this[_0];
  }
}
class Rt extends Wn {
  constructor(e, n) {
    super(e, n, 0, (a) => a === 1);
  }
}
class nh extends Wn {
  constructor(e, n) {
    super(e, n, 1, (a) => a === 0);
  }
}
function Oe(t) {
  return typeof t == "string" ? "0px" : Number.isInteger(t) ? `${t}px` : `${t.toFixed(2)}px`;
}
const Dl = {
  anchorType(t, e) {
    const n = t[kt]();
    if (!(!n || n.layout && n.layout !== "position"))
      switch ("transform" in e || (e.transform = ""), t.anchorType) {
        case "bottomCenter":
          e.transform += "translate(-50%, -100%)";
          break;
        case "bottomLeft":
          e.transform += "translate(0,-100%)";
          break;
        case "bottomRight":
          e.transform += "translate(-100%,-100%)";
          break;
        case "middleCenter":
          e.transform += "translate(-50%,-50%)";
          break;
        case "middleLeft":
          e.transform += "translate(0,-50%)";
          break;
        case "middleRight":
          e.transform += "translate(-100%,-50%)";
          break;
        case "topCenter":
          e.transform += "translate(-50%,0)";
          break;
        case "topRight":
          e.transform += "translate(-100%,0)";
          break;
      }
  },
  dimensions(t, e) {
    const n = t[kt]();
    let a = t.w;
    const i = t.h;
    if (n.layout?.includes("row")) {
      const s = n[$], r = t.colSpan;
      let o;
      r === -1 ? (o = Math.sumPrecise(s.columnWidths.slice(s.currentColumn)), s.currentColumn = 0) : (o = Math.sumPrecise(s.columnWidths.slice(s.currentColumn, s.currentColumn + r)), s.currentColumn = (s.currentColumn + t.colSpan) % s.columnWidths.length), isNaN(o) || (a = t.w = o);
    }
    e.width = a !== "" ? Oe(a) : "auto", e.height = i !== "" ? Oe(i) : "auto";
  },
  position(t, e) {
    const n = t[kt]();
    n?.layout && n.layout !== "position" || (e.position = "absolute", e.left = Oe(t.x), e.top = Oe(t.y));
  },
  rotate(t, e) {
    t.rotate && ("transform" in e || (e.transform = ""), e.transform += `rotate(-${t.rotate}deg)`, e.transformOrigin = "top left");
  },
  presence(t, e) {
    switch (t.presence) {
      case "invisible":
        e.visibility = "hidden";
        break;
      case "hidden":
      case "inactive":
        e.display = "none";
        break;
    }
  },
  hAlign(t, e) {
    if (t[qe] === "para")
      switch (t.hAlign) {
        case "justifyAll":
          e.textAlign = "justify-all";
          break;
        case "radix":
          e.textAlign = "left";
          break;
        default:
          e.textAlign = t.hAlign;
      }
    else
      switch (t.hAlign) {
        case "left":
          e.alignSelf = "start";
          break;
        case "center":
          e.alignSelf = "center";
          break;
        case "right":
          e.alignSelf = "end";
          break;
      }
  },
  margin(t, e) {
    t.margin && (e.margin = t.margin[Xe]().margin);
  }
};
function ah(t, e) {
  t[kt]().layout === "position" && (t.minW > 0 && (e.minWidth = Oe(t.minW)), t.maxW > 0 && (e.maxWidth = Oe(t.maxW)), t.minH > 0 && (e.minHeight = Oe(t.minH)), t.maxH > 0 && (e.maxHeight = Oe(t.maxH)));
}
function Ll(t, e, n, a, i, s) {
  const r = new Px(e, n, a, i);
  return typeof t == "string" ? r.addString(t) : t[ia](r), r.compute(s);
}
function nc(t, e) {
  let n = null, a = null, i = !1;
  if ((!t.w || !t.h) && t.value) {
    let s = 0, r = 0;
    t.margin && (s = t.margin.leftInset + t.margin.rightInset, r = t.margin.topInset + t.margin.bottomInset);
    let o = null, c = null;
    t.para && (c = /* @__PURE__ */ Object.create(null), o = t.para.lineHeight === "" ? null : t.para.lineHeight, c.top = t.para.spaceAbove === "" ? 0 : t.para.spaceAbove, c.bottom = t.para.spaceBelow === "" ? 0 : t.para.spaceBelow, c.left = t.para.marginLeft === "" ? 0 : t.para.marginLeft, c.right = t.para.marginRight === "" ? 0 : t.para.marginRight);
    let l = t.font;
    if (!l) {
      const d = t[wt]();
      let u = t[Me]();
      for (; u && u !== d; ) {
        if (u.font) {
          l = u.font;
          break;
        }
        u = u[Me]();
      }
    }
    const h = (t.w || e.width) - s, f = t[it].fontFinder;
    if (t.value.exData && t.value.exData[q] && t.value.exData.contentType === "text/html") {
      const d = Ll(t.value.exData[q], l, c, o, f, h);
      a = d.width, n = d.height, i = d.isBroken;
    } else {
      const d = t.value[Ft]();
      if (d) {
        const u = Ll(d, l, c, o, f, h);
        a = u.width, n = u.height, i = u.isBroken;
      }
    }
    a !== null && !t.w && (a += s), n !== null && !t.h && (n += r);
  }
  return {
    w: a,
    h: n,
    isBroken: i
  };
}
function ih(t, e, n) {
  let a;
  if (t.w !== "" && t.h !== "")
    a = [t.x, t.y, t.w, t.h];
  else {
    if (!n)
      return null;
    let i = t.w;
    if (i === "") {
      if (t.maxW === 0) {
        const r = t[kt]();
        i = r.layout === "position" && r.w !== "" ? 0 : t.minW;
      } else
        i = Math.min(t.maxW, n.width);
      e.attributes.style.width = Oe(i);
    }
    let s = t.h;
    if (s === "") {
      if (t.maxH === 0) {
        const r = t[kt]();
        s = r.layout === "position" && r.h !== "" ? 0 : t.minH;
      } else
        s = Math.min(t.maxH, n.height);
      e.attributes.style.height = Oe(s);
    }
    a = [t.x, t.y, i, s];
  }
  return a;
}
function u0(t) {
  const e = t[kt]();
  if (e.layout?.includes("row")) {
    const n = e[$], a = t.colSpan;
    let i;
    a === -1 ? i = Math.sumPrecise(n.columnWidths.slice(n.currentColumn)) : i = Math.sumPrecise(n.columnWidths.slice(n.currentColumn, n.currentColumn + a)), isNaN(i) || (t.w = i);
  }
  e.layout && e.layout !== "position" && (t.x = t.y = 0), t.layout === "table" && t.w === "" && Array.isArray(t.columnWidths) && (t.w = Math.sumPrecise(t.columnWidths));
}
function sh(t) {
  switch (t.layout) {
    case "position":
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
    default:
      return "xfaPosition";
  }
}
function ln(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const a of e) {
    const i = t[a];
    if (i !== null) {
      if (Dl.hasOwnProperty(a)) {
        Dl[a](t, n);
        continue;
      }
      if (i instanceof z) {
        const s = i[Xe]();
        s ? Object.assign(n, s) : F(`(DEBUG) - XFA - style for ${a} not implemented yet`);
      }
    }
  }
  return n;
}
function si(t, e) {
  const {
    attributes: n
  } = e, {
    style: a
  } = n, i = {
    name: "div",
    attributes: {
      class: ["xfaWrapper"],
      style: /* @__PURE__ */ Object.create(null)
    },
    children: []
  };
  if (n.class.push("xfaWrapped"), t.border) {
    const {
      widths: s,
      insets: r
    } = t.border[$];
    let o, c, l = r[0], h = r[3];
    const f = r[0] + r[2], d = r[1] + r[3];
    switch (t.border.hand) {
      case "even":
        l -= s[0] / 2, h -= s[3] / 2, o = `calc(100% + ${(s[1] + s[3]) / 2 - d}px)`, c = `calc(100% + ${(s[0] + s[2]) / 2 - f}px)`;
        break;
      case "left":
        l -= s[0], h -= s[3], o = `calc(100% + ${s[1] + s[3] - d}px)`, c = `calc(100% + ${s[0] + s[2] - f}px)`;
        break;
      case "right":
        o = d ? `calc(100% - ${d}px)` : "100%", c = f ? `calc(100% - ${f}px)` : "100%";
        break;
    }
    const u = ["xfaBorder"];
    qi(t.border) && u.push("xfaPrintOnly");
    const x = {
      name: "div",
      attributes: {
        class: u,
        style: {
          top: `${l}px`,
          left: `${h}px`,
          width: o,
          height: c
        }
      },
      children: []
    };
    for (const g of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
      a[g] !== void 0 && (x.attributes.style[g] = a[g], delete a[g]);
    i.children.push(x, e);
  } else
    i.children.push(e);
  for (const s of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
    a[s] !== void 0 && (i.attributes.style[s] = a[s], delete a[s]);
  return i.attributes.style.position = a.position === "absolute" ? "absolute" : "relative", delete a.position, a.alignSelf && (i.attributes.style.alignSelf = a.alignSelf, delete a.alignSelf), i;
}
function rh(t) {
  const e = pe(t.textIndent, "0px");
  if (e >= 0)
    return;
  const a = "padding" + ((t.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), i = pe(t[a], "0px");
  t[a] = `${i - e}px`;
}
function ac(t, e) {
  switch (t.access) {
    case "nonInteractive":
      e.push("xfaNonInteractive");
      break;
    case "readOnly":
      e.push("xfaReadOnly");
      break;
    case "protected":
      e.push("xfaDisabled");
      break;
  }
}
function qi(t) {
  return t.relevant.length > 0 && !t.relevant[0].excluded && t.relevant[0].viewname === "print";
}
function oh(t) {
  const e = t[wt]()[$].paraStack;
  return e.length ? e.at(-1) : null;
}
function ch(t, e, n) {
  if (n.attributes.class?.includes("xfaRich")) {
    e && (t.h === "" && (e.height = "auto"), t.w === "" && (e.width = "auto"));
    const a = oh(t);
    if (a) {
      const i = n.attributes.style;
      switch (i.display = "flex", i.flexDirection = "column", a.vAlign) {
        case "top":
          i.justifyContent = "start";
          break;
        case "bottom":
          i.justifyContent = "end";
          break;
        case "middle":
          i.justifyContent = "center";
          break;
      }
      const s = a[Xe]();
      for (const [r, o] of Object.entries(s))
        r in i || (i[r] = o);
    }
  }
}
function lh(t, e, n, a) {
  if (!n) {
    delete a.fontFamily;
    return;
  }
  const i = h0(t.typeface);
  a.fontFamily = `"${i}"`;
  const s = n.find(i);
  if (s) {
    const {
      fontFamily: r
    } = s.regular.cssFontInfo;
    r !== i && (a.fontFamily = `"${r}"`);
    const o = oh(e);
    if (o && o.lineHeight !== "" || a.lineHeight)
      return;
    const c = ec(t, s);
    c && (a.lineHeight = Math.max(1.2, c.lineHeight));
  }
}
function hh(t) {
  const e = Nr(t, null, {
    addDefaultProtocol: !0,
    tryConvertEncoding: !0
  });
  return e ? e.href : null;
}
function fh(t, e) {
  return {
    name: "div",
    attributes: {
      class: [t.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
    },
    children: e
  };
}
function uh(t) {
  if (!t[$])
    return null;
  const n = {
    name: "div",
    attributes: t[$].attributes,
    children: t[$].children
  };
  if (t[$].failingNode) {
    const a = t[$].failingNode[qs]();
    a && (t.layout.endsWith("-tb") ? n.children.push(fh(t, [a])) : n.children.push(a));
  }
  return n.children.length === 0 ? null : n;
}
function dh(t, e, n) {
  const a = t[$], i = a.availableSpace, [s, r, o, c] = n;
  switch (t.layout) {
    case "position": {
      a.width = Math.max(a.width, s + o), a.height = Math.max(a.height, r + c), a.children.push(e);
      break;
    }
    case "lr-tb":
    case "rl-tb":
      (!a.line || a.attempt === 1) && (a.line = fh(t, []), a.children.push(a.line), a.numberInLine = 0), a.numberInLine += 1, a.line.children.push(e), a.attempt === 0 ? (a.currentWidth += o, a.height = Math.max(a.height, a.prevHeight + c)) : (a.currentWidth = o, a.prevHeight = a.height, a.height += c, a.attempt = 0), a.width = Math.max(a.width, a.currentWidth);
      break;
    case "rl-row":
    case "row": {
      a.children.push(e), a.width += o, a.height = Math.max(a.height, c);
      const l = Oe(a.height);
      for (const h of a.children)
        h.attributes.style.height = l;
      break;
    }
    case "table": {
      a.width = Lt(o, a.width, i.width), a.height += c, a.children.push(e);
      break;
    }
    case "tb": {
      a.width = Lt(o, a.width, i.width), a.height += c, a.children.push(e);
      break;
    }
  }
}
function xh(t) {
  const e = t[$].availableSpace, n = t.margin ? t.margin.topInset + t.margin.bottomInset : 0, a = t.margin ? t.margin.leftInset + t.margin.rightInset : 0;
  switch (t.layout) {
    case "lr-tb":
    case "rl-tb":
      return t[$].attempt === 0 ? {
        width: e.width - a - t[$].currentWidth,
        height: e.height - n - t[$].prevHeight
      } : {
        width: e.width - a,
        height: e.height - n - t[$].height
      };
    case "rl-row":
    case "row":
      return {
        width: Math.sumPrecise(t[$].columnWidths.slice(t[$].currentColumn)),
        height: e.height - a
      };
    case "table":
    case "tb":
      return {
        width: e.width - a,
        height: e.height - n - t[$].height
      };
    case "position":
    default:
      return e;
  }
}
function Ux(t) {
  let e = t.w === "" ? NaN : t.w, n = t.h === "" ? NaN : t.h, [a, i] = [0, 0];
  switch (t.anchorType || "") {
    case "bottomCenter":
      [a, i] = [e / 2, n];
      break;
    case "bottomLeft":
      [a, i] = [0, n];
      break;
    case "bottomRight":
      [a, i] = [e, n];
      break;
    case "middleCenter":
      [a, i] = [e / 2, n / 2];
      break;
    case "middleLeft":
      [a, i] = [0, n / 2];
      break;
    case "middleRight":
      [a, i] = [e, n / 2];
      break;
    case "topCenter":
      [a, i] = [e / 2, 0];
      break;
    case "topRight":
      [a, i] = [e, 0];
      break;
  }
  let s, r;
  switch (t.rotate || 0) {
    case 0:
      [s, r] = [-a, -i];
      break;
    case 90:
      [s, r] = [-i, a], [e, n] = [n, -e];
      break;
    case 180:
      [s, r] = [a, i], [e, n] = [-e, -n];
      break;
    case 270:
      [s, r] = [i, -a], [e, n] = [-n, e];
      break;
  }
  return [t.x + s + Math.min(0, e), t.y + r + Math.min(0, n), Math.abs(e), Math.abs(n)];
}
function d0(t, e) {
  if (t[wt]()[$].firstUnsplittable === null || t.w === 0 || t.h === 0)
    return !0;
  const n = 2, a = t[kt](), i = a[$]?.attempt || 0, [, s, r, o] = Ux(t);
  switch (a.layout) {
    case "lr-tb":
    case "rl-tb":
      return i === 0 ? t[wt]()[$].noLayoutFailure ? t.w !== "" ? Math.round(r - e.width) <= n : e.width > n : t.h !== "" && Math.round(o - e.height) > n ? !1 : t.w !== "" ? Math.round(r - e.width) <= n ? !0 : a[$].numberInLine === 0 ? e.height > n : !1 : e.width > n : t[wt]()[$].noLayoutFailure ? !0 : t.h !== "" && Math.round(o - e.height) > n ? !1 : t.w === "" || Math.round(r - e.width) <= n ? e.height > n : a[ba]() ? !1 : e.height > n;
    case "table":
    case "tb":
      return t[wt]()[$].noLayoutFailure ? !0 : t.h !== "" && !t[ga]() ? Math.round(o - e.height) <= n : t.w === "" || Math.round(r - e.width) <= n ? e.height > n : a[ba]() ? !1 : e.height > n;
    case "position":
      if (t[wt]()[$].noLayoutFailure || t.h === "" || Math.round(o + s - e.height) <= n)
        return !0;
      const c = t[wt]()[$].currentContentArea;
      return o + s > c.h;
    case "rl-row":
    case "row":
      return t[wt]()[$].noLayoutFailure ? !0 : t.h !== "" ? Math.round(o - e.height) <= n : !0;
    default:
      return !0;
  }
}
const se = At.template.id, ri = "http://www.w3.org/2000/svg", Vr = 2, jx = 3, Hx = 5e3, $x = /^H(\d+)$/, Gx = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), zx = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function Ul(t) {
  if (!t || !t.border)
    return {
      w: 0,
      h: 0
    };
  const e = t.border[Xt]();
  return e ? {
    w: e.widths[0] + e.widths[2] + e.insets[0] + e.insets[2],
    h: e.widths[1] + e.widths[3] + e.insets[1] + e.insets[3]
  } : {
    w: 0,
    h: 0
  };
}
function ic(t) {
  return t.margin && (t.margin.topInset || t.margin.rightInset || t.margin.bottomInset || t.margin.leftInset);
}
function sc(t, e) {
  if (!t.value) {
    const n = new uc({});
    t[gt](n), t.value = n;
  }
  t.value[pn](e);
}
function* rc(t) {
  for (const e of t[Ut]()) {
    if (e instanceof lc) {
      yield* e[Gi]();
      continue;
    }
    yield e;
  }
}
function Ks(t) {
  return t.validate?.nullTest === "error";
}
function x0(t) {
  for (; t; ) {
    if (!t.traversal) {
      t[Ln] = t[Me]()[Ln];
      return;
    }
    if (t[Ln])
      return;
    let e = null;
    for (const i of t.traversal[Ut]())
      if (i.operation === "next") {
        e = i;
        break;
      }
    if (!e || !e.ref) {
      t[Ln] = t[Me]()[Ln];
      return;
    }
    const n = t[wt]();
    t[Ln] = ++n[Ln];
    const a = n[fa](e.ref, t);
    if (!a)
      return;
    t = a[0];
  }
}
function g0(t, e) {
  const n = t.assist;
  if (n) {
    const a = n[Ie]();
    a && (e.title = a);
    const s = n.role.match($x);
    if (s) {
      const r = "heading", o = s[1];
      e.role = r, e["aria-level"] = o;
    }
  }
  if (t.layout === "table")
    e.role = "table";
  else if (t.layout === "row")
    e.role = "row";
  else {
    const a = t[Me]();
    a.layout === "row" && (e.role = a.assist?.role === "TH" ? "columnheader" : "cell");
  }
}
function fi(t) {
  if (!t.assist)
    return null;
  const e = t.assist;
  return e.speak && e.speak[q] !== "" ? e.speak[q] : e.toolTip ? e.toolTip[q] : null;
}
function ja(t) {
  return Se.success({
    name: "div",
    attributes: {
      class: ["xfaRich"],
      style: /* @__PURE__ */ Object.create(null)
    },
    children: [{
      name: "span",
      attributes: {
        style: /* @__PURE__ */ Object.create(null)
      },
      value: t
    }]
  });
}
function p0(t) {
  const e = t[wt]();
  e[$].firstUnsplittable === null && (e[$].firstUnsplittable = t, e[$].noLayoutFailure = !0);
}
function m0(t) {
  const e = t[wt]();
  e[$].firstUnsplittable === t && (e[$].noLayoutFailure = !1);
}
function jl(t) {
  if (t[$] || (t[$] = /* @__PURE__ */ Object.create(null), t.targetType === "auto"))
    return !1;
  const e = t[wt]();
  let n = null;
  if (t.target) {
    if (n = e[fa](t.target, t[Me]()), !n)
      return !1;
    n = n[0];
  }
  const {
    currentPageArea: a,
    currentContentArea: i
  } = e[$];
  if (t.targetType === "pageArea")
    return n instanceof zi || (n = null), t.startNew ? (t[$].target = n || a, !0) : n && n !== a ? (t[$].target = n, !0) : !1;
  n instanceof oc || (n = null);
  const s = n && n[Me]();
  let r, o = s;
  if (t.startNew)
    if (n) {
      const c = s.contentArea.children, l = c.indexOf(i), h = c.indexOf(n);
      l !== -1 && l < h && (o = null), r = h - 1;
    } else
      r = a.contentArea.children.indexOf(i);
  else if (n && n !== i)
    r = s.contentArea.children.indexOf(n) - 1, o = s === a ? null : s;
  else
    return !1;
  return t[$].target = o, t[$].index = r, !0;
}
function Hl(t, e, n) {
  const a = t[wt](), i = a[$].noLayoutFailure, s = e[kt];
  e[kt] = () => t, a[$].noLayoutFailure = !0;
  const r = e[Ie](n);
  t[ai](r.html, r.bbox), a[$].noLayoutFailure = i, e[kt] = s;
}
class _x extends $e {
  constructor(e) {
    super(se, "appearanceFilter"), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class gh extends z {
  constructor(e) {
    super(se, "arc", !0), this.circular = Be({
      data: e.circular,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.hand = Y(e.hand, ["even", "left", "right"]), this.id = e.id || "", this.startAngle = Wr({
      data: e.startAngle,
      defaultValue: 0,
      validate: (n) => !0
    }), this.sweepAngle = Wr({
      data: e.sweepAngle,
      defaultValue: 360,
      validate: (n) => !0
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.edge = null, this.fill = null;
  }
  [Ie]() {
    const e = this.edge || new Ys({}), n = e[Xe](), a = /* @__PURE__ */ Object.create(null);
    this.fill?.presence === "visible" ? Object.assign(a, this.fill[Xe]()) : a.fill = "transparent", a.strokeWidth = Oe(e.presence === "visible" ? e.thickness : 0), a.stroke = n.color;
    let i;
    const s = {
      xmlns: ri,
      style: {
        width: "100%",
        height: "100%",
        overflow: "visible"
      }
    };
    if (this.sweepAngle === 360)
      i = {
        name: "ellipse",
        attributes: {
          xmlns: ri,
          cx: "50%",
          cy: "50%",
          rx: "50%",
          ry: "50%",
          style: a
        }
      };
    else {
      const c = this.startAngle * Math.PI / 180, l = this.sweepAngle * Math.PI / 180, h = this.sweepAngle > 180 ? 1 : 0, [f, d, u, x] = [50 * (1 + Math.cos(c)), 50 * (1 - Math.sin(c)), 50 * (1 + Math.cos(c + l)), 50 * (1 - Math.sin(c + l))];
      i = {
        name: "path",
        attributes: {
          xmlns: ri,
          d: `M ${f} ${d} A 50 50 0 ${h} 0 ${u} ${x}`,
          vectorEffect: "non-scaling-stroke",
          style: a
        }
      }, Object.assign(s, {
        viewBox: "0 0 100 100",
        preserveAspectRatio: "none"
      });
    }
    const r = {
      name: "svg",
      children: [i],
      attributes: s
    }, o = this[Me]()[Me]();
    return ic(o) ? Se.success({
      name: "div",
      attributes: {
        style: {
          display: "inline",
          width: "100%",
          height: "100%"
        }
      },
      children: [r]
    }) : (r.attributes.style.position = "absolute", Se.success(r));
  }
}
class Wx extends z {
  constructor(e) {
    super(se, "area", !0), this.colSpan = Be({
      data: e.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    }), this.id = e.id || "", this.name = e.name || "", this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.x = pe(e.x, "0pt"), this.y = pe(e.y, "0pt"), this.desc = null, this.extras = null, this.area = new E(), this.draw = new E(), this.exObject = new E(), this.exclGroup = new E(), this.field = new E(), this.subform = new E(), this.subformSet = new E();
  }
  *[Gi]() {
    yield* rc(this);
  }
  [Gs]() {
    return !0;
  }
  [di]() {
    return !0;
  }
  [ai](e, n) {
    const [a, i, s, r] = n;
    this[$].width = Math.max(this[$].width, a + s), this[$].height = Math.max(this[$].height, i + r), this[$].children.push(e);
  }
  [ii]() {
    return this[$].availableSpace;
  }
  [Ie](e) {
    const n = ln(this, "position"), a = {
      style: n,
      id: this[et],
      class: ["xfaArea"]
    };
    qi(this) && a.class.push("xfaPrintOnly"), this.name && (a.xfaName = this.name);
    const i = [];
    this[$] = {
      children: i,
      width: 0,
      height: 0,
      availableSpace: e
    };
    const s = this[Ua]({
      filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
      include: !0
    });
    if (!s.success)
      return s.isBreak() ? s : (delete this[$], Se.FAILURE);
    n.width = Oe(this[$].width), n.height = Oe(this[$].height);
    const r = {
      name: "div",
      attributes: a,
      children: i
    }, o = [this.x, this.y, this[$].width, this[$].height];
    return delete this[$], Se.success(r, o);
  }
}
class Vx extends z {
  constructor(e) {
    super(se, "assist", !0), this.id = e.id || "", this.role = e.role || "", this.use = e.use || "", this.usehref = e.usehref || "", this.speak = null, this.toolTip = null;
  }
  [Ie]() {
    return this.toolTip?.[q] || null;
  }
}
class Xx extends z {
  constructor(e) {
    super(se, "barcode", !0), this.charEncoding = f0({
      data: e.charEncoding ? e.charEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: (n) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(n) || n.match(/iso-8859-\d{2}/)
    }), this.checksum = Y(e.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = Be({
      data: e.dataColumnCount,
      defaultValue: -1,
      validate: (n) => n >= 0
    }), this.dataLength = Be({
      data: e.dataLength,
      defaultValue: -1,
      validate: (n) => n >= 0
    }), this.dataPrep = Y(e.dataPrep, ["none", "flateCompress"]), this.dataRowCount = Be({
      data: e.dataRowCount,
      defaultValue: -1,
      validate: (n) => n >= 0
    }), this.endChar = e.endChar || "", this.errorCorrectionLevel = Be({
      data: e.errorCorrectionLevel,
      defaultValue: -1,
      validate: (n) => n >= 0 && n <= 8
    }), this.id = e.id || "", this.moduleHeight = pe(e.moduleHeight, "5mm"), this.moduleWidth = pe(e.moduleWidth, "0.25mm"), this.printCheckDigit = Be({
      data: e.printCheckDigit,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.rowColumnRatio = Rl(e.rowColumnRatio), this.startChar = e.startChar || "", this.textLocation = Y(e.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = Be({
      data: e.truncate,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.type = Y(e.type ? e.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = Y(e.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = e.use || "", this.usehref = e.usehref || "", this.wideNarrowRatio = Rl(e.wideNarrowRatio), this.encrypt = null, this.extras = null;
  }
}
class qx extends z {
  constructor(e) {
    super(se, "bind", !0), this.match = Y(e.match, ["once", "dataRef", "global", "none"]), this.ref = e.ref || "", this.picture = null;
  }
}
class Co extends z {
  constructor(e) {
    super(se, "bindItems"), this.connection = e.connection || "", this.labelRef = e.labelRef || "", this.ref = e.ref || "", this.valueRef = e.valueRef || "";
  }
}
class Kx extends z {
  constructor(e) {
    super(se, "bookend"), this.id = e.id || "", this.leader = e.leader || "", this.trailer = e.trailer || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class Yx extends Rt {
  constructor(e) {
    super(se, "boolean"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [Ie](e) {
    return ja(this[q] === 1 ? "1" : "0");
  }
}
class ph extends z {
  constructor(e) {
    super(se, "border", !0), this.break = Y(e.break, ["close", "open"]), this.hand = Y(e.hand, ["even", "left", "right"]), this.id = e.id || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.corner = new E(4), this.edge = new E(4), this.extras = null, this.fill = null, this.margin = null;
  }
  [Xt]() {
    if (!this[$]) {
      const e = this.edge.children.slice();
      if (e.length < 4) {
        const i = e.at(-1) || new Ys({});
        for (let s = e.length; s < 4; s++)
          e.push(i);
      }
      const n = e.map((i) => i.thickness), a = [0, 0, 0, 0];
      this.margin && (a[0] = this.margin.topInset, a[1] = this.margin.rightInset, a[2] = this.margin.bottomInset, a[3] = this.margin.leftInset), this[$] = {
        widths: n,
        insets: a,
        edges: e
      };
    }
    return this[$];
  }
  [Xe]() {
    const {
      edges: e
    } = this[Xt](), n = e.map((i) => {
      const s = i[Xe]();
      return s.color ||= "#000000", s;
    }), a = /* @__PURE__ */ Object.create(null);
    if (this.margin && Object.assign(a, this.margin[Xe]()), this.fill?.presence === "visible" && Object.assign(a, this.fill[Xe]()), this.corner.children.some((i) => i.radius !== 0)) {
      const i = this.corner.children.map((s) => s[Xe]());
      if (i.length === 2 || i.length === 3) {
        const s = i.at(-1);
        for (let r = i.length; r < 4; r++)
          i.push(s);
      }
      a.borderRadius = i.map((s) => s.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        a.borderStyle = "";
        break;
      case "inactive":
        a.borderStyle = "none";
        break;
      default:
        a.borderStyle = n.map((i) => i.style).join(" ");
        break;
    }
    return a.borderWidth = n.map((i) => i.width).join(" "), a.borderColor = n.map((i) => i.color).join(" "), a;
  }
}
class Jx extends z {
  constructor(e) {
    super(se, "break", !0), this.after = Y(e.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = e.afterTarget || "", this.before = Y(e.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = e.beforeTarget || "", this.bookendLeader = e.bookendLeader || "", this.bookendTrailer = e.bookendTrailer || "", this.id = e.id || "", this.overflowLeader = e.overflowLeader || "", this.overflowTarget = e.overflowTarget || "", this.overflowTrailer = e.overflowTrailer || "", this.startNew = Be({
      data: e.startNew,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
}
class mh extends z {
  constructor(e) {
    super(se, "breakAfter", !0), this.id = e.id || "", this.leader = e.leader || "", this.startNew = Be({
      data: e.startNew,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.target = e.target || "", this.targetType = Y(e.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e.trailer || "", this.use = e.use || "", this.usehref = e.usehref || "", this.script = null;
  }
}
class bh extends z {
  constructor(e) {
    super(se, "breakBefore", !0), this.id = e.id || "", this.leader = e.leader || "", this.startNew = Be({
      data: e.startNew,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.target = e.target || "", this.targetType = Y(e.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = e.trailer || "", this.use = e.use || "", this.usehref = e.usehref || "", this.script = null;
  }
  [Ie](e) {
    return this[$] = {}, Se.FAILURE;
  }
}
class Zx extends z {
  constructor(e) {
    super(se, "button", !0), this.highlight = Y(e.highlight, ["inverted", "none", "outline", "push"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
  [Ie](e) {
    const a = this[Me]()[Me](), i = {
      name: "button",
      attributes: {
        id: this[et],
        class: ["xfaButton"],
        style: {}
      },
      children: []
    };
    for (const s of a.event.children) {
      if (s.activity !== "click" || !s.script)
        continue;
      const r = l1(s.script[q]);
      if (!r)
        continue;
      const o = hh(r.url);
      o && i.children.push({
        name: "a",
        attributes: {
          id: "link" + this[et],
          href: o,
          newWindow: r.newWindow,
          class: ["xfaLink"],
          style: {}
        },
        children: []
      });
    }
    return Se.success(i);
  }
}
class Qx extends z {
  constructor(e) {
    super(se, "calculate", !0), this.id = e.id || "", this.override = Y(e.override, ["disabled", "error", "ignore", "warning"]), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.message = null, this.script = null;
  }
}
class e9 extends z {
  constructor(e) {
    super(se, "caption", !0), this.id = e.id || "", this.placement = Y(e.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(pe(e.reserve)), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
  }
  [pn](e) {
    sc(this, e);
  }
  [Xt](e) {
    if (!this[$]) {
      let {
        width: n,
        height: a
      } = e;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          n = this.reserve <= 0 ? n : this.reserve;
          break;
        case "top":
        case "bottom":
          a = this.reserve <= 0 ? a : this.reserve;
          break;
      }
      this[$] = nc(this, {
        width: n
      });
    }
    return this[$];
  }
  [Ie](e) {
    if (!this.value)
      return Se.EMPTY;
    this[Xi]();
    const n = this.value[Ie](e).html;
    if (!n)
      return this[dn](), Se.EMPTY;
    const a = this.reserve;
    if (this.reserve <= 0) {
      const {
        w: r,
        h: o
      } = this[Xt](e);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = r;
          break;
        case "top":
        case "bottom":
          this.reserve = o;
          break;
      }
    }
    const i = [];
    typeof n == "string" ? i.push({
      name: "#text",
      value: n
    }) : i.push(n);
    const s = ln(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (s.width = Oe(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (s.height = Oe(this.reserve));
        break;
    }
    return ch(this, null, n), this[dn](), this.reserve = a, Se.success({
      name: "div",
      attributes: {
        style: s,
        class: ["xfaCaption"]
      },
      children: i
    });
  }
}
class t9 extends $e {
  constructor(e) {
    super(se, "certificate"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class n9 extends z {
  constructor(e) {
    super(se, "certificates", !0), this.credentialServerPolicy = Y(e.credentialServerPolicy, ["optional", "required"]), this.id = e.id || "", this.url = e.url || "", this.urlPolicy = e.urlPolicy || "", this.use = e.use || "", this.usehref = e.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
  }
}
class yh extends z {
  constructor(e) {
    super(se, "checkButton", !0), this.id = e.id || "", this.mark = Y(e.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = Y(e.shape, ["square", "round"]), this.size = pe(e.size, "10pt"), this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Ie](e) {
    const n = ln(this, "margin"), a = Oe(this.size);
    n.width = n.height = a;
    let i, s, r;
    const o = this[Me]()[Me](), c = o.items.children.length && o.items.children[0][Ie]().html || [], l = {
      on: (c[0] !== void 0 ? c[0] : "on").toString(),
      off: (c[1] !== void 0 ? c[1] : "off").toString()
    }, f = (o.value?.[Ft]() || "off") === l.on || void 0, d = o[kt](), u = o[et];
    let x;
    d instanceof kh ? (r = d[et], i = "radio", s = "xfaRadio", x = d[Mn]?.[et] || d[et]) : (i = "checkbox", s = "xfaCheckbox", x = o[Mn]?.[et] || o[et]);
    const g = {
      name: "input",
      attributes: {
        class: [s],
        style: n,
        fieldId: u,
        dataId: x,
        type: i,
        checked: f,
        xfaOn: l.on,
        xfaOff: l.off,
        "aria-label": fi(o),
        "aria-required": !1
      }
    };
    return r && (g.attributes.name = r), Ks(o) && (g.attributes["aria-required"] = !0, g.attributes.required = !0), Se.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [g]
    });
  }
}
class wh extends z {
  constructor(e) {
    super(se, "choiceList", !0), this.commitOn = Y(e.commitOn, ["select", "exit"]), this.id = e.id || "", this.open = Y(e.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = Be({
      data: e.textEntry,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Ie](e) {
    const n = ln(this, "border", "margin"), i = this[Me]()[Me](), r = {
      fontSize: `calc(${i.font?.size || 10}px * var(--total-scale-factor))`
    }, o = [];
    if (i.items.children.length > 0) {
      const l = i.items;
      let h = 0, f = 0;
      l.children.length === 2 && (h = l.children[0].save, f = 1 - h);
      const d = l.children[h][Ie]().html, u = l.children[f][Ie]().html;
      let x = !1;
      const g = i.value?.[Ft]() || "";
      for (let p = 0, m = d.length; p < m; p++) {
        const b = {
          name: "option",
          attributes: {
            value: u[p] || d[p],
            style: r
          },
          value: d[p]
        };
        u[p] === g && (b.attributes.selected = x = !0), o.push(b);
      }
      x || o.splice(0, 0, {
        name: "option",
        attributes: {
          hidden: !0,
          selected: !0
        },
        value: " "
      });
    }
    const c = {
      class: ["xfaSelect"],
      fieldId: i[et],
      dataId: i[Mn]?.[et] || i[et],
      style: n,
      "aria-label": fi(i),
      "aria-required": !1
    };
    return Ks(i) && (c["aria-required"] = !0, c.required = !0), this.open === "multiSelect" && (c.multiple = !0), Se.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [{
        name: "select",
        children: o,
        attributes: c
      }]
    });
  }
}
class a9 extends z {
  constructor(e) {
    super(se, "color", !0), this.cSpace = Y(e.cSpace, ["SRGB"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.value = e.value ? Ex(e.value) : "", this.extras = null;
  }
  [$s]() {
    return !1;
  }
  [Xe]() {
    return this.value ? Je.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class i9 extends z {
  constructor(e) {
    super(se, "comb"), this.id = e.id || "", this.numberOfCells = Be({
      data: e.numberOfCells,
      defaultValue: 0,
      validate: (n) => n >= 0
    }), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class s9 extends z {
  constructor(e) {
    super(se, "connect", !0), this.connection = e.connection || "", this.id = e.id || "", this.ref = e.ref || "", this.usage = Y(e.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = e.use || "", this.usehref = e.usehref || "", this.picture = null;
  }
}
class oc extends z {
  constructor(e) {
    super(se, "contentArea", !0), this.h = pe(e.h), this.id = e.id || "", this.name = e.name || "", this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.w = pe(e.w), this.x = pe(e.x, "0pt"), this.y = pe(e.y, "0pt"), this.desc = null, this.extras = null;
  }
  [Ie](e) {
    const n = Oe(this.x), a = Oe(this.y), i = {
      left: n,
      top: a,
      width: Oe(this.w),
      height: Oe(this.h)
    }, s = ["xfaContentarea"];
    return qi(this) && s.push("xfaPrintOnly"), Se.success({
      name: "div",
      children: [],
      attributes: {
        style: i,
        class: s,
        id: this[et]
      }
    });
  }
}
class vh extends z {
  constructor(e) {
    super(se, "corner", !0), this.id = e.id || "", this.inverted = Be({
      data: e.inverted,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.join = Y(e.join, ["square", "round"]), this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = pe(e.radius), this.stroke = Y(e.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = pe(e.thickness, "0.5pt"), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null;
  }
  [Xe]() {
    const e = ln(this, "visibility");
    return e.radius = Oe(this.join === "square" ? 0 : this.radius), e;
  }
}
class r9 extends mt {
  constructor(e) {
    super(se, "date"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    const e = this[q].trim();
    this[q] = e ? new Date(e) : null;
  }
  [Ie](e) {
    return ja(this[q] ? this[q].toString() : "");
  }
}
class o9 extends mt {
  constructor(e) {
    super(se, "dateTime"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    const e = this[q].trim();
    this[q] = e ? new Date(e) : null;
  }
  [Ie](e) {
    return ja(this[q] ? this[q].toString() : "");
  }
}
class c9 extends z {
  constructor(e) {
    super(se, "dateTimeEdit", !0), this.hScrollPolicy = Y(e.hScrollPolicy, ["auto", "off", "on"]), this.id = e.id || "", this.picker = Y(e.picker, ["host", "none"]), this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Ie](e) {
    const n = ln(this, "border", "font", "margin"), a = this[Me]()[Me](), i = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: a[et],
        dataId: a[Mn]?.[et] || a[et],
        class: ["xfaTextfield"],
        style: n,
        "aria-label": fi(a),
        "aria-required": !1
      }
    };
    return Ks(a) && (i.attributes["aria-required"] = !0, i.attributes.required = !0), Se.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [i]
    });
  }
}
class l9 extends mt {
  constructor(e) {
    super(se, "decimal"), this.fracDigits = Be({
      data: e.fracDigits,
      defaultValue: 2,
      validate: (n) => !0
    }), this.id = e.id || "", this.leadDigits = Be({
      data: e.leadDigits,
      defaultValue: -1,
      validate: (n) => !0
    }), this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    const e = parseFloat(this[q].trim());
    this[q] = isNaN(e) ? null : e;
  }
  [Ie](e) {
    return ja(this[q] !== null ? this[q].toString() : "");
  }
}
class h9 extends z {
  constructor(e) {
    super(se, "defaultUi", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
}
class f9 extends z {
  constructor(e) {
    super(se, "desc", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.boolean = new E(), this.date = new E(), this.dateTime = new E(), this.decimal = new E(), this.exData = new E(), this.float = new E(), this.image = new E(), this.integer = new E(), this.text = new E(), this.time = new E();
  }
}
class u9 extends tt {
  constructor(e) {
    super(se, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class d9 extends z {
  constructor(e) {
    super(se, "digestMethods", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.digestMethod = new E();
  }
}
class Sh extends z {
  constructor(e) {
    super(se, "draw", !0), this.anchorType = Y(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Be({
      data: e.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    }), this.h = e.h ? pe(e.h) : "", this.hAlign = Y(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e.id || "", this.locale = e.locale || "", this.maxH = pe(e.maxH, "0pt"), this.maxW = pe(e.maxW, "0pt"), this.minH = pe(e.minH, "0pt"), this.minW = pe(e.minW, "0pt"), this.name = e.name || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = _n(e.relevant), this.rotate = Be({
      data: e.rotate,
      defaultValue: 0,
      validate: (n) => n % 90 === 0
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.w = e.w ? pe(e.w) : "", this.x = pe(e.x, "0pt"), this.y = pe(e.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new E();
  }
  [pn](e) {
    sc(this, e);
  }
  [Ie](e) {
    if (x0(this), this.presence === "hidden" || this.presence === "inactive")
      return Se.EMPTY;
    u0(this), this[Xi]();
    const n = this.w, a = this.h, {
      w: i,
      h: s,
      isBroken: r
    } = nc(this, e);
    if (i && this.w === "") {
      if (r && this[kt]()[ba]())
        return this[dn](), Se.FAILURE;
      this.w = i;
    }
    if (s && this.h === "" && (this.h = s), p0(this), !d0(this, e))
      return this.w = n, this.h = a, this[dn](), Se.FAILURE;
    m0(this);
    const o = ln(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    ah(this, o), o.margin && (o.padding = o.margin, delete o.margin);
    const c = ["xfaDraw"];
    this.font && c.push("xfaFont"), qi(this) && c.push("xfaPrintOnly");
    const l = {
      style: o,
      id: this[et],
      class: c
    };
    this.name && (l.xfaName = this.name);
    const h = {
      name: "div",
      attributes: l,
      children: []
    };
    g0(this, l);
    const f = ih(this, h, e), d = this.value ? this.value[Ie](e).html : null;
    return d === null ? (this.w = n, this.h = a, this[dn](), Se.success(si(this, h), f)) : (h.children.push(d), ch(this, o, d), this.w = n, this.h = a, this[dn](), Se.success(si(this, h), f));
  }
}
class Ys extends z {
  constructor(e) {
    super(se, "edge", !0), this.cap = Y(e.cap, ["square", "butt", "round"]), this.id = e.id || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = Y(e.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = pe(e.thickness, "0.5pt"), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null;
  }
  [Xe]() {
    const e = ln(this, "visibility");
    if (Object.assign(e, {
      linecap: this.cap,
      width: Oe(this.thickness),
      color: this.color ? this.color[Xe]() : "#000000",
      style: ""
    }), this.presence !== "visible")
      e.style = "none";
    else
      switch (this.stroke) {
        case "solid":
          e.style = "solid";
          break;
        case "dashDot":
          e.style = "dashed";
          break;
        case "dashDotDot":
          e.style = "dashed";
          break;
        case "dashed":
          e.style = "dashed";
          break;
        case "dotted":
          e.style = "dotted";
          break;
        case "embossed":
          e.style = "ridge";
          break;
        case "etched":
          e.style = "groove";
          break;
        case "lowered":
          e.style = "inset";
          break;
        case "raised":
          e.style = "outset";
          break;
      }
    return e;
  }
}
class x9 extends tt {
  constructor(e) {
    super(se, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class g9 extends z {
  constructor(e) {
    super(se, "encodings", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.encoding = new E();
  }
}
class p9 extends z {
  constructor(e) {
    super(se, "encrypt", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.certificate = null;
  }
}
class m9 extends z {
  constructor(e) {
    super(se, "encryptData", !0), this.id = e.id || "", this.operation = Y(e.operation, ["encrypt", "decrypt"]), this.target = e.target || "", this.use = e.use || "", this.usehref = e.usehref || "", this.filter = null, this.manifest = null;
  }
}
class b9 extends z {
  constructor(e) {
    super(se, "encryption", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.certificate = new E();
  }
}
class y9 extends tt {
  constructor(e) {
    super(se, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class w9 extends z {
  constructor(e) {
    super(se, "encryptionMethods", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.encryptionMethod = new E();
  }
}
class v9 extends z {
  constructor(e) {
    super(se, "event", !0), this.activity = Y(e.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = e.id || "", this.listen = Y(e.listen, ["refOnly", "refAndDescendents"]), this.name = e.name || "", this.ref = e.ref || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
  }
}
class S9 extends mt {
  constructor(e) {
    super(se, "exData"), this.contentType = e.contentType || "", this.href = e.href || "", this.id = e.id || "", this.maxLength = Be({
      data: e.maxLength,
      defaultValue: -1,
      validate: (n) => n >= -1
    }), this.name = e.name || "", this.rid = e.rid || "", this.transferEncoding = Y(e.transferEncoding, ["none", "base64", "package"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [Qo]() {
    return this.contentType === "text/html";
  }
  [ea](e) {
    return this.contentType === "text/html" && e[vt] === At.xhtml.id ? (this[q] = e, !0) : this.contentType === "text/xml" ? (this[q] = e, !0) : !1;
  }
  [Ie](e) {
    return this.contentType !== "text/html" || !this[q] ? Se.EMPTY : this[q][Ie](e);
  }
}
class k9 extends z {
  constructor(e) {
    super(se, "exObject", !0), this.archive = e.archive || "", this.classId = e.classId || "", this.codeBase = e.codeBase || "", this.codeType = e.codeType || "", this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.boolean = new E(), this.date = new E(), this.dateTime = new E(), this.decimal = new E(), this.exData = new E(), this.exObject = new E(), this.float = new E(), this.image = new E(), this.integer = new E(), this.text = new E(), this.time = new E();
  }
}
class kh extends z {
  constructor(e) {
    super(se, "exclGroup", !0), this.access = Y(e.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e.accessKey || "", this.anchorType = Y(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Be({
      data: e.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    }), this.h = e.h ? pe(e.h) : "", this.hAlign = Y(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e.id || "", this.layout = Y(e.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = pe(e.maxH, "0pt"), this.maxW = pe(e.maxW, "0pt"), this.minH = pe(e.minH, "0pt"), this.minW = pe(e.minW, "0pt"), this.name = e.name || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.w = e.w ? pe(e.w) : "", this.x = pe(e.x, "0pt"), this.y = pe(e.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new E(), this.event = new E(), this.field = new E(), this.setProperty = new E();
  }
  [di]() {
    return !0;
  }
  [$s]() {
    return !0;
  }
  [pn](e) {
    for (const n of this.field.children) {
      if (!n.value) {
        const a = new uc({});
        n[gt](a), n.value = a;
      }
      n.value[pn](e);
    }
  }
  [ba]() {
    return this.layout.endsWith("-tb") && this[$].attempt === 0 && this[$].numberInLine > 0 || this[Me]()[ba]();
  }
  [ga]() {
    const e = this[kt]();
    return e[ga]() ? this[$]._isSplittable !== void 0 ? this[$]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[$]._isSplittable = !1, !1) : e.layout?.endsWith("-tb") && e[$].numberInLine !== 0 ? !1 : (this[$]._isSplittable = !0, !0) : !1;
  }
  [qs]() {
    return uh(this);
  }
  [ai](e, n) {
    dh(this, e, n);
  }
  [ii]() {
    return xh(this);
  }
  [Ie](e) {
    if (x0(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
      return Se.EMPTY;
    u0(this);
    const n = [], a = {
      id: this[et],
      class: []
    };
    ac(this, a.class), this[$] ||= /* @__PURE__ */ Object.create(null), Object.assign(this[$], {
      children: n,
      attributes: a,
      attempt: 0,
      line: null,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || 1 / 0, e.width),
        height: Math.min(this.h || 1 / 0, e.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const i = this[ga]();
    if (i || p0(this), !d0(this, e))
      return Se.FAILURE;
    const s = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const m = this[kt]().columnWidths;
      Array.isArray(m) && m.length > 0 && (this[$].columnWidths = m, this[$].currentColumn = 0);
    }
    const r = ln(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), o = ["xfaExclgroup"], c = sh(this);
    c && o.push(c), qi(this) && o.push("xfaPrintOnly"), a.style = r, a.class = o, this.name && (a.xfaName = this.name), this[Xi]();
    const l = this.layout === "lr-tb" || this.layout === "rl-tb", h = l ? Vr : 1;
    for (; this[$].attempt < h; this[$].attempt++) {
      l && this[$].attempt === Vr - 1 && (this[$].numberInLine = 0);
      const m = this[Ua]({
        filter: s,
        include: !0
      });
      if (m.success)
        break;
      if (m.isBreak())
        return this[dn](), m;
      if (l && this[$].attempt === 0 && this[$].numberInLine === 0 && !this[wt]()[$].noLayoutFailure) {
        this[$].attempt = h;
        break;
      }
    }
    if (this[dn](), i || m0(this), this[$].attempt === h)
      return i || delete this[$], Se.FAILURE;
    let f = 0, d = 0;
    this.margin && (f = this.margin.leftInset + this.margin.rightInset, d = this.margin.topInset + this.margin.bottomInset);
    const u = Math.max(this[$].width + f, this.w || 0), x = Math.max(this[$].height + d, this.h || 0), g = [this.x, this.y, u, x];
    this.w === "" && (r.width = Oe(u)), this.h === "" && (r.height = Oe(x));
    const p = {
      name: "div",
      attributes: a,
      children: n
    };
    return g0(this, a), delete this[$], Se.success(si(this, p), g);
  }
}
class A9 extends z {
  constructor(e) {
    super(se, "execute"), this.connection = e.connection || "", this.executeType = Y(e.executeType, ["import", "remerge"]), this.id = e.id || "", this.runAt = Y(e.runAt, ["client", "both", "server"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class C9 extends z {
  constructor(e) {
    super(se, "extras", !0), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "", this.boolean = new E(), this.date = new E(), this.dateTime = new E(), this.decimal = new E(), this.exData = new E(), this.extras = new E(), this.float = new E(), this.image = new E(), this.integer = new E(), this.text = new E(), this.time = new E();
  }
}
class cc extends z {
  constructor(e) {
    super(se, "field", !0), this.access = Y(e.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = e.accessKey || "", this.anchorType = Y(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Be({
      data: e.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    }), this.h = e.h ? pe(e.h) : "", this.hAlign = Y(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e.id || "", this.locale = e.locale || "", this.maxH = pe(e.maxH, "0pt"), this.maxW = pe(e.maxW, "0pt"), this.minH = pe(e.minH, "0pt"), this.minW = pe(e.minW, "0pt"), this.name = e.name || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = _n(e.relevant), this.rotate = Be({
      data: e.rotate,
      defaultValue: 0,
      validate: (n) => n % 90 === 0
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.w = e.w ? pe(e.w) : "", this.x = pe(e.x, "0pt"), this.y = pe(e.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new E(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new E(), this.connect = new E(), this.event = new E(), this.setProperty = new E();
  }
  [di]() {
    return !0;
  }
  [pn](e) {
    sc(this, e);
  }
  [Ie](e) {
    if (x0(this), !this.ui) {
      this.ui = new fc({}), this.ui[it] = this[it], this[gt](this.ui);
      let m;
      switch (this.items.children.length) {
        case 0:
          m = new Fh({}), this.ui.textEdit = m;
          break;
        case 1:
          m = new yh({}), this.ui.checkButton = m;
          break;
        case 2:
          m = new wh({}), this.ui.choiceList = m;
          break;
      }
      this.ui[gt](m);
    }
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
      return Se.EMPTY;
    this.caption && delete this.caption[$], this[Xi]();
    const n = this.caption ? this.caption[Ie](e).html : null, a = this.w, i = this.h;
    let s = 0, r = 0;
    this.margin && (s = this.margin.leftInset + this.margin.rightInset, r = this.margin.topInset + this.margin.bottomInset);
    let o = null;
    if (this.w === "" || this.h === "") {
      let m = null, b = null, y = 0, w = 0;
      if (this.ui.checkButton)
        y = w = this.ui.checkButton.size;
      else {
        const {
          w: S,
          h: v
        } = nc(this, e);
        S !== null ? (y = S, w = v) : w = Ox(this.font, !0).lineNoGap;
      }
      if (o = Ul(this.ui[Xt]()), y += o.w, w += o.h, this.caption) {
        const {
          w: S,
          h: v,
          isBroken: k
        } = this.caption[Xt](e);
        if (k && this[kt]()[ba]())
          return this[dn](), Se.FAILURE;
        switch (m = S, b = v, this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            m += y;
            break;
          case "top":
          case "bottom":
            b += w;
            break;
        }
      } else
        m = y, b = w;
      m && this.w === "" && (m += s, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < m ? m : this.minW)), b && this.h === "" && (b += r, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < b ? b : this.minH));
    }
    if (this[dn](), u0(this), p0(this), !d0(this, e))
      return this.w = a, this.h = i, this[dn](), Se.FAILURE;
    m0(this);
    const c = ln(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    ah(this, c);
    const l = ["xfaField"];
    this.font && l.push("xfaFont"), qi(this) && l.push("xfaPrintOnly");
    const h = {
      style: c,
      id: this[et],
      class: l
    };
    c.margin && (c.padding = c.margin, delete c.margin), ac(this, l), this.name && (h.xfaName = this.name);
    const f = [], d = {
      name: "div",
      attributes: h,
      children: f
    };
    g0(this, h);
    const u = this.border ? this.border[Xe]() : null, x = ih(this, d, e), g = this.ui[Ie]().html;
    if (!g)
      return Object.assign(c, u), Se.success(si(this, d), x);
    this[Ln] && (g.children?.[0] ? g.children[0].attributes.tabindex = this[Ln] : g.attributes.tabindex = this[Ln]), g.attributes.style ||= /* @__PURE__ */ Object.create(null);
    let p = null;
    if (this.ui.button ? (g.children.length === 1 && ([p] = g.children.splice(0, 1)), Object.assign(g.attributes.style, u)) : Object.assign(c, u), f.push(g), this.value) {
      if (this.ui.imageEdit)
        g.children.push(this.value[Ie]().html);
      else if (!this.ui.button) {
        let m = "";
        if (this.value.exData)
          m = this.value.exData[Ft]();
        else if (this.value.text)
          m = this.value.text[Xt]();
        else {
          const b = this.value[Ie]().html;
          b !== null && (m = b.children[0].value);
        }
        this.ui.textEdit && this.value.text?.maxChars && (g.children[0].attributes.maxLength = this.value.text.maxChars), m && (this.ui.numericEdit && (m = parseFloat(m), m = isNaN(m) ? "" : m.toString()), g.children[0].name === "textarea" ? g.children[0].attributes.textContent = m : g.children[0].attributes.value = m);
      }
    }
    if (!this.ui.imageEdit && g.children?.[0] && this.h) {
      o = o || Ul(this.ui[Xt]());
      let m = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        m = this.caption.reserve, m <= 0 && (m = this.caption[Xt](e).h);
        const b = this.h - m - r - o.h;
        g.children[0].attributes.style.height = Oe(b);
      } else
        g.children[0].attributes.style.height = "100%";
    }
    if (p && g.children.push(p), !n)
      return g.attributes.class && g.attributes.class.push("xfaLeft"), this.w = a, this.h = i, Se.success(si(this, d), x);
    if (this.ui.button)
      return c.padding && delete c.padding, n.name === "div" && (n.name = "span"), g.children.push(n), Se.success(d, x);
    switch (this.ui.checkButton && (n.attributes.class[0] = "xfaCaptionForCheckButton"), g.attributes.class ||= [], g.children.splice(0, 0, n), this.caption.placement) {
      case "left":
        g.attributes.class.push("xfaLeft");
        break;
      case "right":
        g.attributes.class.push("xfaRight");
        break;
      case "top":
        g.attributes.class.push("xfaTop");
        break;
      case "bottom":
        g.attributes.class.push("xfaBottom");
        break;
      case "inline":
        g.attributes.class.push("xfaLeft");
        break;
    }
    return this.w = a, this.h = i, Se.success(si(this, d), x);
  }
}
class I9 extends z {
  constructor(e) {
    super(se, "fill", !0), this.id = e.id || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
  }
  [Xe]() {
    const e = this[Me](), a = e[Me]()[Me](), i = /* @__PURE__ */ Object.create(null);
    let s = "color", r = s;
    e instanceof ph && (s = "background-color", r = "background", a instanceof fc && (i.backgroundColor = "white")), (e instanceof Ih || e instanceof gh) && (s = r = "fill", i.fill = "white");
    for (const o of Object.getOwnPropertyNames(this)) {
      if (o === "extras" || o === "color")
        continue;
      const c = this[o];
      if (!(c instanceof z))
        continue;
      const l = c[Xe](this.color);
      return l && (i[l.startsWith("#") ? s : r] = l), i;
    }
    if (this.color?.value) {
      const o = this.color[Xe]();
      i[o.startsWith("#") ? s : r] = o;
    }
    return i;
  }
}
class T9 extends z {
  constructor(e) {
    super(se, "filter", !0), this.addRevocationInfo = Y(e.addRevocationInfo, ["", "required", "optional", "none"]), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "", this.version = Be({
      data: this.version,
      defaultValue: 5,
      validate: (n) => n >= 1 && n <= 5
    }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
  }
}
class E9 extends mt {
  constructor(e) {
    super(se, "float"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    const e = parseFloat(this[q].trim());
    this[q] = isNaN(e) ? null : e;
  }
  [Ie](e) {
    return ja(this[q] !== null ? this[q].toString() : "");
  }
}
class F9 extends z {
  constructor(e) {
    super(se, "font", !0), this.baselineShift = pe(e.baselineShift), this.fontHorizontalScale = Wr({
      data: e.fontHorizontalScale,
      defaultValue: 100,
      validate: (n) => n >= 0
    }), this.fontVerticalScale = Wr({
      data: e.fontVerticalScale,
      defaultValue: 100,
      validate: (n) => n >= 0
    }), this.id = e.id || "", this.kerningMode = Y(e.kerningMode, ["none", "pair"]), this.letterSpacing = pe(e.letterSpacing, "0"), this.lineThrough = Be({
      data: e.lineThrough,
      defaultValue: 0,
      validate: (n) => n === 1 || n === 2
    }), this.lineThroughPeriod = Y(e.lineThroughPeriod, ["all", "word"]), this.overline = Be({
      data: e.overline,
      defaultValue: 0,
      validate: (n) => n === 1 || n === 2
    }), this.overlinePeriod = Y(e.overlinePeriod, ["all", "word"]), this.posture = Y(e.posture, ["normal", "italic"]), this.size = pe(e.size, "10pt"), this.typeface = e.typeface || "Courier", this.underline = Be({
      data: e.underline,
      defaultValue: 0,
      validate: (n) => n === 1 || n === 2
    }), this.underlinePeriod = Y(e.underlinePeriod, ["all", "word"]), this.use = e.use || "", this.usehref = e.usehref || "", this.weight = Y(e.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
  }
  [Pn](e) {
    super[Pn](e), this[it].usedTypefaces.add(this.typeface);
  }
  [Xe]() {
    const e = ln(this, "fill"), n = e.color;
    return n && (n === "#000000" ? delete e.color : n.startsWith("#") || (e.background = n, e.backgroundClip = "text", e.color = "transparent")), this.baselineShift && (e.verticalAlign = Oe(this.baselineShift)), e.fontKerning = this.kerningMode === "none" ? "none" : "normal", e.letterSpacing = Oe(this.letterSpacing), this.lineThrough !== 0 && (e.textDecoration = "line-through", this.lineThrough === 2 && (e.textDecorationStyle = "double")), this.overline !== 0 && (e.textDecoration = "overline", this.overline === 2 && (e.textDecorationStyle = "double")), e.fontStyle = this.posture, e.fontSize = Oe(0.99 * this.size), lh(this, this, this[it].fontFinder, e), this.underline !== 0 && (e.textDecoration = "underline", this.underline === 2 && (e.textDecorationStyle = "double")), e.fontWeight = this.weight, e;
  }
}
class R9 extends z {
  constructor(e) {
    super(se, "format", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.picture = null;
  }
}
class O9 extends $e {
  constructor(e) {
    super(se, "handler"), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class B9 extends z {
  constructor(e) {
    super(se, "hyphenation"), this.excludeAllCaps = Be({
      data: e.excludeAllCaps,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.excludeInitialCap = Be({
      data: e.excludeInitialCap,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.hyphenate = Be({
      data: e.hyphenate,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.id = e.id || "", this.pushCharacterCount = Be({
      data: e.pushCharacterCount,
      defaultValue: 3,
      validate: (n) => n >= 0
    }), this.remainCharacterCount = Be({
      data: e.remainCharacterCount,
      defaultValue: 3,
      validate: (n) => n >= 0
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.wordCharacterCount = Be({
      data: e.wordCharacterCount,
      defaultValue: 7,
      validate: (n) => n >= 0
    });
  }
}
class Ah extends $e {
  constructor(e) {
    super(se, "image"), this.aspect = Y(e.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = e.contentType || "", this.href = e.href || "", this.id = e.id || "", this.name = e.name || "", this.transferEncoding = Y(e.transferEncoding, ["base64", "none", "package"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [Ie]() {
    if (this.contentType && !Gx.has(this.contentType.toLowerCase()))
      return Se.EMPTY;
    let e = this[it].images?.get(this.href);
    if (!e && (this.href || !this[q]) || (!e && this.transferEncoding === "base64" && (e = sf(this[q])), !e))
      return Se.EMPTY;
    if (!this.contentType) {
      for (const [s, r] of zx)
        if (e.length > s.length && s.every((o, c) => o === e[c])) {
          this.contentType = r;
          break;
        }
      if (!this.contentType)
        return Se.EMPTY;
    }
    const n = new Blob([e], {
      type: this.contentType
    });
    let a;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        a = {
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "none":
        a = {
          width: "100%",
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "width":
        a = {
          width: "100%",
          objectFit: "fill"
        };
        break;
    }
    const i = this[Me]();
    return Se.success({
      name: "img",
      attributes: {
        class: ["xfaImage"],
        style: a,
        src: URL.createObjectURL(n),
        alt: i ? fi(i[Me]()) : null
      }
    });
  }
}
class M9 extends z {
  constructor(e) {
    super(se, "imageEdit", !0), this.data = Y(e.data, ["link", "embed"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Ie](e) {
    return this.data === "embed" ? Se.success({
      name: "div",
      children: [],
      attributes: {}
    }) : Se.EMPTY;
  }
}
class P9 extends mt {
  constructor(e) {
    super(se, "integer"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    const e = parseInt(this[q].trim(), 10);
    this[q] = isNaN(e) ? null : e;
  }
  [Ie](e) {
    return ja(this[q] !== null ? this[q].toString() : "");
  }
}
class N9 extends z {
  constructor(e) {
    super(se, "issuers", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.certificate = new E();
  }
}
class Io extends z {
  constructor(e) {
    super(se, "items", !0), this.id = e.id || "", this.name = e.name || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = e.ref || "", this.save = Be({
      data: e.save,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.boolean = new E(), this.date = new E(), this.dateTime = new E(), this.decimal = new E(), this.exData = new E(), this.float = new E(), this.image = new E(), this.integer = new E(), this.text = new E(), this.time = new E();
  }
  [Ie]() {
    const e = [];
    for (const n of this[Ut]())
      e.push(n[Ft]());
    return Se.success(e);
  }
}
class D9 extends z {
  constructor(e) {
    super(se, "keep", !0), this.id = e.id || "";
    const n = ["none", "contentArea", "pageArea"];
    this.intact = Y(e.intact, n), this.next = Y(e.next, n), this.previous = Y(e.previous, n), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
}
class L9 extends z {
  constructor(e) {
    super(se, "keyUsage");
    const n = ["", "yes", "no"];
    this.crlSign = Y(e.crlSign, n), this.dataEncipherment = Y(e.dataEncipherment, n), this.decipherOnly = Y(e.decipherOnly, n), this.digitalSignature = Y(e.digitalSignature, n), this.encipherOnly = Y(e.encipherOnly, n), this.id = e.id || "", this.keyAgreement = Y(e.keyAgreement, n), this.keyCertSign = Y(e.keyCertSign, n), this.keyEncipherment = Y(e.keyEncipherment, n), this.nonRepudiation = Y(e.nonRepudiation, n), this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class U9 extends z {
  constructor(e) {
    super(se, "line", !0), this.hand = Y(e.hand, ["even", "left", "right"]), this.id = e.id || "", this.slope = Y(e.slope, ["\\", "/"]), this.use = e.use || "", this.usehref = e.usehref || "", this.edge = null;
  }
  [Ie]() {
    const e = this[Me]()[Me](), n = this.edge || new Ys({}), a = n[Xe](), i = /* @__PURE__ */ Object.create(null), s = n.presence === "visible" ? n.thickness : 0;
    i.strokeWidth = Oe(s), i.stroke = a.color;
    let r, o, c, l, h = "100%", f = "100%";
    e.w <= s ? ([r, o, c, l] = ["50%", 0, "50%", "100%"], h = i.strokeWidth) : e.h <= s ? ([r, o, c, l] = [0, "50%", "100%", "50%"], f = i.strokeWidth) : this.slope === "\\" ? [r, o, c, l] = [0, 0, "100%", "100%"] : [r, o, c, l] = [0, "100%", "100%", 0];
    const u = {
      name: "svg",
      children: [{
        name: "line",
        attributes: {
          xmlns: ri,
          x1: r,
          y1: o,
          x2: c,
          y2: l,
          style: i
        }
      }],
      attributes: {
        xmlns: ri,
        width: h,
        height: f,
        style: {
          overflow: "visible"
        }
      }
    };
    return ic(e) ? Se.success({
      name: "div",
      attributes: {
        style: {
          display: "inline",
          width: "100%",
          height: "100%"
        }
      },
      children: [u]
    }) : (u.attributes.style.position = "absolute", Se.success(u));
  }
}
class j9 extends z {
  constructor(e) {
    super(se, "linear", !0), this.id = e.id || "", this.type = Y(e.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null;
  }
  [Xe](e) {
    e = e ? e[Xe]() : "#FFFFFF";
    const n = this.type.replace(/([RBLT])/, " $1").toLowerCase(), a = this.color ? this.color[Xe]() : "#000000";
    return `linear-gradient(${n}, ${e}, ${a})`;
  }
}
class H9 extends mt {
  constructor(e) {
    super(se, "lockDocument"), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    this[q] = Y(this[q], ["auto", "0", "1"]);
  }
}
class $9 extends z {
  constructor(e) {
    super(se, "manifest", !0), this.action = Y(e.action, ["include", "all", "exclude"]), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.ref = new E();
  }
}
class G9 extends z {
  constructor(e) {
    super(se, "margin", !0), this.bottomInset = pe(e.bottomInset, "0"), this.id = e.id || "", this.leftInset = pe(e.leftInset, "0"), this.rightInset = pe(e.rightInset, "0"), this.topInset = pe(e.topInset, "0"), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
  [Xe]() {
    return {
      margin: Oe(this.topInset) + " " + Oe(this.rightInset) + " " + Oe(this.bottomInset) + " " + Oe(this.leftInset)
    };
  }
}
class z9 extends z {
  constructor(e) {
    super(se, "mdp"), this.id = e.id || "", this.permissions = Be({
      data: e.permissions,
      defaultValue: 2,
      validate: (n) => n === 1 || n === 3
    }), this.signatureType = Y(e.signatureType, ["filler", "author"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class _9 extends z {
  constructor(e) {
    super(se, "medium"), this.id = e.id || "", this.imagingBBox = Fx(e.imagingBBox), this.long = pe(e.long), this.orientation = Y(e.orientation, ["portrait", "landscape"]), this.short = pe(e.short), this.stock = e.stock || "", this.trayIn = Y(e.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = Y(e.trayOut, ["auto", "delegate"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class W9 extends z {
  constructor(e) {
    super(se, "message", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.text = new E();
  }
}
class V9 extends z {
  constructor(e) {
    super(se, "numericEdit", !0), this.hScrollPolicy = Y(e.hScrollPolicy, ["auto", "off", "on"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Ie](e) {
    const n = ln(this, "border", "font", "margin"), a = this[Me]()[Me](), i = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: a[et],
        dataId: a[Mn]?.[et] || a[et],
        class: ["xfaTextfield"],
        style: n,
        "aria-label": fi(a),
        "aria-required": !1
      }
    };
    return Ks(a) && (i.attributes["aria-required"] = !0, i.attributes.required = !0), Se.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [i]
    });
  }
}
class X9 extends z {
  constructor(e) {
    super(se, "occur", !0), this.id = e.id || "", this.initial = e.initial !== "" ? Be({
      data: e.initial,
      defaultValue: "",
      validate: (n) => !0
    }) : "", this.max = e.max !== "" ? Be({
      data: e.max,
      defaultValue: 1,
      validate: (n) => !0
    }) : "", this.min = e.min !== "" ? Be({
      data: e.min,
      defaultValue: 1,
      validate: (n) => !0
    }) : "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
  [Pn]() {
    const e = this[Me](), n = this.min;
    this.min === "" && (this.min = e instanceof zi || e instanceof _s ? 0 : 1), this.max === "" && (n === "" ? this.max = e instanceof zi || e instanceof _s ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = e instanceof hc ? 1 : this.min);
  }
}
class q9 extends $e {
  constructor(e) {
    super(se, "oid"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class K9 extends z {
  constructor(e) {
    super(se, "oids", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.oid = new E();
  }
}
class Ch extends z {
  constructor(e) {
    super(se, "overflow"), this.id = e.id || "", this.leader = e.leader || "", this.target = e.target || "", this.trailer = e.trailer || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [Xt]() {
    if (!this[$]) {
      const e = this[Me](), n = this[wt](), a = n[fa](this.target, e), i = n[fa](this.leader, e), s = n[fa](this.trailer, e);
      this[$] = {
        target: a?.[0] || null,
        leader: i?.[0] || null,
        trailer: s?.[0] || null,
        addLeader: !1,
        addTrailer: !1
      };
    }
    return this[$];
  }
}
class zi extends z {
  constructor(e) {
    super(se, "pageArea", !0), this.blankOrNotBlank = Y(e.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = e.id || "", this.initialNumber = Be({
      data: e.initialNumber,
      defaultValue: 1,
      validate: (n) => !0
    }), this.name = e.name || "", this.numbered = Be({
      data: e.numbered,
      defaultValue: 1,
      validate: (n) => !0
    }), this.oddOrEven = Y(e.oddOrEven, ["any", "even", "odd"]), this.pagePosition = Y(e.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new E(), this.contentArea = new E(), this.draw = new E(), this.exclGroup = new E(), this.field = new E(), this.subform = new E();
  }
  [zs]() {
    return this[$] ? !this.occur || this.occur.max === -1 || this[$].numberOfUse < this.occur.max : (this[$] = {
      numberOfUse: 0
    }, !0);
  }
  [Ii]() {
    delete this[$];
  }
  [ca]() {
    this[$] ||= {
      numberOfUse: 0
    };
    const e = this[Me]();
    return e.relation === "orderedOccurrence" && this[zs]() ? (this[$].numberOfUse += 1, this) : e[ca]();
  }
  [ii]() {
    return this[$].space || {
      width: 0,
      height: 0
    };
  }
  [Ie]() {
    this[$] ||= {
      numberOfUse: 1
    };
    const e = [];
    this[$].children = e;
    const n = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      if (n.width = Oe(this.medium.short), n.height = Oe(this.medium.long), this[$].space = {
        width: this.medium.short,
        height: this.medium.long
      }, this.medium.orientation === "landscape") {
        const a = n.width;
        n.width = n.height, n.height = a, this[$].space = {
          width: this.medium.long,
          height: this.medium.short
        };
      }
    } else
      F("XFA - No medium specified in pageArea: please file a bug.");
    return this[Ua]({
      filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
      include: !0
    }), this[Ua]({
      filter: /* @__PURE__ */ new Set(["contentArea"]),
      include: !0
    }), Se.success({
      name: "div",
      children: e,
      attributes: {
        class: ["xfaPage"],
        id: this[et],
        style: n,
        xfaName: this.name
      }
    });
  }
}
class _s extends z {
  constructor(e) {
    super(se, "pageSet", !0), this.duplexImposition = Y(e.duplexImposition, ["longEdge", "shortEdge"]), this.id = e.id || "", this.name = e.name || "", this.relation = Y(e.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.occur = null, this.pageArea = new E(), this.pageSet = new E();
  }
  [Ii]() {
    for (const e of this.pageArea.children)
      e[Ii]();
    for (const e of this.pageSet.children)
      e[Ii]();
  }
  [zs]() {
    return !this.occur || this.occur.max === -1 || this[$].numberOfUse < this.occur.max;
  }
  [ca]() {
    if (this[$] ||= {
      numberOfUse: 1,
      pageIndex: -1,
      pageSetIndex: -1
    }, this.relation === "orderedOccurrence") {
      if (this[$].pageIndex + 1 < this.pageArea.children.length)
        return this[$].pageIndex += 1, this.pageArea.children[this[$].pageIndex][ca]();
      if (this[$].pageSetIndex + 1 < this.pageSet.children.length)
        return this[$].pageSetIndex += 1, this.pageSet.children[this[$].pageSetIndex][ca]();
      if (this[zs]())
        return this[$].numberOfUse += 1, this[$].pageIndex = -1, this[$].pageSetIndex = -1, this[ca]();
      const s = this[Me]();
      return s instanceof _s ? s[ca]() : (this[Ii](), this[ca]());
    }
    const e = this[wt]()[$].pageNumber, n = e % 2 === 0 ? "even" : "odd", a = e === 0 ? "first" : "rest";
    let i = this.pageArea.children.find((s) => s.oddOrEven === n && s.pagePosition === a);
    return i || (i = this.pageArea.children.find((s) => s.oddOrEven === "any" && s.pagePosition === a), i) || (i = this.pageArea.children.find((s) => s.oddOrEven === "any" && s.pagePosition === "any"), i) ? i : this.pageArea.children[0];
  }
}
class Y9 extends z {
  constructor(e) {
    super(se, "para", !0), this.hAlign = Y(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e.id || "", this.lineHeight = e.lineHeight ? pe(e.lineHeight, "0pt") : "", this.marginLeft = e.marginLeft ? pe(e.marginLeft, "0pt") : "", this.marginRight = e.marginRight ? pe(e.marginRight, "0pt") : "", this.orphans = Be({
      data: e.orphans,
      defaultValue: 0,
      validate: (n) => n >= 0
    }), this.preserve = e.preserve || "", this.radixOffset = e.radixOffset ? pe(e.radixOffset, "0pt") : "", this.spaceAbove = e.spaceAbove ? pe(e.spaceAbove, "0pt") : "", this.spaceBelow = e.spaceBelow ? pe(e.spaceBelow, "0pt") : "", this.tabDefault = e.tabDefault ? pe(this.tabDefault) : "", this.tabStops = (e.tabStops || "").trim().split(/\s+/).map((n, a) => a % 2 === 1 ? pe(n) : n), this.textIndent = e.textIndent ? pe(e.textIndent, "0pt") : "", this.use = e.use || "", this.usehref = e.usehref || "", this.vAlign = Y(e.vAlign, ["top", "bottom", "middle"]), this.widows = Be({
      data: e.widows,
      defaultValue: 0,
      validate: (n) => n >= 0
    }), this.hyphenation = null;
  }
  [Xe]() {
    const e = ln(this, "hAlign");
    return this.marginLeft !== "" && (e.paddingLeft = Oe(this.marginLeft)), this.marginRight !== "" && (e.paddingRight = Oe(this.marginRight)), this.spaceAbove !== "" && (e.paddingTop = Oe(this.spaceAbove)), this.spaceBelow !== "" && (e.paddingBottom = Oe(this.spaceBelow)), this.textIndent !== "" && (e.textIndent = Oe(this.textIndent), rh(e)), this.lineHeight > 0 && (e.lineHeight = Oe(this.lineHeight)), this.tabDefault !== "" && (e.tabSize = Oe(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(e, this.hyphenatation[Xe]()), e;
  }
}
class J9 extends z {
  constructor(e) {
    super(se, "passwordEdit", !0), this.hScrollPolicy = Y(e.hScrollPolicy, ["auto", "off", "on"]), this.id = e.id || "", this.passwordChar = e.passwordChar || "*", this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
}
class Z9 extends z {
  constructor(e) {
    super(se, "pattern", !0), this.id = e.id || "", this.type = Y(e.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null;
  }
  [Xe](e) {
    e = e ? e[Xe]() : "#FFFFFF";
    const n = this.color ? this.color[Xe]() : "#000000", a = 5, i = "repeating-linear-gradient", s = `${e},${e} ${a}px,${n} ${a}px,${n} ${2 * a}px`;
    switch (this.type) {
      case "crossHatch":
        return `${i}(to top,${s}) ${i}(to right,${s})`;
      case "crossDiagonal":
        return `${i}(45deg,${s}) ${i}(-45deg,${s})`;
      case "diagonalLeft":
        return `${i}(45deg,${s})`;
      case "diagonalRight":
        return `${i}(-45deg,${s})`;
      case "horizontal":
        return `${i}(to top,${s})`;
      case "vertical":
        return `${i}(to right,${s})`;
    }
    return "";
  }
}
class Q9 extends $e {
  constructor(e) {
    super(se, "picture"), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class eg extends z {
  constructor(e) {
    super(se, "proto", !0), this.appearanceFilter = new E(), this.arc = new E(), this.area = new E(), this.assist = new E(), this.barcode = new E(), this.bindItems = new E(), this.bookend = new E(), this.boolean = new E(), this.border = new E(), this.break = new E(), this.breakAfter = new E(), this.breakBefore = new E(), this.button = new E(), this.calculate = new E(), this.caption = new E(), this.certificate = new E(), this.certificates = new E(), this.checkButton = new E(), this.choiceList = new E(), this.color = new E(), this.comb = new E(), this.connect = new E(), this.contentArea = new E(), this.corner = new E(), this.date = new E(), this.dateTime = new E(), this.dateTimeEdit = new E(), this.decimal = new E(), this.defaultUi = new E(), this.desc = new E(), this.digestMethod = new E(), this.digestMethods = new E(), this.draw = new E(), this.edge = new E(), this.encoding = new E(), this.encodings = new E(), this.encrypt = new E(), this.encryptData = new E(), this.encryption = new E(), this.encryptionMethod = new E(), this.encryptionMethods = new E(), this.event = new E(), this.exData = new E(), this.exObject = new E(), this.exclGroup = new E(), this.execute = new E(), this.extras = new E(), this.field = new E(), this.fill = new E(), this.filter = new E(), this.float = new E(), this.font = new E(), this.format = new E(), this.handler = new E(), this.hyphenation = new E(), this.image = new E(), this.imageEdit = new E(), this.integer = new E(), this.issuers = new E(), this.items = new E(), this.keep = new E(), this.keyUsage = new E(), this.line = new E(), this.linear = new E(), this.lockDocument = new E(), this.manifest = new E(), this.margin = new E(), this.mdp = new E(), this.medium = new E(), this.message = new E(), this.numericEdit = new E(), this.occur = new E(), this.oid = new E(), this.oids = new E(), this.overflow = new E(), this.pageArea = new E(), this.pageSet = new E(), this.para = new E(), this.passwordEdit = new E(), this.pattern = new E(), this.picture = new E(), this.radial = new E(), this.reason = new E(), this.reasons = new E(), this.rectangle = new E(), this.ref = new E(), this.script = new E(), this.setProperty = new E(), this.signData = new E(), this.signature = new E(), this.signing = new E(), this.solid = new E(), this.speak = new E(), this.stipple = new E(), this.subform = new E(), this.subformSet = new E(), this.subjectDN = new E(), this.subjectDNs = new E(), this.submit = new E(), this.text = new E(), this.textEdit = new E(), this.time = new E(), this.timeStamp = new E(), this.toolTip = new E(), this.traversal = new E(), this.traverse = new E(), this.ui = new E(), this.validate = new E(), this.value = new E(), this.variables = new E();
  }
}
class tg extends z {
  constructor(e) {
    super(se, "radial", !0), this.id = e.id || "", this.type = Y(e.type, ["toEdge", "toCenter"]), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null;
  }
  [Xe](e) {
    e = e ? e[Xe]() : "#FFFFFF";
    const n = this.color ? this.color[Xe]() : "#000000";
    return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${e},${n}` : `${n},${e}`})`;
  }
}
class ng extends $e {
  constructor(e) {
    super(se, "reason"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class ag extends z {
  constructor(e) {
    super(se, "reasons", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.reason = new E();
  }
}
class Ih extends z {
  constructor(e) {
    super(se, "rectangle", !0), this.hand = Y(e.hand, ["even", "left", "right"]), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.corner = new E(4), this.edge = new E(4), this.fill = null;
  }
  [Ie]() {
    const e = this.edge.children.length ? this.edge.children[0] : new Ys({}), n = e[Xe](), a = /* @__PURE__ */ Object.create(null);
    this.fill?.presence === "visible" ? Object.assign(a, this.fill[Xe]()) : a.fill = "transparent", a.strokeWidth = Oe(e.presence === "visible" ? e.thickness : 0), a.stroke = n.color;
    const s = (this.corner.children.length ? this.corner.children[0] : new vh({}))[Xe](), o = {
      name: "svg",
      children: [{
        name: "rect",
        attributes: {
          xmlns: ri,
          width: "100%",
          height: "100%",
          x: 0,
          y: 0,
          rx: s.radius,
          ry: s.radius,
          style: a
        }
      }],
      attributes: {
        xmlns: ri,
        style: {
          overflow: "visible"
        },
        width: "100%",
        height: "100%"
      }
    }, c = this[Me]()[Me]();
    return ic(c) ? Se.success({
      name: "div",
      attributes: {
        style: {
          display: "inline",
          width: "100%",
          height: "100%"
        }
      },
      children: [o]
    }) : (o.attributes.style.position = "absolute", Se.success(o));
  }
}
class ig extends $e {
  constructor(e) {
    super(se, "ref"), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class sg extends $e {
  constructor(e) {
    super(se, "script"), this.binding = e.binding || "", this.contentType = e.contentType || "", this.id = e.id || "", this.name = e.name || "", this.runAt = Y(e.runAt, ["client", "both", "server"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class To extends z {
  constructor(e) {
    super(se, "setProperty"), this.connection = e.connection || "", this.ref = e.ref || "", this.target = e.target || "";
  }
}
class rg extends z {
  constructor(e) {
    super(se, "signData", !0), this.id = e.id || "", this.operation = Y(e.operation, ["sign", "clear", "verify"]), this.ref = e.ref || "", this.target = e.target || "", this.use = e.use || "", this.usehref = e.usehref || "", this.filter = null, this.manifest = null;
  }
}
class og extends z {
  constructor(e) {
    super(se, "signature", !0), this.id = e.id || "", this.type = Y(e.type, ["PDF1.3", "PDF1.6"]), this.use = e.use || "", this.usehref = e.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
  }
}
class cg extends z {
  constructor(e) {
    super(se, "signing", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.certificate = new E();
  }
}
class lg extends z {
  constructor(e) {
    super(se, "solid", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null;
  }
  [Xe](e) {
    return e ? e[Xe]() : "#FFFFFF";
  }
}
class hg extends $e {
  constructor(e) {
    super(se, "speak"), this.disable = Be({
      data: e.disable,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.id = e.id || "", this.priority = Y(e.priority, ["custom", "caption", "name", "toolTip"]), this.rid = e.rid || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class fg extends z {
  constructor(e) {
    super(se, "stipple", !0), this.id = e.id || "", this.rate = Be({
      data: e.rate,
      defaultValue: 50,
      validate: (n) => n >= 0 && n <= 100
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.color = null, this.extras = null;
  }
  [Xe](e) {
    const n = this.rate / 100;
    return Je.makeHexColor(Math.round(e.value.r * (1 - n) + this.value.r * n), Math.round(e.value.g * (1 - n) + this.value.g * n), Math.round(e.value.b * (1 - n) + this.value.b * n));
  }
}
class Th extends z {
  constructor(e) {
    super(se, "subform", !0), this.access = Y(e.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = Be({
      data: e.allowMacro,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.anchorType = Y(e.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Be({
      data: e.colSpan,
      defaultValue: 1,
      validate: (n) => n >= 1 || n === -1
    }), this.columnWidths = (e.columnWidths || "").trim().split(/\s+/).map((n) => n === "-1" ? -1 : pe(n)), this.h = e.h ? pe(e.h) : "", this.hAlign = Y(e.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = e.id || "", this.layout = Y(e.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = e.locale || "", this.maxH = pe(e.maxH, "0pt"), this.maxW = pe(e.maxW, "0pt"), this.mergeMode = Y(e.mergeMode, ["consumeData", "matchTemplate"]), this.minH = pe(e.minH, "0pt"), this.minW = pe(e.minW, "0pt"), this.name = e.name || "", this.presence = Y(e.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = _n(e.relevant), this.restoreState = Y(e.restoreState, ["manual", "auto"]), this.scope = Y(e.scope, ["name", "none"]), this.use = e.use || "", this.usehref = e.usehref || "", this.w = e.w ? pe(e.w) : "", this.x = pe(e.x, "0pt"), this.y = pe(e.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new E(), this.breakAfter = new E(), this.breakBefore = new E(), this.connect = new E(), this.draw = new E(), this.event = new E(), this.exObject = new E(), this.exclGroup = new E(), this.field = new E(), this.proto = new E(), this.setProperty = new E(), this.subform = new E(), this.subformSet = new E();
  }
  [kt]() {
    const e = this[Me]();
    return e instanceof lc ? e[kt]() : e;
  }
  [di]() {
    return !0;
  }
  [ba]() {
    return this.layout.endsWith("-tb") && this[$].attempt === 0 && this[$].numberInLine > 0 || this[Me]()[ba]();
  }
  *[Gi]() {
    yield* rc(this);
  }
  [qs]() {
    return uh(this);
  }
  [ai](e, n) {
    dh(this, e, n);
  }
  [ii]() {
    return xh(this);
  }
  [ga]() {
    const e = this[kt]();
    return e[ga]() ? this[$]._isSplittable !== void 0 ? this[$]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[$]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[$]._isSplittable = !1, !1) : e.layout?.endsWith("-tb") && e[$].numberInLine !== 0 ? !1 : (this[$]._isSplittable = !0, !0) : !1;
  }
  [Ie](e) {
    if (x0(this), this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const w = new mh({
          targetType: this.break.after,
          target: this.break.afterTarget,
          startNew: this.break.startNew.toString()
        });
        w[it] = this[it], this[gt](w), this.breakAfter.push(w);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const w = new bh({
          targetType: this.break.before,
          target: this.break.beforeTarget,
          startNew: this.break.startNew.toString()
        });
        w[it] = this[it], this[gt](w), this.breakBefore.push(w);
      }
      if (this.break.overflowTarget !== "") {
        const w = new Ch({
          target: this.break.overflowTarget,
          leader: this.break.overflowLeader,
          trailer: this.break.overflowTrailer
        });
        w[it] = this[it], this[gt](w), this.overflow.push(w);
      }
      this[Na](this.break), this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive")
      return Se.EMPTY;
    if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && F("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
      const w = this.breakBefore.children[0];
      if (jl(w))
        return Se.breakNode(w);
    }
    if (this[$]?.afterBreakAfter)
      return Se.EMPTY;
    u0(this);
    const n = [], a = {
      id: this[et],
      class: []
    };
    ac(this, a.class), this[$] ||= /* @__PURE__ */ Object.create(null), Object.assign(this[$], {
      children: n,
      line: null,
      attributes: a,
      attempt: 0,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || 1 / 0, e.width),
        height: Math.min(this.h || 1 / 0, e.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const i = this[wt](), s = i[$].noLayoutFailure, r = this[ga]();
    if (r || p0(this), !d0(this, e))
      return Se.FAILURE;
    const o = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const w = this[kt]().columnWidths;
      Array.isArray(w) && w.length > 0 && (this[$].columnWidths = w, this[$].currentColumn = 0);
    }
    const c = ln(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), l = ["xfaSubform"], h = sh(this);
    if (h && l.push(h), a.style = c, a.class = l, this.name && (a.xfaName = this.name), this.overflow) {
      const w = this.overflow[Xt]();
      w.addLeader && (w.addLeader = !1, Hl(this, w.leader, e));
    }
    this[Xi]();
    const f = this.layout === "lr-tb" || this.layout === "rl-tb", d = f ? Vr : 1;
    for (; this[$].attempt < d; this[$].attempt++) {
      f && this[$].attempt === Vr - 1 && (this[$].numberInLine = 0);
      const w = this[Ua]({
        filter: o,
        include: !0
      });
      if (w.success)
        break;
      if (w.isBreak())
        return this[dn](), w;
      if (f && this[$].attempt === 0 && this[$].numberInLine === 0 && !i[$].noLayoutFailure) {
        this[$].attempt = d;
        break;
      }
    }
    if (this[dn](), r || m0(this), i[$].noLayoutFailure = s, this[$].attempt === d)
      return this.overflow && (this[wt]()[$].overflowNode = this.overflow), r || delete this[$], Se.FAILURE;
    if (this.overflow) {
      const w = this.overflow[Xt]();
      w.addTrailer && (w.addTrailer = !1, Hl(this, w.trailer, e));
    }
    let u = 0, x = 0;
    this.margin && (u = this.margin.leftInset + this.margin.rightInset, x = this.margin.topInset + this.margin.bottomInset);
    const g = Math.max(this[$].width + u, this.w || 0), p = Math.max(this[$].height + x, this.h || 0), m = [this.x, this.y, g, p];
    if (this.w === "" && (c.width = Oe(g)), this.h === "" && (c.height = Oe(p)), (c.width === "0px" || c.height === "0px") && n.length === 0)
      return Se.EMPTY;
    const b = {
      name: "div",
      attributes: a,
      children: n
    };
    g0(this, a);
    const y = Se.success(si(this, b), m);
    if (this.breakAfter.children.length >= 1) {
      const w = this.breakAfter.children[0];
      if (jl(w))
        return this[$].afterBreakAfter = y, Se.breakNode(w);
    }
    return delete this[$], y;
  }
}
class lc extends z {
  constructor(e) {
    super(se, "subformSet", !0), this.id = e.id || "", this.name = e.name || "", this.relation = Y(e.relation, ["ordered", "choice", "unordered"]), this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new E(), this.breakBefore = new E(), this.subform = new E(), this.subformSet = new E();
  }
  *[Gi]() {
    yield* rc(this);
  }
  [kt]() {
    let e = this[Me]();
    for (; !(e instanceof Th); )
      e = e[Me]();
    return e;
  }
  [di]() {
    return !0;
  }
}
class ug extends mt {
  constructor(e) {
    super(se, "subjectDN"), this.delimiter = e.delimiter || ",", this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    this[q] = new Map(this[q].split(this.delimiter).map((e) => (e = e.split("=", 2), e[0] = e[0].trim(), e)));
  }
}
class dg extends z {
  constructor(e) {
    super(se, "subjectDNs", !0), this.id = e.id || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "", this.subjectDN = new E();
  }
}
class xg extends z {
  constructor(e) {
    super(se, "submit", !0), this.embedPDF = Be({
      data: e.embedPDF,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.format = Y(e.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = e.id || "", this.target = e.target || "", this.textEncoding = f0({
      data: e.textEncoding ? e.textEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: (n) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(n) || n.match(/iso-8859-\d{2}/)
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.xdpContent = e.xdpContent || "", this.encrypt = null, this.encryptData = new E(), this.signData = new E();
  }
}
class hc extends z {
  constructor(e) {
    super(se, "template", !0), this.baseProfile = Y(e.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new E();
  }
  [st]() {
    this.subform.children.length === 0 && F("XFA - No subforms in template node."), this.subform.children.length >= 2 && F("XFA - Several subforms in template node: please file a bug."), this[Ln] = Hx;
  }
  [ga]() {
    return !0;
  }
  [fa](e, n) {
    return e.startsWith("#") ? [this[Ai].get(e.slice(1))] : Ca(this, n, e, !0, !0);
  }
  *[Z1]() {
    if (!this.subform.children.length)
      return Se.success({
        name: "div",
        children: []
      });
    this[$] = {
      overflowNode: null,
      firstUnsplittable: null,
      currentContentArea: null,
      currentPageArea: null,
      noLayoutFailure: !1,
      pageNumber: 1,
      pagePosition: "first",
      oddOrEven: "odd",
      blankOrNotBlank: "nonBlank",
      paraStack: []
    };
    const e = this.subform.children[0];
    e.pageSet[Ii]();
    const n = e.pageSet.pageArea.children, a = {
      name: "div",
      children: []
    };
    let i = null, s = null, r = null;
    if (e.breakBefore.children.length >= 1 ? (s = e.breakBefore.children[0], r = s.target) : e.subform.children.length >= 1 && e.subform.children[0].breakBefore.children.length >= 1 ? (s = e.subform.children[0].breakBefore.children[0], r = s.target) : e.break?.beforeTarget ? (s = e.break, r = s.beforeTarget) : e.subform.children.length >= 1 && e.subform.children[0].break?.beforeTarget && (s = e.subform.children[0].break, r = s.beforeTarget), s) {
      const x = this[fa](r, s[Me]());
      x instanceof zi && (i = x, s[$] = {});
    }
    i ||= n[0], i[$] = {
      numberOfUse: 1
    };
    const o = i[Me]();
    o[$] = {
      numberOfUse: 1,
      pageIndex: o.pageArea.children.indexOf(i),
      pageSetIndex: 0
    };
    let c, l = null, h = null, f = !0, d = 0, u = 0;
    for (; ; ) {
      if (f)
        d = 0;
      else if (a.children.pop(), ++d === jx)
        return F("XFA - Something goes wrong: please file a bug."), a;
      c = null, this[$].currentPageArea = i;
      const x = i[Ie]().html;
      a.children.push(x), l && (this[$].noLayoutFailure = !0, x.children.push(l[Ie](i[$].space).html), l = null), h && (this[$].noLayoutFailure = !0, x.children.push(h[Ie](i[$].space).html), h = null);
      const g = i.contentArea.children, p = x.children.filter((b) => b.attributes.class.includes("xfaContentarea"));
      f = !1, this[$].firstUnsplittable = null, this[$].noLayoutFailure = !1;
      const m = (b) => {
        const y = e[qs]();
        y && (f ||= y.children?.length > 0, p[b].children.push(y));
      };
      for (let b = u, y = g.length; b < y; b++) {
        const w = this[$].currentContentArea = g[b], S = {
          width: w.w,
          height: w.h
        };
        u = 0, l && (p[b].children.push(l[Ie](S).html), l = null), h && (p[b].children.push(h[Ie](S).html), h = null);
        const v = e[Ie](S);
        if (v.success)
          return v.html ? (f ||= v.html.children?.length > 0, p[b].children.push(v.html)) : !f && a.children.length > 1 && a.children.pop(), a;
        if (v.isBreak()) {
          const k = v.breakNode;
          if (m(b), k.targetType === "auto")
            continue;
          k.leader && (l = this[fa](k.leader, k[Me]()), l = l ? l[0] : null), k.trailer && (h = this[fa](k.trailer, k[Me]()), h = h ? h[0] : null), k.targetType === "pageArea" ? (c = k[$].target, b = 1 / 0) : k[$].target ? (c = k[$].target, u = k[$].index + 1, b = 1 / 0) : b = k[$].index;
          continue;
        }
        if (this[$].overflowNode) {
          const k = this[$].overflowNode;
          this[$].overflowNode = null;
          const A = k[Xt](), C = A.target;
          A.addLeader = A.leader !== null, A.addTrailer = A.trailer !== null, m(b);
          const T = b;
          if (b = 1 / 0, C instanceof zi)
            c = C;
          else if (C instanceof oc) {
            const M = g.indexOf(C);
            M !== -1 ? M > T ? b = M - 1 : u = M : (c = C[Me](), u = c.contentArea.children.indexOf(C));
          }
          continue;
        }
        m(b);
      }
      this[$].pageNumber += 1, c && (c[zs]() ? c[$].numberOfUse += 1 : c = null), i = c || i[ca](), yield null;
    }
  }
}
class Eh extends mt {
  constructor(e) {
    super(se, "text"), this.id = e.id || "", this.maxChars = Be({
      data: e.maxChars,
      defaultValue: 0,
      validate: (n) => n >= 0
    }), this.name = e.name || "", this.rid = e.rid || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [c0]() {
    return !0;
  }
  [ea](e) {
    return e[vt] === At.xhtml.id ? (this[q] = e, !0) : (F(`XFA - Invalid content in Text: ${e[qe]}.`), !1);
  }
  [pa](e) {
    this[q] instanceof z || super[pa](e);
  }
  [st]() {
    typeof this[q] == "string" && (this[q] = this[q].replaceAll(`\r
`, `
`));
  }
  [Xt]() {
    return typeof this[q] == "string" ? this[q].split(/[\u2029\u2028\n]/).filter((e) => !!e).join(`
`) : this[q][Ft]();
  }
  [Ie](e) {
    if (typeof this[q] == "string") {
      const n = ja(this[q]).html;
      return this[q].includes("\u2029") ? (n.name = "div", n.children = [], this[q].split("\u2029").map((a) => a.split(/[\u2028\n]/).flatMap((i) => [{
        name: "span",
        value: i
      }, {
        name: "br"
      }])).forEach((a) => {
        n.children.push({
          name: "p",
          children: a
        });
      })) : /[\u2028\n]/.test(this[q]) && (n.name = "div", n.children = [], this[q].split(/[\u2028\n]/).forEach((a) => {
        n.children.push({
          name: "span",
          value: a
        }, {
          name: "br"
        });
      })), Se.success(n);
    }
    return this[q][Ie](e);
  }
}
class Fh extends z {
  constructor(e) {
    super(se, "textEdit", !0), this.allowRichText = Be({
      data: e.allowRichText,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.hScrollPolicy = Y(e.hScrollPolicy, ["auto", "off", "on"]), this.id = e.id || "", this.multiLine = Be({
      data: e.multiLine,
      defaultValue: "",
      validate: (n) => n === 0 || n === 1
    }), this.use = e.use || "", this.usehref = e.usehref || "", this.vScrollPolicy = Y(e.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Ie](e) {
    const n = ln(this, "border", "font", "margin");
    let a;
    const i = this[Me]()[Me]();
    return this.multiLine === "" && (this.multiLine = i instanceof Sh ? 1 : 0), this.multiLine === 1 ? a = {
      name: "textarea",
      attributes: {
        dataId: i[Mn]?.[et] || i[et],
        fieldId: i[et],
        class: ["xfaTextfield"],
        style: n,
        "aria-label": fi(i),
        "aria-required": !1
      }
    } : a = {
      name: "input",
      attributes: {
        type: "text",
        dataId: i[Mn]?.[et] || i[et],
        fieldId: i[et],
        class: ["xfaTextfield"],
        style: n,
        "aria-label": fi(i),
        "aria-required": !1
      }
    }, Ks(i) && (a.attributes["aria-required"] = !0, a.attributes.required = !0), Se.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [a]
    });
  }
}
class gg extends $e {
  constructor(e) {
    super(se, "time"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
  [st]() {
    const e = this[q].trim();
    this[q] = e ? new Date(e) : null;
  }
  [Ie](e) {
    return ja(this[q] ? this[q].toString() : "");
  }
}
class pg extends z {
  constructor(e) {
    super(se, "timeStamp"), this.id = e.id || "", this.server = e.server || "", this.type = Y(e.type, ["optional", "required"]), this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class mg extends $e {
  constructor(e) {
    super(se, "toolTip"), this.id = e.id || "", this.rid = e.rid || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class bg extends z {
  constructor(e) {
    super(se, "traversal", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.traverse = new E();
  }
}
class yg extends z {
  constructor(e) {
    super(se, "traverse", !0), this.id = e.id || "", this.operation = Y(e.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = e.ref || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.script = null;
  }
  get name() {
    return this.operation;
  }
  [Gs]() {
    return !1;
  }
}
class fc extends z {
  constructor(e) {
    super(se, "ui", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
  }
  [Xt]() {
    if (this[$] === void 0) {
      for (const e of Object.getOwnPropertyNames(this)) {
        if (e === "extras" || e === "picture")
          continue;
        const n = this[e];
        if (n instanceof z)
          return this[$] = n, n;
      }
      this[$] = null;
    }
    return this[$];
  }
  [Ie](e) {
    const n = this[Xt]();
    return n ? n[Ie](e) : Se.EMPTY;
  }
}
class wg extends z {
  constructor(e) {
    super(se, "validate", !0), this.formatTest = Y(e.formatTest, ["warning", "disabled", "error"]), this.id = e.id || "", this.nullTest = Y(e.nullTest, ["disabled", "error", "warning"]), this.scriptTest = Y(e.scriptTest, ["error", "disabled", "warning"]), this.use = e.use || "", this.usehref = e.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
  }
}
class uc extends z {
  constructor(e) {
    super(se, "value", !0), this.id = e.id || "", this.override = Be({
      data: e.override,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.relevant = _n(e.relevant), this.use = e.use || "", this.usehref = e.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
  }
  [pn](e) {
    const n = this[Me]();
    if (n instanceof cc && n.ui?.imageEdit) {
      this.image || (this.image = new Ah({}), this[gt](this.image)), this.image[q] = e[q];
      return;
    }
    const a = e[qe];
    if (this[a] !== null) {
      this[a][q] = e[q];
      return;
    }
    for (const i of Object.getOwnPropertyNames(this)) {
      const s = this[i];
      s instanceof z && (this[i] = null, this[Na](s));
    }
    this[e[qe]] = e, this[gt](e);
  }
  [Ft]() {
    if (this.exData)
      return typeof this.exData[q] == "string" ? this.exData[q].trim() : this.exData[q][Ft]().trim();
    for (const e of Object.getOwnPropertyNames(this)) {
      if (e === "image")
        continue;
      const n = this[e];
      if (n instanceof z)
        return (n[q] || "").toString().trim();
    }
    return null;
  }
  [Ie](e) {
    for (const n of Object.getOwnPropertyNames(this)) {
      const a = this[n];
      if (a instanceof z)
        return a[Ie](e);
    }
    return Se.EMPTY;
  }
}
class vg extends z {
  constructor(e) {
    super(se, "variables", !0), this.id = e.id || "", this.use = e.use || "", this.usehref = e.usehref || "", this.boolean = new E(), this.date = new E(), this.dateTime = new E(), this.decimal = new E(), this.exData = new E(), this.float = new E(), this.image = new E(), this.integer = new E(), this.manifest = new E(), this.script = new E(), this.text = new E(), this.time = new E();
  }
  [Gs]() {
    return !0;
  }
}
class Xr {
  static [zn](e, n) {
    if (Xr.hasOwnProperty(e)) {
      const a = Xr[e](n);
      return a[J1](n), a;
    }
  }
  static appearanceFilter(e) {
    return new _x(e);
  }
  static arc(e) {
    return new gh(e);
  }
  static area(e) {
    return new Wx(e);
  }
  static assist(e) {
    return new Vx(e);
  }
  static barcode(e) {
    return new Xx(e);
  }
  static bind(e) {
    return new qx(e);
  }
  static bindItems(e) {
    return new Co(e);
  }
  static bookend(e) {
    return new Kx(e);
  }
  static boolean(e) {
    return new Yx(e);
  }
  static border(e) {
    return new ph(e);
  }
  static break(e) {
    return new Jx(e);
  }
  static breakAfter(e) {
    return new mh(e);
  }
  static breakBefore(e) {
    return new bh(e);
  }
  static button(e) {
    return new Zx(e);
  }
  static calculate(e) {
    return new Qx(e);
  }
  static caption(e) {
    return new e9(e);
  }
  static certificate(e) {
    return new t9(e);
  }
  static certificates(e) {
    return new n9(e);
  }
  static checkButton(e) {
    return new yh(e);
  }
  static choiceList(e) {
    return new wh(e);
  }
  static color(e) {
    return new a9(e);
  }
  static comb(e) {
    return new i9(e);
  }
  static connect(e) {
    return new s9(e);
  }
  static contentArea(e) {
    return new oc(e);
  }
  static corner(e) {
    return new vh(e);
  }
  static date(e) {
    return new r9(e);
  }
  static dateTime(e) {
    return new o9(e);
  }
  static dateTimeEdit(e) {
    return new c9(e);
  }
  static decimal(e) {
    return new l9(e);
  }
  static defaultUi(e) {
    return new h9(e);
  }
  static desc(e) {
    return new f9(e);
  }
  static digestMethod(e) {
    return new u9(e);
  }
  static digestMethods(e) {
    return new d9(e);
  }
  static draw(e) {
    return new Sh(e);
  }
  static edge(e) {
    return new Ys(e);
  }
  static encoding(e) {
    return new x9(e);
  }
  static encodings(e) {
    return new g9(e);
  }
  static encrypt(e) {
    return new p9(e);
  }
  static encryptData(e) {
    return new m9(e);
  }
  static encryption(e) {
    return new b9(e);
  }
  static encryptionMethod(e) {
    return new y9(e);
  }
  static encryptionMethods(e) {
    return new w9(e);
  }
  static event(e) {
    return new v9(e);
  }
  static exData(e) {
    return new S9(e);
  }
  static exObject(e) {
    return new k9(e);
  }
  static exclGroup(e) {
    return new kh(e);
  }
  static execute(e) {
    return new A9(e);
  }
  static extras(e) {
    return new C9(e);
  }
  static field(e) {
    return new cc(e);
  }
  static fill(e) {
    return new I9(e);
  }
  static filter(e) {
    return new T9(e);
  }
  static float(e) {
    return new E9(e);
  }
  static font(e) {
    return new F9(e);
  }
  static format(e) {
    return new R9(e);
  }
  static handler(e) {
    return new O9(e);
  }
  static hyphenation(e) {
    return new B9(e);
  }
  static image(e) {
    return new Ah(e);
  }
  static imageEdit(e) {
    return new M9(e);
  }
  static integer(e) {
    return new P9(e);
  }
  static issuers(e) {
    return new N9(e);
  }
  static items(e) {
    return new Io(e);
  }
  static keep(e) {
    return new D9(e);
  }
  static keyUsage(e) {
    return new L9(e);
  }
  static line(e) {
    return new U9(e);
  }
  static linear(e) {
    return new j9(e);
  }
  static lockDocument(e) {
    return new H9(e);
  }
  static manifest(e) {
    return new $9(e);
  }
  static margin(e) {
    return new G9(e);
  }
  static mdp(e) {
    return new z9(e);
  }
  static medium(e) {
    return new _9(e);
  }
  static message(e) {
    return new W9(e);
  }
  static numericEdit(e) {
    return new V9(e);
  }
  static occur(e) {
    return new X9(e);
  }
  static oid(e) {
    return new q9(e);
  }
  static oids(e) {
    return new K9(e);
  }
  static overflow(e) {
    return new Ch(e);
  }
  static pageArea(e) {
    return new zi(e);
  }
  static pageSet(e) {
    return new _s(e);
  }
  static para(e) {
    return new Y9(e);
  }
  static passwordEdit(e) {
    return new J9(e);
  }
  static pattern(e) {
    return new Z9(e);
  }
  static picture(e) {
    return new Q9(e);
  }
  static proto(e) {
    return new eg(e);
  }
  static radial(e) {
    return new tg(e);
  }
  static reason(e) {
    return new ng(e);
  }
  static reasons(e) {
    return new ag(e);
  }
  static rectangle(e) {
    return new Ih(e);
  }
  static ref(e) {
    return new ig(e);
  }
  static script(e) {
    return new sg(e);
  }
  static setProperty(e) {
    return new To(e);
  }
  static signData(e) {
    return new rg(e);
  }
  static signature(e) {
    return new og(e);
  }
  static signing(e) {
    return new cg(e);
  }
  static solid(e) {
    return new lg(e);
  }
  static speak(e) {
    return new hg(e);
  }
  static stipple(e) {
    return new fg(e);
  }
  static subform(e) {
    return new Th(e);
  }
  static subformSet(e) {
    return new lc(e);
  }
  static subjectDN(e) {
    return new ug(e);
  }
  static subjectDNs(e) {
    return new dg(e);
  }
  static submit(e) {
    return new xg(e);
  }
  static template(e) {
    return new hc(e);
  }
  static text(e) {
    return new Eh(e);
  }
  static textEdit(e) {
    return new Fh(e);
  }
  static time(e) {
    return new gg(e);
  }
  static timeStamp(e) {
    return new pg(e);
  }
  static toolTip(e) {
    return new mg(e);
  }
  static traversal(e) {
    return new bg(e);
  }
  static traverse(e) {
    return new yg(e);
  }
  static ui(e) {
    return new fc(e);
  }
  static validate(e) {
    return new wg(e);
  }
  static value(e) {
    return new uc(e);
  }
  static variables(e) {
    return new vg(e);
  }
}
const $l = At.datasets.id;
function Ar(t) {
  const e = new Eh({});
  return e[q] = t, e;
}
class Sg {
  constructor(e) {
    this.root = e, this.datasets = e.datasets, this.data = e.datasets?.data || new ta(At.datasets.id, "data"), this.emptyMerge = this.data[Ut]().length === 0, this.root.form = this.form = e.template[jn]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    return this._bindElement(this.form, this.data), this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(e, n, a) {
    if (e[Mn] = n, e[$s]())
      if (n[Ti]()) {
        const i = n[Zo]();
        e[pn](Ar(i));
      } else if (e instanceof cc && e.ui?.choiceList?.open === "multiSelect") {
        const i = n[Ut]().map((s) => s[q].trim()).join(`
`);
        e[pn](Ar(i));
      } else this._isConsumeData() && F("XFA - Nodes haven't the same type.");
    else !n[Ti]() || this._isMatchTemplate() ? this._bindElement(e, n) : F("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(e, n, a, i) {
    if (!e)
      return null;
    let s, r;
    for (let o = 0; o < 3; o++) {
      for (s = a[Ss](e, !1, !0); r = s.next().value, !!r; )
        if (n === r[Ti]())
          return r;
      if (a[vt] === At.datasets.id && a[qe] === "data")
        break;
      a = a[Me]();
    }
    return i ? (s = this.data[Ss](e, !0, !1), r = s.next().value, r || (s = this.data[wo](e, !0), r = s.next().value, r?.[Ti]()) ? r : null) : null;
  }
  _setProperties(e, n) {
    if (e.hasOwnProperty("setProperty"))
      for (const {
        ref: a,
        target: i,
        connection: s
      } of e.setProperty.children) {
        if (s || !a)
          continue;
        const r = Ca(this.root, n, a, !1, !1);
        if (!r) {
          F(`XFA - Invalid reference: ${a}.`);
          continue;
        }
        const [o] = r;
        if (!o[Ta](this.data)) {
          F("XFA - Invalid node: must be a data node.");
          continue;
        }
        const c = Ca(this.root, e, i, !1, !1);
        if (!c) {
          F(`XFA - Invalid target: ${i}.`);
          continue;
        }
        const [l] = c;
        if (!l[Ta](e)) {
          F("XFA - Invalid target: must be a property or subproperty.");
          continue;
        }
        const h = l[Me]();
        if (l instanceof To || h instanceof To) {
          F("XFA - Invalid target: cannot be a setProperty or one of its properties.");
          continue;
        }
        if (l instanceof Co || h instanceof Co) {
          F("XFA - Invalid target: cannot be a bindItems or one of its properties.");
          continue;
        }
        const f = o[Ft](), d = l[qe];
        if (l instanceof tc) {
          const u = /* @__PURE__ */ Object.create(null);
          u[d] = f;
          const x = Reflect.construct(Object.getPrototypeOf(h).constructor, [u]);
          h[d] = x[d];
          continue;
        }
        if (!l.hasOwnProperty(q)) {
          F("XFA - Invalid node to use in setProperty");
          continue;
        }
        l[Mn] = o, l[q] = f, l[st]();
      }
  }
  _bindItems(e, n) {
    if (!e.hasOwnProperty("items") || !e.hasOwnProperty("bindItems") || e.bindItems.isEmpty())
      return;
    for (const s of e.items.children)
      e[Na](s);
    e.items.clear();
    const a = new Io({}), i = new Io({});
    e[gt](a), e.items.push(a), e[gt](i), e.items.push(i);
    for (const {
      ref: s,
      labelRef: r,
      valueRef: o,
      connection: c
    } of e.bindItems.children) {
      if (c || !s)
        continue;
      const l = Ca(this.root, n, s, !1, !1);
      if (!l) {
        F(`XFA - Invalid reference: ${s}.`);
        continue;
      }
      for (const h of l) {
        if (!h[Ta](this.datasets)) {
          F(`XFA - Invalid ref (${s}): must be a datasets child.`);
          continue;
        }
        const f = Ca(this.root, h, r, !0, !1);
        if (!f) {
          F(`XFA - Invalid label: ${r}.`);
          continue;
        }
        const [d] = f;
        if (!d[Ta](this.datasets)) {
          F("XFA - Invalid label: must be a datasets child.");
          continue;
        }
        const u = Ca(this.root, h, o, !0, !1);
        if (!u) {
          F(`XFA - Invalid value: ${o}.`);
          continue;
        }
        const [x] = u;
        if (!x[Ta](this.datasets)) {
          F("XFA - Invalid value: must be a datasets child.");
          continue;
        }
        const g = Ar(d[Ft]()), p = Ar(x[Ft]());
        a[gt](g), a.text.push(g), i[gt](p), i.text.push(p);
      }
    }
  }
  _bindOccurrences(e, n, a) {
    let i;
    if (n.length > 1 && (i = e[jn](), i[Na](i.occur), i.occur = null), this._bindValue(e, n[0], a), this._setProperties(e, n[0]), this._bindItems(e, n[0]), n.length === 1)
      return;
    const s = e[Me](), r = e[qe], o = s[vo](e);
    for (let c = 1, l = n.length; c < l; c++) {
      const h = n[c], f = i[jn]();
      s[r].push(f), s[Mr](o + c, f), this._bindValue(f, h, a), this._setProperties(f, h), this._bindItems(f, h);
    }
  }
  _createOccurrences(e) {
    if (!this.emptyMerge)
      return;
    const {
      occur: n
    } = e;
    if (!n || n.initial <= 1)
      return;
    const a = e[Me](), i = e[qe];
    if (!(a[i] instanceof E))
      return;
    let s;
    e.name ? s = a[i].children.filter((c) => c.name === e.name).length : s = a[i].children.length;
    const r = a[vo](e) + 1, o = n.initial - s;
    if (o) {
      const c = e[jn]();
      c[Na](c.occur), c.occur = null, a[i].push(c), a[Mr](r, c);
      for (let l = 1; l < o; l++) {
        const h = c[jn]();
        a[i].push(h), a[Mr](r + l, h);
      }
    }
  }
  _getOccurInfo(e) {
    const {
      name: n,
      occur: a
    } = e;
    if (!a || !n)
      return [1, 1];
    const i = a.max === -1 ? 1 / 0 : a.max;
    return [a.min, i];
  }
  _setAndBind(e, n) {
    this._setProperties(e, n), this._bindItems(e, n), this._bindElement(e, n);
  }
  _bindElement(e, n) {
    const a = [];
    this._createOccurrences(e);
    for (const i of e[Ut]()) {
      if (i[Mn])
        continue;
      if (this._mergeMode === void 0 && i[qe] === "subform") {
        this._mergeMode = i.mergeMode === "consumeData";
        const f = n[Ut]();
        if (f.length > 0)
          this._bindOccurrences(i, [f[0]], null);
        else if (this.emptyMerge) {
          const d = n[vt] === $l ? -1 : n[vt], u = i[Mn] = new ta(d, i.name || "root");
          n[gt](u), this._bindElement(i, u);
        }
        continue;
      }
      if (!i[di]())
        continue;
      let s = !1, r = null, o = null, c = null;
      if (i.bind) {
        switch (i.bind.match) {
          case "none":
            this._setAndBind(i, n);
            continue;
          case "global":
            s = !0;
            break;
          case "dataRef":
            if (!i.bind.ref) {
              F(`XFA - ref is empty in node ${i[qe]}.`), this._setAndBind(i, n);
              continue;
            }
            o = i.bind.ref;
            break;
        }
        i.bind.picture && (r = i.bind.picture[q]);
      }
      const [l, h] = this._getOccurInfo(i);
      if (o)
        if (c = Ca(this.root, n, o, !0, !1), c === null) {
          if (c = Lx(this.data, n, o), !c)
            continue;
          this._isConsumeData() && (c[Zn] = !0), this._setAndBind(i, c);
          continue;
        } else
          this._isConsumeData() && (c = c.filter((f) => !f[Zn])), c.length > h ? c = c.slice(0, h) : c.length === 0 && (c = null), c && this._isConsumeData() && c.forEach((f) => {
            f[Zn] = !0;
          });
      else {
        if (!i.name) {
          this._setAndBind(i, n);
          continue;
        }
        if (this._isConsumeData()) {
          const f = [];
          for (; f.length < h; ) {
            const d = this._findDataByNameToConsume(i.name, i[$s](), n, s);
            if (!d)
              break;
            d[Zn] = !0, f.push(d);
          }
          c = f.length > 0 ? f : null;
        } else {
          if (c = n[Ss](i.name, !1, this.emptyMerge).next().value, !c) {
            if (l === 0) {
              a.push(i);
              continue;
            }
            const f = n[vt] === $l ? -1 : n[vt];
            c = i[Mn] = new ta(f, i.name), this.emptyMerge && (c[Zn] = !0), n[gt](c), this._setAndBind(i, c);
            continue;
          }
          this.emptyMerge && (c[Zn] = !0), c = [c];
        }
      }
      c ? this._bindOccurrences(i, c, r) : l > 0 ? this._setAndBind(i, n) : a.push(i);
    }
    a.forEach((i) => i[Me]()[Na](i));
  }
}
class kg {
  constructor(e, n) {
    this.data = n, this.dataset = e.datasets || null;
  }
  serialize(e) {
    const n = [[-1, this.data[Ut]()]];
    for (; n.length > 0; ) {
      const i = n.at(-1), [s, r] = i;
      if (s + 1 === r.length) {
        n.pop();
        continue;
      }
      const o = r[++i[0]], c = e.get(o[et]);
      if (c)
        o[pn](c);
      else {
        const h = o[K1]();
        for (const f of h.values()) {
          const d = e.get(f[et]);
          if (d) {
            f[pn](d);
            break;
          }
        }
      }
      const l = o[Ut]();
      l.length > 0 && n.push([-1, l]);
    }
    const a = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset)
      for (const i of this.dataset[Ut]())
        i[qe] !== "data" && i[As](a);
    return this.data[As](a), a.push("</xfa:datasets>"), a.join("");
  }
}
const Q = At.config.id;
class Ag extends z {
  constructor(e) {
    super(Q, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new E();
  }
}
class Cg extends z {
  constructor(e) {
    super(Q, "acrobat7", !0), this.dynamicRender = null;
  }
}
class Ig extends tt {
  constructor(e) {
    super(Q, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class Tg extends tt {
  constructor(e) {
    super(Q, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class Eg extends Rt {
  constructor(e) {
    super(Q, "addSilentPrint");
  }
}
class Fg extends Rt {
  constructor(e) {
    super(Q, "addViewerPreferences");
  }
}
class Rg extends nh {
  constructor(e) {
    super(Q, "adjustData");
  }
}
class Og extends Wn {
  constructor(e) {
    super(Q, "adobeExtensionLevel", 0, (n) => n >= 1 && n <= 8);
  }
}
class Bg extends z {
  constructor(e) {
    super(Q, "agent", !0), this.name = e.name ? e.name.trim() : "", this.common = new E();
  }
}
class Mg extends mt {
  constructor(e) {
    super(Q, "alwaysEmbed");
  }
}
class Pg extends $e {
  constructor(e) {
    super(Q, "amd");
  }
}
class Ng extends z {
  constructor(e) {
    super(Q, "area"), this.level = Be({
      data: e.level,
      defaultValue: 0,
      validate: (n) => n >= 1 && n <= 3
    }), this.name = Y(e.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class Dg extends tt {
  constructor(e) {
    super(Q, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class Lg extends tt {
  constructor(e) {
    super(Q, "autoSave", ["disabled", "enabled"]);
  }
}
class Ug extends $e {
  constructor(e) {
    super(Q, "base");
  }
}
class jg extends z {
  constructor(e) {
    super(Q, "batchOutput"), this.format = Y(e.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class Hg extends mt {
  constructor(e) {
    super(Q, "behaviorOverride");
  }
  [st]() {
    this[q] = new Map(this[q].trim().split(/\s+/).filter((e) => e.includes(":")).map((e) => e.split(":", 2)));
  }
}
class $g extends z {
  constructor(e) {
    super(Q, "cache", !0), this.templateCache = null;
  }
}
class Gg extends Rt {
  constructor(e) {
    super(Q, "change");
  }
}
class zg extends z {
  constructor(e) {
    super(Q, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new E();
  }
}
class _g extends z {
  constructor(e) {
    super(Q, "compress"), this.scope = Y(e.scope, ["imageOnly", "document"]);
  }
}
class Wg extends Rt {
  constructor(e) {
    super(Q, "compressLogicalStructure");
  }
}
class Vg extends nh {
  constructor(e) {
    super(Q, "compressObjectStream");
  }
}
class Xg extends z {
  constructor(e) {
    super(Q, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
  }
}
class qg extends z {
  constructor(e) {
    super(Q, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new E();
  }
}
class Kg extends tt {
  constructor(e) {
    super(Q, "conformance", ["A", "B"]);
  }
}
class Yg extends Rt {
  constructor(e) {
    super(Q, "contentCopy");
  }
}
class Jg extends Wn {
  constructor(e) {
    super(Q, "copies", 1, (n) => n >= 1);
  }
}
class Zg extends $e {
  constructor(e) {
    super(Q, "creator");
  }
}
class Qg extends Wn {
  constructor(e) {
    super(Q, "currentPage", 0, (n) => n >= 0);
  }
}
class ep extends z {
  constructor(e) {
    super(Q, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new E(), this.transform = new E();
  }
}
class tp extends z {
  constructor(e) {
    super(Q, "debug", !0), this.uri = null;
  }
}
class np extends mt {
  constructor(e) {
    super(Q, "defaultTypeface"), this.writingScript = Y(e.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class ap extends tt {
  constructor(e) {
    super(Q, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class ip extends Rt {
  constructor(e) {
    super(Q, "documentAssembly");
  }
}
class sp extends z {
  constructor(e) {
    super(Q, "driver", !0), this.name = e.name ? e.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class rp extends tt {
  constructor(e) {
    super(Q, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class op extends tt {
  constructor(e) {
    super(Q, "dynamicRender", ["forbidden", "required"]);
  }
}
class cp extends Rt {
  constructor(e) {
    super(Q, "embed");
  }
}
class lp extends Rt {
  constructor(e) {
    super(Q, "encrypt");
  }
}
class hp extends z {
  constructor(e) {
    super(Q, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
  }
}
class fp extends tt {
  constructor(e) {
    super(Q, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class up extends $e {
  constructor(e) {
    super(Q, "enforce");
  }
}
class dp extends z {
  constructor(e) {
    super(Q, "equate"), this.force = Be({
      data: e.force,
      defaultValue: 1,
      validate: (n) => n === 0
    }), this.from = e.from || "", this.to = e.to || "";
  }
}
class xp extends z {
  constructor(e) {
    super(Q, "equateRange"), this.from = e.from || "", this.to = e.to || "", this._unicodeRange = e.unicodeRange || "";
  }
  get unicodeRange() {
    const e = [], n = /U\+([0-9a-fA-F]+)/, a = this._unicodeRange;
    for (let i of a.split(",").map((s) => s.trim()).filter((s) => !!s))
      i = i.split("-", 2).map((s) => {
        const r = s.match(n);
        return r ? parseInt(r[1], 16) : 0;
      }), i.length === 1 && i.push(i[0]), e.push(i);
    return ae(this, "unicodeRange", e);
  }
}
class gp extends mt {
  constructor(e) {
    super(Q, "exclude");
  }
  [st]() {
    this[q] = this[q].trim().split(/\s+/).filter((e) => e && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e));
  }
}
class pp extends $e {
  constructor(e) {
    super(Q, "excludeNS");
  }
}
class mp extends tt {
  constructor(e) {
    super(Q, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class bp extends z {
  constructor(e) {
    super(Q, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new E(), this.defaultTypeface = new E(), this.neverEmbed = new E();
  }
}
class yp extends Rt {
  constructor(e) {
    super(Q, "formFieldFilling");
  }
}
class wp extends $e {
  constructor(e) {
    super(Q, "groupParent");
  }
}
class vp extends tt {
  constructor(e) {
    super(Q, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class Sp extends $e {
  constructor(e) {
    super(Q, "includeXDPContent");
  }
}
class kp extends tt {
  constructor(e) {
    super(Q, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class Ap extends Rt {
  constructor(e) {
    super(Q, "incrementalMerge");
  }
}
class Cp extends Rt {
  constructor(e) {
    super(Q, "interactive");
  }
}
class Ip extends tt {
  constructor(e) {
    super(Q, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class Tp extends z {
  constructor(e) {
    super(Q, "labelPrinter", !0), this.name = Y(e.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class Ep extends tt {
  constructor(e) {
    super(Q, "layout", ["paginate", "panel"]);
  }
}
class Fp extends Wn {
  constructor(e) {
    super(Q, "level", 0, (n) => n > 0);
  }
}
class Rp extends Rt {
  constructor(e) {
    super(Q, "linearized");
  }
}
class Op extends $e {
  constructor(e) {
    super(Q, "locale");
  }
}
class Bp extends $e {
  constructor(e) {
    super(Q, "localeSet");
  }
}
class Mp extends z {
  constructor(e) {
    super(Q, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
  }
}
class Pp extends z {
  constructor(e) {
    super(Q, "map", !0), this.equate = new E(), this.equateRange = new E();
  }
}
class Np extends z {
  constructor(e) {
    super(Q, "mediumInfo", !0), this.map = null;
  }
}
class Dp extends z {
  constructor(e) {
    super(Q, "message", !0), this.msgId = null, this.severity = null;
  }
}
class Lp extends z {
  constructor(e) {
    super(Q, "messaging", !0), this.message = new E();
  }
}
class Up extends tt {
  constructor(e) {
    super(Q, "mode", ["append", "overwrite"]);
  }
}
class jp extends Rt {
  constructor(e) {
    super(Q, "modifyAnnots");
  }
}
class Hp extends Wn {
  constructor(e) {
    super(Q, "msgId", 1, (n) => n >= 1);
  }
}
class $p extends $e {
  constructor(e) {
    super(Q, "nameAttr");
  }
}
class Gp extends mt {
  constructor(e) {
    super(Q, "neverEmbed");
  }
}
class zp extends Wn {
  constructor(e) {
    super(Q, "numberOfCopies", null, (n) => n >= 2 && n <= 5);
  }
}
class _p extends z {
  constructor(e) {
    super(Q, "openAction", !0), this.destination = null;
  }
}
class Wp extends z {
  constructor(e) {
    super(Q, "output", !0), this.to = null, this.type = null, this.uri = null;
  }
}
class Vp extends $e {
  constructor(e) {
    super(Q, "outputBin");
  }
}
class Xp extends z {
  constructor(e) {
    super(Q, "outputXSL", !0), this.uri = null;
  }
}
class qp extends tt {
  constructor(e) {
    super(Q, "overprint", ["none", "both", "draw", "field"]);
  }
}
class Kp extends $e {
  constructor(e) {
    super(Q, "packets");
  }
  [st]() {
    this[q] !== "*" && (this[q] = this[q].trim().split(/\s+/).filter((e) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e)));
  }
}
class Yp extends z {
  constructor(e) {
    super(Q, "pageOffset"), this.x = Be({
      data: e.x,
      defaultValue: "useXDCSetting",
      validate: (n) => !0
    }), this.y = Be({
      data: e.y,
      defaultValue: "useXDCSetting",
      validate: (n) => !0
    });
  }
}
class Jp extends $e {
  constructor(e) {
    super(Q, "pageRange");
  }
  [st]() {
    const e = this[q].trim().split(/\s+/).map((a) => parseInt(a, 10)), n = [];
    for (let a = 0, i = e.length; a < i; a += 2)
      n.push(e.slice(a, a + 2));
    this[q] = n;
  }
}
class Zp extends tt {
  constructor(e) {
    super(Q, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class Qp extends tt {
  constructor(e) {
    super(Q, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class e3 extends Wn {
  constructor(e) {
    super(Q, "part", 1, (n) => !1);
  }
}
class t3 extends z {
  constructor(e) {
    super(Q, "pcl", !0), this.name = e.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
  }
}
class n3 extends z {
  constructor(e) {
    super(Q, "pdf", !0), this.name = e.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
  }
}
class a3 extends z {
  constructor(e) {
    super(Q, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
  }
}
class i3 extends z {
  constructor(e) {
    super(Q, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
  }
}
class s3 extends Rt {
  constructor(e) {
    super(Q, "pickTrayByPDFSize");
  }
}
class r3 extends $e {
  constructor(e) {
    super(Q, "picture");
  }
}
class o3 extends Rt {
  constructor(e) {
    super(Q, "plaintextMetadata");
  }
}
class c3 extends tt {
  constructor(e) {
    super(Q, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class l3 extends z {
  constructor(e) {
    super(Q, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new E(), this.labelPrinter = new E(), this.pcl = new E(), this.pdf = new E(), this.ps = new E(), this.submitUrl = new E(), this.webClient = new E(), this.zpl = new E();
  }
}
class h3 extends Rt {
  constructor(e) {
    super(Q, "print");
  }
}
class f3 extends Rt {
  constructor(e) {
    super(Q, "printHighQuality");
  }
}
class u3 extends tt {
  constructor(e) {
    super(Q, "printScaling", ["appdefault", "noScaling"]);
  }
}
class d3 extends $e {
  constructor(e) {
    super(Q, "printerName");
  }
}
class x3 extends $e {
  constructor(e) {
    super(Q, "producer");
  }
}
class g3 extends z {
  constructor(e) {
    super(Q, "ps", !0), this.name = e.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
  }
}
class p3 extends mt {
  constructor(e) {
    super(Q, "range");
  }
  [st]() {
    this[q] = this[q].split(",", 2).map((e) => e.split("-").map((n) => parseInt(n.trim(), 10))).filter((e) => e.every((n) => !isNaN(n))).map((e) => (e.length === 1 && e.push(e[0]), e));
  }
}
class m3 extends mt {
  constructor(e) {
    super(Q, "record");
  }
  [st]() {
    this[q] = this[q].trim();
    const e = parseInt(this[q], 10);
    !isNaN(e) && e >= 0 && (this[q] = e);
  }
}
class b3 extends mt {
  constructor(e) {
    super(Q, "relevant");
  }
  [st]() {
    this[q] = this[q].trim().split(/\s+/);
  }
}
class y3 extends mt {
  constructor(e) {
    super(Q, "rename");
  }
  [st]() {
    this[q] = this[q].trim(), (this[q].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[q])) && F("XFA - Rename: invalid XFA name");
  }
}
class w3 extends tt {
  constructor(e) {
    super(Q, "renderPolicy", ["server", "client"]);
  }
}
class v3 extends tt {
  constructor(e) {
    super(Q, "runScripts", ["both", "client", "none", "server"]);
  }
}
class S3 extends z {
  constructor(e) {
    super(Q, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
  }
}
class k3 extends tt {
  constructor(e) {
    super(Q, "scriptModel", ["XFA", "none"]);
  }
}
class A3 extends tt {
  constructor(e) {
    super(Q, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class C3 extends z {
  constructor(e) {
    super(Q, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
  }
}
class I3 extends z {
  constructor(e) {
    super(Q, "staple"), this.mode = Y(e.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class T3 extends $e {
  constructor(e) {
    super(Q, "startNode");
  }
}
class E3 extends Wn {
  constructor(e) {
    super(Q, "startPage", 0, (n) => !0);
  }
}
class F3 extends tt {
  constructor(e) {
    super(Q, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class R3 extends $e {
  constructor(e) {
    super(Q, "submitUrl");
  }
}
class O3 extends Wn {
  constructor(e) {
    super(Q, "subsetBelow", 100, (n) => n >= 0 && n <= 100);
  }
}
class B3 extends Rt {
  constructor(e) {
    super(Q, "suppressBanner");
  }
}
class M3 extends Rt {
  constructor(e) {
    super(Q, "tagged");
  }
}
class P3 extends z {
  constructor(e) {
    super(Q, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
  }
}
class N3 extends tt {
  constructor(e) {
    super(Q, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class D3 extends tt {
  constructor(e) {
    super(Q, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class L3 extends z {
  constructor(e) {
    super(Q, "templateCache"), this.maxEntries = Be({
      data: e.maxEntries,
      defaultValue: 5,
      validate: (n) => n >= 0
    });
  }
}
class U3 extends z {
  constructor(e) {
    super(Q, "trace", !0), this.area = new E();
  }
}
class j3 extends z {
  constructor(e) {
    super(Q, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
  }
}
class H3 extends tt {
  constructor(e) {
    super(Q, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class $3 extends $e {
  constructor(e) {
    super(Q, "uri");
  }
}
class G3 extends tt {
  constructor(e) {
    super(Q, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class z3 extends mt {
  constructor(e) {
    super(Q, "validateApprovalSignatures");
  }
  [st]() {
    this[q] = this[q].trim().split(/\s+/).filter((e) => ["docReady", "postSign"].includes(e));
  }
}
class _3 extends tt {
  constructor(e) {
    super(Q, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class W3 extends tt {
  constructor(e) {
    super(Q, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class V3 extends z {
  constructor(e) {
    super(Q, "VersionControl"), this.outputBelow = Y(e.outputBelow, ["warn", "error", "update"]), this.sourceAbove = Y(e.sourceAbove, ["warn", "error"]), this.sourceBelow = Y(e.sourceBelow, ["update", "maintain"]);
  }
}
class X3 extends z {
  constructor(e) {
    super(Q, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
  }
}
class q3 extends z {
  constructor(e) {
    super(Q, "webClient", !0), this.name = e.name ? e.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class K3 extends tt {
  constructor(e) {
    super(Q, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class Y3 extends mt {
  constructor(e) {
    super(Q, "window");
  }
  [st]() {
    const e = this[q].split(",", 2).map((n) => parseInt(n.trim(), 10));
    if (e.some((n) => isNaN(n))) {
      this[q] = [0, 0];
      return;
    }
    e.length === 1 && e.push(e[0]), this[q] = e;
  }
}
class J3 extends z {
  constructor(e) {
    super(Q, "xdc", !0), this.uri = new E(), this.xsl = new E();
  }
}
class Z3 extends z {
  constructor(e) {
    super(Q, "xdp", !0), this.packets = null;
  }
}
class Q3 extends z {
  constructor(e) {
    super(Q, "xsl", !0), this.debug = null, this.uri = null;
  }
}
class em extends z {
  constructor(e) {
    super(Q, "zpl", !0), this.name = e.name ? e.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class qr {
  static [zn](e, n) {
    if (qr.hasOwnProperty(e))
      return qr[e](n);
  }
  static acrobat(e) {
    return new Ag(e);
  }
  static acrobat7(e) {
    return new Cg(e);
  }
  static ADBE_JSConsole(e) {
    return new Ig(e);
  }
  static ADBE_JSDebugger(e) {
    return new Tg(e);
  }
  static addSilentPrint(e) {
    return new Eg(e);
  }
  static addViewerPreferences(e) {
    return new Fg(e);
  }
  static adjustData(e) {
    return new Rg(e);
  }
  static adobeExtensionLevel(e) {
    return new Og(e);
  }
  static agent(e) {
    return new Bg(e);
  }
  static alwaysEmbed(e) {
    return new Mg(e);
  }
  static amd(e) {
    return new Pg(e);
  }
  static area(e) {
    return new Ng(e);
  }
  static attributes(e) {
    return new Dg(e);
  }
  static autoSave(e) {
    return new Lg(e);
  }
  static base(e) {
    return new Ug(e);
  }
  static batchOutput(e) {
    return new jg(e);
  }
  static behaviorOverride(e) {
    return new Hg(e);
  }
  static cache(e) {
    return new $g(e);
  }
  static change(e) {
    return new Gg(e);
  }
  static common(e) {
    return new zg(e);
  }
  static compress(e) {
    return new _g(e);
  }
  static compressLogicalStructure(e) {
    return new Wg(e);
  }
  static compressObjectStream(e) {
    return new Vg(e);
  }
  static compression(e) {
    return new Xg(e);
  }
  static config(e) {
    return new qg(e);
  }
  static conformance(e) {
    return new Kg(e);
  }
  static contentCopy(e) {
    return new Yg(e);
  }
  static copies(e) {
    return new Jg(e);
  }
  static creator(e) {
    return new Zg(e);
  }
  static currentPage(e) {
    return new Qg(e);
  }
  static data(e) {
    return new ep(e);
  }
  static debug(e) {
    return new tp(e);
  }
  static defaultTypeface(e) {
    return new np(e);
  }
  static destination(e) {
    return new ap(e);
  }
  static documentAssembly(e) {
    return new ip(e);
  }
  static driver(e) {
    return new sp(e);
  }
  static duplexOption(e) {
    return new rp(e);
  }
  static dynamicRender(e) {
    return new op(e);
  }
  static embed(e) {
    return new cp(e);
  }
  static encrypt(e) {
    return new lp(e);
  }
  static encryption(e) {
    return new hp(e);
  }
  static encryptionLevel(e) {
    return new fp(e);
  }
  static enforce(e) {
    return new up(e);
  }
  static equate(e) {
    return new dp(e);
  }
  static equateRange(e) {
    return new xp(e);
  }
  static exclude(e) {
    return new gp(e);
  }
  static excludeNS(e) {
    return new pp(e);
  }
  static flipLabel(e) {
    return new mp(e);
  }
  static fontInfo(e) {
    return new bp(e);
  }
  static formFieldFilling(e) {
    return new yp(e);
  }
  static groupParent(e) {
    return new wp(e);
  }
  static ifEmpty(e) {
    return new vp(e);
  }
  static includeXDPContent(e) {
    return new Sp(e);
  }
  static incrementalLoad(e) {
    return new kp(e);
  }
  static incrementalMerge(e) {
    return new Ap(e);
  }
  static interactive(e) {
    return new Cp(e);
  }
  static jog(e) {
    return new Ip(e);
  }
  static labelPrinter(e) {
    return new Tp(e);
  }
  static layout(e) {
    return new Ep(e);
  }
  static level(e) {
    return new Fp(e);
  }
  static linearized(e) {
    return new Rp(e);
  }
  static locale(e) {
    return new Op(e);
  }
  static localeSet(e) {
    return new Bp(e);
  }
  static log(e) {
    return new Mp(e);
  }
  static map(e) {
    return new Pp(e);
  }
  static mediumInfo(e) {
    return new Np(e);
  }
  static message(e) {
    return new Dp(e);
  }
  static messaging(e) {
    return new Lp(e);
  }
  static mode(e) {
    return new Up(e);
  }
  static modifyAnnots(e) {
    return new jp(e);
  }
  static msgId(e) {
    return new Hp(e);
  }
  static nameAttr(e) {
    return new $p(e);
  }
  static neverEmbed(e) {
    return new Gp(e);
  }
  static numberOfCopies(e) {
    return new zp(e);
  }
  static openAction(e) {
    return new _p(e);
  }
  static output(e) {
    return new Wp(e);
  }
  static outputBin(e) {
    return new Vp(e);
  }
  static outputXSL(e) {
    return new Xp(e);
  }
  static overprint(e) {
    return new qp(e);
  }
  static packets(e) {
    return new Kp(e);
  }
  static pageOffset(e) {
    return new Yp(e);
  }
  static pageRange(e) {
    return new Jp(e);
  }
  static pagination(e) {
    return new Zp(e);
  }
  static paginationOverride(e) {
    return new Qp(e);
  }
  static part(e) {
    return new e3(e);
  }
  static pcl(e) {
    return new t3(e);
  }
  static pdf(e) {
    return new n3(e);
  }
  static pdfa(e) {
    return new a3(e);
  }
  static permissions(e) {
    return new i3(e);
  }
  static pickTrayByPDFSize(e) {
    return new s3(e);
  }
  static picture(e) {
    return new r3(e);
  }
  static plaintextMetadata(e) {
    return new o3(e);
  }
  static presence(e) {
    return new c3(e);
  }
  static present(e) {
    return new l3(e);
  }
  static print(e) {
    return new h3(e);
  }
  static printHighQuality(e) {
    return new f3(e);
  }
  static printScaling(e) {
    return new u3(e);
  }
  static printerName(e) {
    return new d3(e);
  }
  static producer(e) {
    return new x3(e);
  }
  static ps(e) {
    return new g3(e);
  }
  static range(e) {
    return new p3(e);
  }
  static record(e) {
    return new m3(e);
  }
  static relevant(e) {
    return new b3(e);
  }
  static rename(e) {
    return new y3(e);
  }
  static renderPolicy(e) {
    return new w3(e);
  }
  static runScripts(e) {
    return new v3(e);
  }
  static script(e) {
    return new S3(e);
  }
  static scriptModel(e) {
    return new k3(e);
  }
  static severity(e) {
    return new A3(e);
  }
  static silentPrint(e) {
    return new C3(e);
  }
  static staple(e) {
    return new I3(e);
  }
  static startNode(e) {
    return new T3(e);
  }
  static startPage(e) {
    return new E3(e);
  }
  static submitFormat(e) {
    return new F3(e);
  }
  static submitUrl(e) {
    return new R3(e);
  }
  static subsetBelow(e) {
    return new O3(e);
  }
  static suppressBanner(e) {
    return new B3(e);
  }
  static tagged(e) {
    return new M3(e);
  }
  static template(e) {
    return new P3(e);
  }
  static templateCache(e) {
    return new L3(e);
  }
  static threshold(e) {
    return new N3(e);
  }
  static to(e) {
    return new D3(e);
  }
  static trace(e) {
    return new U3(e);
  }
  static transform(e) {
    return new j3(e);
  }
  static type(e) {
    return new H3(e);
  }
  static uri(e) {
    return new $3(e);
  }
  static validate(e) {
    return new G3(e);
  }
  static validateApprovalSignatures(e) {
    return new z3(e);
  }
  static validationMessaging(e) {
    return new _3(e);
  }
  static version(e) {
    return new W3(e);
  }
  static versionControl(e) {
    return new V3(e);
  }
  static viewerPreferences(e) {
    return new X3(e);
  }
  static webClient(e) {
    return new q3(e);
  }
  static whitespace(e) {
    return new K3(e);
  }
  static window(e) {
    return new Y3(e);
  }
  static xdc(e) {
    return new J3(e);
  }
  static xdp(e) {
    return new Z3(e);
  }
  static xsl(e) {
    return new Q3(e);
  }
  static zpl(e) {
    return new em(e);
  }
}
const Nn = At.connectionSet.id;
class tm extends z {
  constructor(e) {
    super(Nn, "connectionSet", !0), this.wsdlConnection = new E(), this.xmlConnection = new E(), this.xsdConnection = new E();
  }
}
class nm extends z {
  constructor(e) {
    super(Nn, "effectiveInputPolicy"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class am extends z {
  constructor(e) {
    super(Nn, "effectiveOutputPolicy"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class im extends $e {
  constructor(e) {
    super(Nn, "operation"), this.id = e.id || "", this.input = e.input || "", this.name = e.name || "", this.output = e.output || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class sm extends $e {
  constructor(e) {
    super(Nn, "rootElement"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class rm extends $e {
  constructor(e) {
    super(Nn, "soapAction"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class om extends $e {
  constructor(e) {
    super(Nn, "soapAddress"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class cm extends $e {
  constructor(e) {
    super(Nn, "uri"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class lm extends $e {
  constructor(e) {
    super(Nn, "wsdlAddress"), this.id = e.id || "", this.name = e.name || "", this.use = e.use || "", this.usehref = e.usehref || "";
  }
}
class hm extends z {
  constructor(e) {
    super(Nn, "wsdlConnection", !0), this.dataDescription = e.dataDescription || "", this.name = e.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
  }
}
class fm extends z {
  constructor(e) {
    super(Nn, "xmlConnection", !0), this.dataDescription = e.dataDescription || "", this.name = e.name || "", this.uri = null;
  }
}
class um extends z {
  constructor(e) {
    super(Nn, "xsdConnection", !0), this.dataDescription = e.dataDescription || "", this.name = e.name || "", this.rootElement = null, this.uri = null;
  }
}
class Kr {
  static [zn](e, n) {
    if (Kr.hasOwnProperty(e))
      return Kr[e](n);
  }
  static connectionSet(e) {
    return new tm(e);
  }
  static effectiveInputPolicy(e) {
    return new nm(e);
  }
  static effectiveOutputPolicy(e) {
    return new am(e);
  }
  static operation(e) {
    return new im(e);
  }
  static rootElement(e) {
    return new sm(e);
  }
  static soapAction(e) {
    return new rm(e);
  }
  static soapAddress(e) {
    return new om(e);
  }
  static uri(e) {
    return new cm(e);
  }
  static wsdlAddress(e) {
    return new lm(e);
  }
  static wsdlConnection(e) {
    return new hm(e);
  }
  static xmlConnection(e) {
    return new fm(e);
  }
  static xsdConnection(e) {
    return new um(e);
  }
}
const Eo = At.datasets.id;
class dm extends ta {
  constructor(e) {
    super(Eo, "data", e);
  }
  [ks]() {
    return !0;
  }
}
class xm extends z {
  constructor(e) {
    super(Eo, "datasets", !0), this.data = null, this.Signature = null;
  }
  [ea](e) {
    const n = e[qe];
    (n === "data" && e[vt] === Eo || n === "Signature" && e[vt] === At.signature.id) && (this[n] = e), this[gt](e);
  }
}
class Yr {
  static [zn](e, n) {
    if (Yr.hasOwnProperty(e))
      return Yr[e](n);
  }
  static datasets(e) {
    return new xm(e);
  }
  static data(e) {
    return new dm(e);
  }
}
const bt = At.localeSet.id;
class gm extends z {
  constructor(e) {
    super(bt, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new E(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new E(2);
  }
}
class pm extends $e {
  constructor(e) {
    super(bt, "currencySymbol"), this.name = Y(e.name, ["symbol", "isoname", "decimal"]);
  }
}
class mm extends z {
  constructor(e) {
    super(bt, "currencySymbols", !0), this.currencySymbol = new E(3);
  }
}
class bm extends $e {
  constructor(e) {
    super(bt, "datePattern"), this.name = Y(e.name, ["full", "long", "med", "short"]);
  }
}
class ym extends z {
  constructor(e) {
    super(bt, "datePatterns", !0), this.datePattern = new E(4);
  }
}
class wm extends mt {
  constructor(e) {
    super(bt, "dateTimeSymbols");
  }
}
class vm extends $e {
  constructor(e) {
    super(bt, "day");
  }
}
class Sm extends z {
  constructor(e) {
    super(bt, "dayNames", !0), this.abbr = Be({
      data: e.abbr,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.day = new E(7);
  }
}
class km extends $e {
  constructor(e) {
    super(bt, "era");
  }
}
class Am extends z {
  constructor(e) {
    super(bt, "eraNames", !0), this.era = new E(2);
  }
}
class Cm extends z {
  constructor(e) {
    super(bt, "locale", !0), this.desc = e.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
  }
}
class Im extends z {
  constructor(e) {
    super(bt, "localeSet", !0), this.locale = new E();
  }
}
class Tm extends $e {
  constructor(e) {
    super(bt, "meridiem");
  }
}
class Em extends z {
  constructor(e) {
    super(bt, "meridiemNames", !0), this.meridiem = new E(2);
  }
}
class Fm extends $e {
  constructor(e) {
    super(bt, "month");
  }
}
class Rm extends z {
  constructor(e) {
    super(bt, "monthNames", !0), this.abbr = Be({
      data: e.abbr,
      defaultValue: 0,
      validate: (n) => n === 1
    }), this.month = new E(12);
  }
}
class Om extends $e {
  constructor(e) {
    super(bt, "numberPattern"), this.name = Y(e.name, ["full", "long", "med", "short"]);
  }
}
class Bm extends z {
  constructor(e) {
    super(bt, "numberPatterns", !0), this.numberPattern = new E(4);
  }
}
class Mm extends $e {
  constructor(e) {
    super(bt, "numberSymbol"), this.name = Y(e.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class Pm extends z {
  constructor(e) {
    super(bt, "numberSymbols", !0), this.numberSymbol = new E(5);
  }
}
class Nm extends $e {
  constructor(e) {
    super(bt, "timePattern"), this.name = Y(e.name, ["full", "long", "med", "short"]);
  }
}
class Dm extends z {
  constructor(e) {
    super(bt, "timePatterns", !0), this.timePattern = new E(4);
  }
}
class Lm extends z {
  constructor(e) {
    super(bt, "typeFace", !0), this.name = e.name | "";
  }
}
class Um extends z {
  constructor(e) {
    super(bt, "typeFaces", !0), this.typeFace = new E();
  }
}
class Jr {
  static [zn](e, n) {
    if (Jr.hasOwnProperty(e))
      return Jr[e](n);
  }
  static calendarSymbols(e) {
    return new gm(e);
  }
  static currencySymbol(e) {
    return new pm(e);
  }
  static currencySymbols(e) {
    return new mm(e);
  }
  static datePattern(e) {
    return new bm(e);
  }
  static datePatterns(e) {
    return new ym(e);
  }
  static dateTimeSymbols(e) {
    return new wm(e);
  }
  static day(e) {
    return new vm(e);
  }
  static dayNames(e) {
    return new Sm(e);
  }
  static era(e) {
    return new km(e);
  }
  static eraNames(e) {
    return new Am(e);
  }
  static locale(e) {
    return new Cm(e);
  }
  static localeSet(e) {
    return new Im(e);
  }
  static meridiem(e) {
    return new Tm(e);
  }
  static meridiemNames(e) {
    return new Em(e);
  }
  static month(e) {
    return new Fm(e);
  }
  static monthNames(e) {
    return new Rm(e);
  }
  static numberPattern(e) {
    return new Om(e);
  }
  static numberPatterns(e) {
    return new Bm(e);
  }
  static numberSymbol(e) {
    return new Mm(e);
  }
  static numberSymbols(e) {
    return new Pm(e);
  }
  static timePattern(e) {
    return new Nm(e);
  }
  static timePatterns(e) {
    return new Dm(e);
  }
  static typeFace(e) {
    return new Lm(e);
  }
  static typeFaces(e) {
    return new Um(e);
  }
}
const jm = At.signature.id;
class Hm extends z {
  constructor(e) {
    super(jm, "signature", !0);
  }
}
class Zr {
  static [zn](e, n) {
    if (Zr.hasOwnProperty(e))
      return Zr[e](n);
  }
  static signature(e) {
    return new Hm(e);
  }
}
const $m = At.stylesheet.id;
class Gm extends z {
  constructor(e) {
    super($m, "stylesheet", !0);
  }
}
class Qr {
  static [zn](e, n) {
    if (Qr.hasOwnProperty(e))
      return Qr[e](n);
  }
  static stylesheet(e) {
    return new Gm(e);
  }
}
const zm = At.xdp.id;
class _m extends z {
  constructor(e) {
    super(zm, "xdp", !0), this.uuid = e.uuid || "", this.timeStamp = e.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new E(), this.template = null;
  }
  [So](e) {
    const n = At[e[qe]];
    return n && e[vt] === n.id;
  }
}
class e0 {
  static [zn](e, n) {
    if (e0.hasOwnProperty(e))
      return e0[e](n);
  }
  static xdp(e) {
    return new _m(e);
  }
}
const Wm = At.xhtml.id, Cr = Symbol(), Vm = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), Xm = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (t) => t === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (t) => `scaleX(${Math.max(0, parseInt(t) / 100).toFixed(2)})`], ["xfa-font-vertical-scale", (t) => `scaleY(${Math.max(0, parseInt(t) / 100).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (t, e) => (t = e.fontSize = Math.abs(pe(t)), Oe(0.99 * t))], ["letter-spacing", (t) => Oe(pe(t))], ["line-height", (t) => Oe(pe(t))], ["margin", (t) => Oe(pe(t))], ["margin-bottom", (t) => Oe(pe(t))], ["margin-left", (t) => Oe(pe(t))], ["margin-right", (t) => Oe(pe(t))], ["margin-top", (t) => Oe(pe(t))], ["text-indent", (t) => Oe(pe(t))], ["font-family", (t) => t], ["vertical-align", (t) => Oe(pe(t))]]), qm = /\s+/g, Km = /[\r\n]+/g, Ym = /\r\n?/g;
function Jm(t, e, n) {
  const a = /* @__PURE__ */ Object.create(null);
  if (!t)
    return a;
  const i = /* @__PURE__ */ Object.create(null);
  for (const [s, r] of t.split(";").map((o) => o.split(":", 2))) {
    const o = Xm.get(s);
    if (o === "")
      continue;
    let c = r;
    o && (c = typeof o == "string" ? o : o(r, i)), s.endsWith("scale") ? a.transform = a.transform ? `${a[s]} ${c}` : c : a[s.replaceAll(/-([a-zA-Z])/g, (l, h) => h.toUpperCase())] = c;
  }
  if (a.fontFamily && lh({
    typeface: a.fontFamily,
    weight: a.fontWeight || "normal",
    posture: a.fontStyle || "normal",
    size: i.fontSize || 0
  }, e, e[it].fontFinder, a), n && a.verticalAlign && a.verticalAlign !== "0px" && a.fontSize) {
    const o = pe(a.fontSize);
    a.fontSize = Oe(o * 0.583), a.verticalAlign = Oe(Math.sign(pe(a.verticalAlign)) * o * 0.333);
  }
  return n && a.fontSize && (a.fontSize = `calc(${a.fontSize} * var(--total-scale-factor))`), rh(a), a;
}
function Zm(t) {
  return t.style ? t.style.split(";").filter((e) => !!e.trim()).map((e) => e.split(":", 2).map((n) => n.trim())).filter(([e, n]) => (e === "font-family" && t[it].usedTypefaces.add(n), Vm.has(e))).map((e) => e.join(":")).join(";") : "";
}
const Qm = /* @__PURE__ */ new Set(["body", "html"]);
class Cn extends ta {
  constructor(e, n) {
    super(Wm, n), this[Cr] = !1, this.style = e.style || "";
  }
  [Pn](e) {
    super[Pn](e), this.style = Zm(this);
  }
  [c0]() {
    return !Qm.has(this[qe]);
  }
  [pa](e, n = !1) {
    n ? this[Cr] = !0 : (e = e.replaceAll(Km, ""), this.style.includes("xfa-spacerun:yes") || (e = e.replaceAll(qm, " "))), e && (this[q] += e);
  }
  [ia](e, n = !0) {
    const a = /* @__PURE__ */ Object.create(null), i = {
      top: NaN,
      bottom: NaN,
      left: NaN,
      right: NaN
    };
    let s = null;
    for (const [r, o] of this.style.split(";").map((c) => c.split(":", 2)))
      switch (r) {
        case "font-family":
          a.typeface = h0(o);
          break;
        case "font-size":
          a.size = pe(o);
          break;
        case "font-weight":
          a.weight = o;
          break;
        case "font-style":
          a.posture = o;
          break;
        case "letter-spacing":
          a.letterSpacing = pe(o);
          break;
        case "margin":
          const c = o.split(/ \t/).map((l) => pe(l));
          switch (c.length) {
            case 1:
              i.top = i.bottom = i.left = i.right = c[0];
              break;
            case 2:
              i.top = i.bottom = c[0], i.left = i.right = c[1];
              break;
            case 3:
              i.top = c[0], i.bottom = c[2], i.left = i.right = c[1];
              break;
            case 4:
              i.top = c[0], i.left = c[1], i.bottom = c[2], i.right = c[3];
              break;
          }
          break;
        case "margin-top":
          i.top = pe(o);
          break;
        case "margin-bottom":
          i.bottom = pe(o);
          break;
        case "margin-left":
          i.left = pe(o);
          break;
        case "margin-right":
          i.right = pe(o);
          break;
        case "line-height":
          s = pe(o);
          break;
      }
    if (e.pushData(a, i, s), this[q])
      e.addString(this[q]);
    else
      for (const r of this[Ut]()) {
        if (r[qe] === "#text") {
          e.addString(r[q]);
          continue;
        }
        r[ia](e);
      }
    n && e.popFont();
  }
  [Ie](e) {
    const n = [];
    if (this[$] = {
      children: n
    }, this[Ua]({}), n.length === 0 && !this[q])
      return Se.EMPTY;
    let a;
    return this[Cr] ? a = this[q] ? this[q].replaceAll(Ym, `
`) : void 0 : a = this[q] || void 0, Se.success({
      name: this[qe],
      attributes: {
        href: this.href,
        style: Jm(this.style, this, this[Cr])
      },
      children: n,
      value: a
    });
  }
}
class e5 extends Cn {
  constructor(e) {
    super(e, "a"), this.href = hh(e.href) || "";
  }
}
class t5 extends Cn {
  constructor(e) {
    super(e, "b");
  }
  [ia](e) {
    e.pushFont({
      weight: "bold"
    }), super[ia](e), e.popFont();
  }
}
class n5 extends Cn {
  constructor(e) {
    super(e, "body");
  }
  [Ie](e) {
    const n = super[Ie](e), {
      html: a
    } = n;
    return a ? (a.name = "div", a.attributes.class = ["xfaRich"], n) : Se.EMPTY;
  }
}
class a5 extends Cn {
  constructor(e) {
    super(e, "br");
  }
  [Ft]() {
    return `
`;
  }
  [ia](e) {
    e.addString(`
`);
  }
  [Ie](e) {
    return Se.success({
      name: "br"
    });
  }
}
class i5 extends Cn {
  constructor(e) {
    super(e, "html");
  }
  [Ie](e) {
    const n = [];
    if (this[$] = {
      children: n
    }, this[Ua]({}), n.length === 0)
      return Se.success({
        name: "div",
        attributes: {
          class: ["xfaRich"],
          style: {}
        },
        value: this[q] || ""
      });
    if (n.length === 1) {
      const a = n[0];
      if (a.attributes?.class.includes("xfaRich"))
        return Se.success(a);
    }
    return Se.success({
      name: "div",
      attributes: {
        class: ["xfaRich"],
        style: {}
      },
      children: n
    });
  }
}
class s5 extends Cn {
  constructor(e) {
    super(e, "i");
  }
  [ia](e) {
    e.pushFont({
      posture: "italic"
    }), super[ia](e), e.popFont();
  }
}
class r5 extends Cn {
  constructor(e) {
    super(e, "li");
  }
}
class o5 extends Cn {
  constructor(e) {
    super(e, "ol");
  }
}
class c5 extends Cn {
  constructor(e) {
    super(e, "p");
  }
  [ia](e) {
    super[ia](e, !1), e.addString(`
`), e.addPara(), e.popFont();
  }
  [Ft]() {
    return this[Me]()[Ut]().at(-1) === this ? super[Ft]() : super[Ft]() + `
`;
  }
}
class l5 extends Cn {
  constructor(e) {
    super(e, "span");
  }
}
class h5 extends Cn {
  constructor(e) {
    super(e, "sub");
  }
}
class f5 extends Cn {
  constructor(e) {
    super(e, "sup");
  }
}
class u5 extends Cn {
  constructor(e) {
    super(e, "ul");
  }
}
class _i {
  static [zn](e, n) {
    if (_i.hasOwnProperty(e))
      return _i[e](n);
  }
  static a(e) {
    return new e5(e);
  }
  static b(e) {
    return new t5(e);
  }
  static body(e) {
    return new n5(e);
  }
  static br(e) {
    return new a5(e);
  }
  static html(e) {
    return new i5(e);
  }
  static i(e) {
    return new s5(e);
  }
  static li(e) {
    return new r5(e);
  }
  static ol(e) {
    return new o5(e);
  }
  static p(e) {
    return new c5(e);
  }
  static span(e) {
    return new l5(e);
  }
  static sub(e) {
    return new h5(e);
  }
  static sup(e) {
    return new f5(e);
  }
  static ul(e) {
    return new u5(e);
  }
}
const Gl = {
  config: qr,
  connection: Kr,
  datasets: Yr,
  localeSet: Jr,
  signature: Zr,
  stylesheet: Qr,
  template: Xr,
  xdp: e0,
  xhtml: _i
};
class zl {
  constructor(e) {
    this.namespaceId = e;
  }
  [zn](e, n) {
    return new ta(this.namespaceId, e, n);
  }
}
class d5 extends z {
  constructor(e) {
    super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[Ai] = e;
  }
  [ea](e) {
    return this.element = e, !0;
  }
  [st]() {
    super[st](), this.element.template instanceof hc && (this[Ai].set(Y1, this.element), this.element.template[gs](this[Ai]), this.element.template[Ai] = this[Ai]);
  }
}
class x5 extends z {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [ea](e) {
    return !1;
  }
}
class g5 {
  constructor(e = null) {
    this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(At).map(({
      id: n
    }) => n)), this._currentNamespace = e || new zl(++this._nextNsId);
  }
  buildRoot(e) {
    return new d5(e);
  }
  build({
    nsPrefix: e,
    name: n,
    attributes: a,
    namespace: i,
    prefixes: s
  }) {
    const r = i !== null;
    if (r && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(i)), s && this._addNamespacePrefix(s), a.hasOwnProperty(ei)) {
      const l = Gl.datasets, h = a[ei];
      let f = null;
      for (const [d, u] of Object.entries(h))
        if (this._getNamespaceToUse(d) === l) {
          f = {
            xfa: u
          };
          break;
        }
      f ? a[ei] = f : delete a[ei];
    }
    const c = this._getNamespaceToUse(e)?.[zn](n, a) || new x5();
    return c[ks]() && this._nsAgnosticLevel++, (r || s || c[ks]()) && (c[Br] = {
      hasNamespace: r,
      prefixes: s,
      nsAgnostic: c[ks]()
    }), c;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(e) {
    let n = this._namespaces.get(e);
    if (n)
      return n;
    for (const [a, {
      check: i
    }] of Object.entries(At))
      if (i(e)) {
        if (n = Gl[a], n)
          return this._namespaces.set(e, n), n;
        break;
      }
    return n = new zl(++this._nextNsId), this._namespaces.set(e, n), n;
  }
  _addNamespacePrefix(e) {
    for (const {
      prefix: n,
      value: a
    } of e) {
      const i = this._searchNamespace(a);
      let s = this._namespacePrefixes.get(n);
      s || (s = [], this._namespacePrefixes.set(n, s)), s.push(i);
    }
  }
  _getNamespaceToUse(e) {
    if (!e)
      return this._currentNamespace;
    const n = this._namespacePrefixes.get(e);
    return n?.length > 0 ? n.at(-1) : (F(`Unknown namespace prefix: ${e}.`), null);
  }
  clean(e) {
    const {
      hasNamespace: n,
      prefixes: a,
      nsAgnostic: i
    } = e;
    n && (this._currentNamespace = this._namespaceStack.pop()), a && a.forEach(({
      prefix: s
    }) => {
      this._namespacePrefixes.get(s).pop();
    }), i && this._nsAgnosticLevel--;
  }
}
class t0 extends X1 {
  constructor(e = null, n = !1) {
    super(), this._builder = new g5(e), this._stack = [], this._globalData = {
      usedTypefaces: /* @__PURE__ */ new Set()
    }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = hn.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = n;
  }
  parse(e) {
    if (this.parseXml(e), this._errorCode === hn.NoError)
      return this._current[st](), this._current.element;
  }
  onText(e) {
    if (e = e.replace(this._nbsps, (n) => n.slice(1) + " "), this._richText || this._current[c0]()) {
      this._current[pa](e, this._richText);
      return;
    }
    this._whiteRegex.test(e) || this._current[pa](e.trim());
  }
  onCdata(e) {
    this._current[pa](e);
  }
  _mkAttributes(e, n) {
    let a = null, i = null;
    const s = /* @__PURE__ */ Object.create({});
    for (const {
      name: r,
      value: o
    } of e)
      if (r === "xmlns")
        a ? F(`XFA - multiple namespace definition in <${n}>`) : a = o;
      else if (r.startsWith("xmlns:")) {
        const c = r.substring(6);
        i ??= [], i.push({
          prefix: c,
          value: o
        });
      } else {
        const c = r.indexOf(":");
        if (c === -1)
          s[r] = o;
        else {
          const l = s[ei] ??= /* @__PURE__ */ Object.create(null), [h, f] = [r.slice(0, c), r.slice(c + 1)], d = l[h] ||= /* @__PURE__ */ Object.create(null);
          d[f] = o;
        }
      }
    return [a, i, s];
  }
  _getNameAndPrefix(e, n) {
    const a = e.indexOf(":");
    return a === -1 ? [e, null] : [e.substring(a + 1), n ? "" : e.substring(0, a)];
  }
  onBeginElement(e, n, a) {
    const [i, s, r] = this._mkAttributes(n, e), [o, c] = this._getNameAndPrefix(e, this._builder.isNsAgnostic()), l = this._builder.build({
      nsPrefix: c,
      name: o,
      attributes: r,
      namespace: i,
      prefixes: s
    });
    if (l[it] = this._globalData, a) {
      l[st](), this._current[ea](l) && l[ko](this._ids), l[Pn](this._builder);
      return;
    }
    this._stack.push(this._current), this._current = l;
  }
  onEndElement(e) {
    const n = this._current;
    if (n[Qo]() && typeof n[q] == "string") {
      const a = new t0();
      a._globalData = this._globalData;
      const i = a.parse(n[q]);
      n[q] = null, n[ea](i);
    }
    n[st](), this._current = this._stack.pop(), this._current[ea](n) && n[ko](this._ids), n[Pn](this._builder);
  }
  onError(e) {
    this._errorCode = e;
  }
}
class Js {
  constructor(e) {
    try {
      this.root = new t0().parse(Js._createDocument(e));
      const n = new Sg(this.root);
      this.form = n.bind(), this.dataHandler = new kg(this.root, n.getData()), this.form[it].template = this.form;
    } catch (n) {
      F(`XFA - an error occurred during parsing and binding: ${n}`);
    }
  }
  isValid() {
    return !!(this.root && this.form);
  }
  _createPagesHelper() {
    const e = this.form[Z1]();
    return new Promise((n, a) => {
      const i = () => {
        try {
          const s = e.next();
          s.done ? n(s.value) : setTimeout(i, 0);
        } catch (s) {
          a(s);
        }
      };
      setTimeout(i, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((e) => {
        const {
          width: n,
          height: a
        } = e.attributes.style;
        return [0, 0, parseInt(n), parseInt(a)];
      });
    } catch (e) {
      F(`XFA - an error occurred during layout: ${e}`);
    }
  }
  getBoundingBox(e) {
    return this.dims[e];
  }
  async getNumPages() {
    return this.pages || await this._createPages(), this.dims.length;
  }
  setImages(e) {
    this.form[it].images = e;
  }
  setFonts(e) {
    this.form[it].fontFinder = new Rx(e);
    const n = [];
    for (let a of this.form[it].usedTypefaces)
      a = h0(a), this.form[it].fontFinder.find(a) || n.push(a);
    return n.length > 0 ? n : null;
  }
  appendFonts(e, n) {
    this.form[it].fontFinder.add(e, n);
  }
  async getPages() {
    this.pages || await this._createPages();
    const e = this.pages;
    return this.pages = null, e;
  }
  serializeData(e) {
    return this.dataHandler.serialize(e);
  }
  static _createDocument(e) {
    return e["/xdp:xdp"] ? Object.values(e).join("") : e["xdp:xdp"];
  }
  static getRichTextAsHtml(e) {
    if (!e || typeof e != "string")
      return null;
    try {
      let n = new t0(_i, !0).parse(e);
      if (!["body", "xhtml"].includes(n[qe])) {
        const r = _i.body({});
        r[gt](n), n = r;
      }
      const a = n[Ie]();
      if (!a.success)
        return null;
      const {
        html: i
      } = a, {
        attributes: s
      } = i;
      return s && (s.class && (s.class = s.class.filter((r) => !r.startsWith("xfa"))), s.dir = "auto"), {
        html: i,
        str: n[Ft]()
      };
    } catch (n) {
      F(`XFA - an error occurred during parsing of rich text: ${n}`);
    }
    return null;
  }
}
class la {
  static createGlobals(e) {
    return Promise.all([e.ensureCatalog("acroForm"), e.ensureDoc("xfaDatasets"), e.ensureCatalog("structTreeRoot"), e.ensureCatalog("baseUrl"), e.ensureCatalog("attachments"), e.ensureCatalog("globalColorSpaceCache")]).then(([n, a, i, s, r, o]) => ({
      pdfManager: e,
      acroForm: n instanceof B ? n : B.empty,
      xfaDatasets: a,
      structTreeRoot: i,
      baseUrl: s,
      attachments: r,
      globalColorSpaceCache: o
    }), (n) => (F(`createGlobals: "${n}".`), null));
  }
  static async create(e, n, a, i, s, r, o, c) {
    const l = s ? await this._getPageIndex(e, n, a.pdfManager) : null;
    return a.pdfManager.ensure(this, "_create", [e, n, a, i, s, r, o, l, c]);
  }
  static _create(e, n, a, i, s = !1, r = null, o = null, c = null, l = null) {
    const h = e.fetchIfRef(n);
    if (!(h instanceof B))
      return;
    let f = h.get("Subtype");
    if (f = f instanceof Z ? f.name : null, o && !o.has(Mt[f.toUpperCase()]))
      return null;
    const {
      acroForm: d,
      pdfManager: u
    } = a, x = n instanceof le ? n.toString() : `annot_${i.createObjId()}`, g = {
      xref: e,
      ref: n,
      dict: h,
      subtype: f,
      id: x,
      annotationGlobals: a,
      collectFields: s,
      orphanFields: r,
      needAppearances: !s && d.get("NeedAppearances") === !0,
      pageIndex: c,
      evaluatorOptions: u.evaluatorOptions,
      pageRef: l
    };
    switch (f) {
      case "Link":
        return new v5(g);
      case "Text":
        return new w5(g);
      case "Widget":
        let p = Bn({
          dict: h,
          key: "FT"
        });
        switch (p = p instanceof Z ? p.name : null, p) {
          case "Tx":
            return new m5(g);
          case "Btn":
            return new b5(g);
          case "Ch":
            return new y5(g);
          case "Sig":
            return new Rh(g);
        }
        return F(`Unimplemented widget field type "${p}", falling back to base field type.`), new Gn(g);
      case "Popup":
        return new dc(g);
      case "FreeText":
        return new W0(g);
      case "Line":
        return new S5(g);
      case "Square":
        return new k5(g);
      case "Circle":
        return new A5(g);
      case "PolyLine":
        return new Oh(g);
      case "Polygon":
        return new Bh(g);
      case "Caret":
        return new C5(g);
      case "Ink":
        return new fs(g);
      case "Highlight":
        return new V0(g);
      case "Underline":
        return new I5(g);
      case "Squiggly":
        return new T5(g);
      case "StrikeOut":
        return new E5(g);
      case "Stamp":
        return new Si(g);
      case "FileAttachment":
        return new F5(g);
      default:
        return s || F(f ? `Unimplemented annotation type "${f}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Qs(g);
    }
  }
  static async _getPageIndex(e, n, a) {
    try {
      const i = await e.fetchIfRefAsync(n);
      if (!(i instanceof B))
        return -1;
      const s = i.getRaw("P");
      if (s instanceof le)
        try {
          return await a.ensureCatalog("getPageIndex", [s]);
        } catch (o) {
          Ue(`_getPageIndex -- not a valid page reference: "${o}".`);
        }
      if (i.has("Kids"))
        return -1;
      const r = await a.ensureDoc("numPages");
      for (let o = 0; o < r; o++) {
        const c = await a.getPage(o), l = await a.ensure(c, "annotations");
        for (const h of l)
          if (h instanceof le && Dr(h, n))
            return o;
      }
    } catch (i) {
      F(`_getPageIndex: "${i}".`);
    }
    return -1;
  }
  static generateImages(e, n, a) {
    if (!a)
      return F("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
    let i;
    for (const {
      bitmapId: s,
      bitmap: r
    } of e)
      r && (i ||= /* @__PURE__ */ new Map(), i.set(s, Si.createImage(r, n)));
    return i;
  }
  static async saveNewAnnotations(e, n, a, i, s) {
    const r = e.xref;
    let o;
    const c = [], {
      isOffscreenCanvasSupported: l
    } = e.options;
    for (const h of a)
      if (!h.deleted)
        switch (h.annotationType) {
          case Xn.FREETEXT:
            if (!o) {
              const d = new B(r);
              d.setIfName("BaseFont", "Helvetica"), d.setIfName("Type", "Font"), d.setIfName("Subtype", "Type1"), d.setIfName("Encoding", "WinAnsiEncoding"), o = r.getNewTemporaryRef(), s.put(o, {
                data: d
              });
            }
            c.push(W0.createNewAnnotation(r, h, s, {
              evaluator: e,
              task: n,
              baseFontRef: o
            }));
            break;
          case Xn.HIGHLIGHT:
            h.quadPoints ? c.push(V0.createNewAnnotation(r, h, s)) : c.push(fs.createNewAnnotation(r, h, s));
            break;
          case Xn.INK:
            c.push(fs.createNewAnnotation(r, h, s));
            break;
          case Xn.STAMP:
            const f = l ? await i?.get(h.bitmapId) : null;
            if (f?.imageStream) {
              const {
                imageStream: d,
                smaskStream: u
              } = f;
              if (u) {
                const g = r.getNewTemporaryRef();
                s.put(g, {
                  data: u
                }), d.dict.set("SMask", g);
              }
              const x = f.imageRef = r.getNewTemporaryRef();
              s.put(x, {
                data: d
              }), f.imageStream = f.smaskStream = null;
            }
            c.push(Si.createNewAnnotation(r, h, s, {
              image: f
            }));
            break;
          case Xn.SIGNATURE:
            c.push(Si.createNewAnnotation(r, h, s, {}));
            break;
        }
    return {
      annotations: (await Promise.all(c)).flat()
    };
  }
  static async printNewAnnotations(e, n, a, i, s) {
    if (!i)
      return null;
    const {
      options: r,
      xref: o
    } = n, c = [];
    for (const l of i)
      if (!l.deleted)
        switch (l.annotationType) {
          case Xn.FREETEXT:
            c.push(W0.createNewPrintAnnotation(e, o, l, {
              evaluator: n,
              task: a,
              evaluatorOptions: r
            }));
            break;
          case Xn.HIGHLIGHT:
            l.quadPoints ? c.push(V0.createNewPrintAnnotation(e, o, l, {
              evaluatorOptions: r
            })) : c.push(fs.createNewPrintAnnotation(e, o, l, {
              evaluatorOptions: r
            }));
            break;
          case Xn.INK:
            c.push(fs.createNewPrintAnnotation(e, o, l, {
              evaluatorOptions: r
            }));
            break;
          case Xn.STAMP:
            const h = r.isOffscreenCanvasSupported ? await s?.get(l.bitmapId) : null;
            if (h?.imageStream) {
              const {
                imageStream: f,
                smaskStream: d
              } = h;
              d && f.dict.set("SMask", d), h.imageRef = new Wi(f, f.length), h.imageStream = h.smaskStream = null;
            }
            c.push(Si.createNewPrintAnnotation(e, o, l, {
              image: h,
              evaluatorOptions: r
            }));
            break;
          case Xn.SIGNATURE:
            c.push(Si.createNewPrintAnnotation(e, o, l, {
              evaluatorOptions: r
            }));
            break;
        }
    return Promise.all(c);
  }
}
function oi(t, e = new Uint8ClampedArray(3)) {
  if (!Array.isArray(t))
    return e;
  const n = e || new Uint8ClampedArray(3);
  switch (t.length) {
    case 0:
      return null;
    case 1:
      return Ye.gray.getRgbItem(t, 0, n, 0), n;
    case 3:
      return Ye.rgb.getRgbItem(t, 0, n, 0), n;
    case 4:
      return Ye.cmyk.getRgbItem(t, 0, n, 0), n;
    default:
      return e;
  }
}
function qt(t, e = null) {
  return t && Array.from(t, (n) => n / 255) || e;
}
function Zs(t, e) {
  const n = t.getArray("QuadPoints");
  if (!an(n, null) || n.length === 0 || n.length % 8 > 0)
    return null;
  const a = new Float32Array(n.length);
  for (let i = 0, s = n.length; i < s; i += 8) {
    const [r, o, c, l, h, f, d, u] = n.slice(i, i + 8), x = Math.min(r, c, h, d), g = Math.max(r, c, h, d), p = Math.min(o, l, f, u), m = Math.max(o, l, f, u);
    if (e !== null && (x < e[0] || g > e[2] || p < e[1] || m > e[3]))
      return null;
    a.set([x, m, g, m, x, p, g, p], i);
  }
  return a;
}
function Fo(t, e, n) {
  const a = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
  Je.axialAlignedBoundingBox(e, n, a);
  const [i, s, r, o] = a;
  if (i === r || s === o)
    return [1, 0, 0, 1, t[0], t[1]];
  const c = (t[2] - t[0]) / (r - i), l = (t[3] - t[1]) / (o - s);
  return [c, 0, 0, l, t[0] - i * c, t[1] - s * l];
}
class Qs {
  constructor(e) {
    const {
      dict: n,
      xref: a,
      annotationGlobals: i,
      ref: s,
      orphanFields: r
    } = e, o = r?.get(s);
    o && n.set("Parent", o), this.setTitle(n.get("T")), this.setContents(n.get("Contents")), this.setModificationDate(n.get("M")), this.setFlags(n.get("F")), this.setRectangle(n.getArray("Rect")), this.setColor(n.getArray("C")), this.setBorderStyle(n), this.setAppearance(n), this.setOptionalContent(n);
    const c = n.get("MK");
    this.setBorderAndBackgroundColors(c), this.setRotation(c, n), this.ref = e.ref instanceof le ? e.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
    const l = !!(this.flags & Tt.LOCKED), h = !!(this.flags & Tt.LOCKEDCONTENTS);
    if (this.data = {
      annotationFlags: this.flags,
      borderStyle: this.borderStyle,
      color: this.color,
      backgroundColor: this.backgroundColor,
      borderColor: this.borderColor,
      rotation: this.rotation,
      contentsObj: this._contents,
      hasAppearance: !!this.appearance,
      id: e.id,
      modificationDate: this.modificationDate,
      rect: this.rectangle,
      subtype: e.subtype,
      hasOwnCanvas: !1,
      noRotate: !!(this.flags & Tt.NOROTATE),
      noHTML: l && h,
      isEditable: !1,
      structParent: -1
    }, i.structTreeRoot) {
      let d = n.get("StructParent");
      this.data.structParent = d = Number.isInteger(d) && d >= 0 ? d : -1, i.structTreeRoot.addAnnotationIdToPage(e.pageRef, d);
    }
    if (e.collectFields) {
      const d = n.get("Kids");
      if (Array.isArray(d)) {
        const u = [];
        for (const x of d)
          x instanceof le && u.push(x.toString());
        u.length !== 0 && (this.data.kidIds = u);
      }
      this.data.actions = a0(a, n, t1), this.data.fieldName = this._constructFieldName(n), this.data.pageIndex = e.pageIndex;
    }
    const f = n.get("IT");
    f instanceof Z && (this.data.it = f.name), this._isOffscreenCanvasSupported = e.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
  }
  _hasFlag(e, n) {
    return !!(e & n);
  }
  _buildFlags(e, n) {
    let {
      flags: a
    } = this;
    return e === void 0 ? n === void 0 ? void 0 : n ? a & -5 : a & -3 | Tt.PRINT : e ? (a |= Tt.PRINT, n ? a & -33 | Tt.HIDDEN : a & -3 | Tt.NOVIEW) : (a &= -35, n ? a & -5 : a | Tt.PRINT);
  }
  _isViewable(e) {
    return !this._hasFlag(e, Tt.INVISIBLE) && !this._hasFlag(e, Tt.NOVIEW);
  }
  _isPrintable(e) {
    return this._hasFlag(e, Tt.PRINT) && !this._hasFlag(e, Tt.HIDDEN) && !this._hasFlag(e, Tt.INVISIBLE);
  }
  mustBeViewed(e, n) {
    const a = e?.get(this.data.id)?.noView;
    return a !== void 0 ? !a : this.viewable && !this._hasFlag(this.flags, Tt.HIDDEN);
  }
  mustBePrinted(e) {
    const n = e?.get(this.data.id)?.noPrint;
    return n !== void 0 ? !n : this.printable;
  }
  mustBeViewedWhenEditing(e, n = null) {
    return e ? !this.data.isEditable : !n?.has(this.data.id);
  }
  get viewable() {
    return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
  }
  get printable() {
    return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
  }
  _parseStringHelper(e) {
    const n = typeof e == "string" ? Ve(e) : "", a = n && z1(n).dir === "rtl" ? "rtl" : "ltr";
    return {
      str: n,
      dir: a
    };
  }
  setDefaultAppearance(e) {
    const {
      dict: n,
      annotationGlobals: a
    } = e, i = Bn({
      dict: n,
      key: "DA"
    }) || a.acroForm.get("DA");
    this._defaultAppearance = typeof i == "string" ? i : "", this.data.defaultAppearanceData = Yo(this._defaultAppearance);
  }
  setTitle(e) {
    this._title = this._parseStringHelper(e);
  }
  setContents(e) {
    this._contents = this._parseStringHelper(e);
  }
  setModificationDate(e) {
    this.modificationDate = typeof e == "string" ? e : null;
  }
  setFlags(e) {
    this.flags = Number.isInteger(e) && e > 0 ? e : 0, this.flags & Tt.INVISIBLE && this.constructor.name !== "Annotation" && (this.flags ^= Tt.INVISIBLE);
  }
  hasFlag(e) {
    return this._hasFlag(this.flags, e);
  }
  setRectangle(e) {
    this.rectangle = ma(e, [0, 0, 0, 0]);
  }
  setColor(e) {
    this.color = oi(e);
  }
  setLineEndings(e) {
    if (this.lineEndings = ["None", "None"], Array.isArray(e) && e.length === 2)
      for (let n = 0; n < 2; n++) {
        const a = e[n];
        if (a instanceof Z)
          switch (a.name) {
            case "None":
              continue;
            case "Square":
            case "Circle":
            case "Diamond":
            case "OpenArrow":
            case "ClosedArrow":
            case "Butt":
            case "ROpenArrow":
            case "RClosedArrow":
            case "Slash":
              this.lineEndings[n] = a.name;
              continue;
          }
        F(`Ignoring invalid lineEnding: ${a}`);
      }
  }
  setRotation(e, n) {
    this.rotation = 0;
    let a = e instanceof B ? e.get("R") || 0 : n.get("Rotate") || 0;
    Number.isInteger(a) && a !== 0 && (a %= 360, a < 0 && (a += 360), a % 90 === 0 && (this.rotation = a));
  }
  setBorderAndBackgroundColors(e) {
    e instanceof B ? (this.borderColor = oi(e.getArray("BC"), null), this.backgroundColor = oi(e.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(e) {
    if (this.borderStyle = new p5(), e instanceof B)
      if (e.has("BS")) {
        const n = e.get("BS");
        if (n instanceof B) {
          const a = n.get("Type");
          (!a || dt(a, "Border")) && (this.borderStyle.setWidth(n.get("W"), this.rectangle), this.borderStyle.setStyle(n.get("S")), this.borderStyle.setDashArray(n.getArray("D")));
        }
      } else if (e.has("Border")) {
        const n = e.getArray("Border");
        Array.isArray(n) && n.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(n[0]), this.borderStyle.setVerticalCornerRadius(n[1]), this.borderStyle.setWidth(n[2], this.rectangle), n.length === 4 && this.borderStyle.setDashArray(n[3], !0));
      } else
        this.borderStyle.setWidth(0);
  }
  setAppearance(e) {
    this.appearance = null;
    const n = e.get("AP");
    if (!(n instanceof B))
      return;
    const a = n.get("N");
    if (a instanceof Ne) {
      this.appearance = a;
      return;
    }
    if (!(a instanceof B))
      return;
    const i = e.get("AS");
    if (!(i instanceof Z) || !a.has(i.name))
      return;
    const s = a.get(i.name);
    s instanceof Ne && (this.appearance = s);
  }
  setOptionalContent(e) {
    this.oc = null;
    const n = e.get("OC");
    n instanceof Z ? F("setOptionalContent: Support for /Name-entry is not implemented.") : n instanceof B && (this.oc = n);
  }
  async loadResources(e, n) {
    const a = await n.dict.getAsync("Resources");
    return a && await Hi.load(a, e, a.xref), a;
  }
  async getOperatorList(e, n, a, i) {
    const {
      hasOwnCanvas: s,
      id: r,
      rect: o
    } = this.data;
    let c = this.appearance;
    const l = !!(s && a & tn.DISPLAY);
    if (l && (this.width === 0 || this.height === 0))
      return this.data.hasOwnCanvas = !1, {
        opList: new Ht(),
        separateForm: !1,
        separateCanvas: !1
      };
    if (!c) {
      if (!l)
        return {
          opList: new Ht(),
          separateForm: !1,
          separateCanvas: !1
        };
      c = new rn(""), c.dict = new B();
    }
    const h = c.dict, f = await this.loadResources(Z0, c), d = no(h.getArray("BBox"), [0, 0, 1, 1]), u = Fa(h.getArray("Matrix"), $n), x = Fo(o, d, u), g = new Ht();
    let p;
    return this.oc && (p = await e.parseMarkedContentProps(this.oc, null)), p !== void 0 && g.addOp(I.beginMarkedContentProps, ["OC", p]), g.addOp(I.beginAnnotation, [r, o, x, u, l]), await e.getOperatorList({
      stream: c,
      task: n,
      resources: f,
      operatorList: g,
      fallbackFontDict: this._fallbackFontDict
    }), g.addOp(I.endAnnotation, []), p !== void 0 && g.addOp(I.endMarkedContent, []), this.reset(), {
      opList: g,
      separateForm: !1,
      separateCanvas: l
    };
  }
  async save(e, n, a, i) {
    return null;
  }
  get overlaysTextContent() {
    return !1;
  }
  get hasTextContent() {
    return !1;
  }
  async extractTextContent(e, n, a) {
    if (!this.appearance)
      return;
    const i = await this.loadResources(Q0, this.appearance), s = [], r = [];
    let o = null;
    const c = {
      desiredSize: Math.Infinity,
      ready: !0,
      enqueue(l, h) {
        for (const f of l.items)
          f.str !== void 0 && (o ||= f.transform.slice(-2), r.push(f.str), f.hasEOL && (s.push(r.join("").trimEnd()), r.length = 0));
      }
    };
    if (await e.getTextContent({
      stream: this.appearance,
      task: n,
      resources: i,
      includeMarkedContent: !0,
      keepWhiteSpace: !0,
      sink: c,
      viewBox: a
    }), this.reset(), r.length && s.push(r.join("").trimEnd()), s.length > 1 || s[0]) {
      const l = this.appearance.dict, h = no(l.getArray("BBox"), null), f = Fa(l.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(o, h, f), this.data.textContent = s;
    }
  }
  _transformPoint(e, n, a) {
    const {
      rect: i
    } = this.data;
    n ||= [0, 0, 1, 1], a ||= [1, 0, 0, 1, 0, 0];
    const s = Fo(i, n, a);
    s[4] -= i[0], s[5] -= i[1];
    const r = e.slice();
    return Je.applyTransform(r, s), Je.applyTransform(r, a), r;
  }
  getFieldObject() {
    return this.data.kidIds ? {
      id: this.data.id,
      actions: this.data.actions,
      name: this.data.fieldName,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      type: "",
      kidIds: this.data.kidIds,
      page: this.data.pageIndex,
      rotation: this.rotation
    } : null;
  }
  reset() {
    for (const e of this._streams)
      e.reset();
  }
  _constructFieldName(e) {
    if (!e.has("T") && !e.has("Parent"))
      return F("Unknown field name, falling back to empty field name."), "";
    if (!e.has("Parent"))
      return Ve(e.get("T"));
    const n = [];
    e.has("T") && n.unshift(Ve(e.get("T")));
    let a = e;
    const i = new St();
    for (e.objId && i.put(e.objId); a.has("Parent") && (a = a.get("Parent"), !(!(a instanceof B) || a.objId && i.has(a.objId))); )
      a.objId && i.put(a.objId), a.has("T") && n.unshift(Ve(a.get("T")));
    return n.join(".");
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
}
class p5 {
  constructor() {
    this.width = 1, this.rawWidth = 1, this.style = gi.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
  }
  setWidth(e, n = [0, 0, 0, 0]) {
    if (e instanceof Z) {
      this.width = 0;
      return;
    }
    if (typeof e == "number") {
      if (e > 0) {
        this.rawWidth = e;
        const a = (n[2] - n[0]) / 2, i = (n[3] - n[1]) / 2;
        a > 0 && i > 0 && (e > a || e > i) && (F(`AnnotationBorderStyle.setWidth - ignoring width: ${e}`), e = 1);
      }
      this.width = e;
    }
  }
  setStyle(e) {
    if (e instanceof Z)
      switch (e.name) {
        case "S":
          this.style = gi.SOLID;
          break;
        case "D":
          this.style = gi.DASHED;
          break;
        case "B":
          this.style = gi.BEVELED;
          break;
        case "I":
          this.style = gi.INSET;
          break;
        case "U":
          this.style = gi.UNDERLINE;
          break;
      }
  }
  setDashArray(e, n = !1) {
    if (Array.isArray(e)) {
      let a = !0, i = !0;
      for (const s of e)
        if (+s >= 0)
          s > 0 && (i = !1);
        else {
          a = !1;
          break;
        }
      e.length === 0 || a && !i ? (this.dashArray = e, n && this.setStyle(Z.get("D"))) : this.width = 0;
    } else e && (this.width = 0);
  }
  setHorizontalCornerRadius(e) {
    Number.isInteger(e) && (this.horizontalCornerRadius = e);
  }
  setVerticalCornerRadius(e) {
    Number.isInteger(e) && (this.verticalCornerRadius = e);
  }
}
class mn extends Qs {
  constructor(e) {
    super(e);
    const {
      dict: n
    } = e;
    if (n.has("IRT")) {
      const i = n.getRaw("IRT");
      this.data.inReplyTo = i instanceof le ? i.toString() : null;
      const s = n.get("RT");
      this.data.replyType = s instanceof Z ? s.name : K0.REPLY;
    }
    let a = null;
    if (this.data.replyType === K0.GROUP) {
      const i = n.get("IRT");
      this.setTitle(i.get("T")), this.data.titleObj = this._title, this.setContents(i.get("Contents")), this.data.contentsObj = this._contents, i.has("CreationDate") ? (this.setCreationDate(i.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, i.has("M") ? (this.setModificationDate(i.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, a = i.getRaw("Popup"), i.has("C") ? (this.setColor(i.getArray("C")), this.data.color = this.color) : this.data.color = null;
    } else
      this.data.titleObj = this._title, this.setCreationDate(n.get("CreationDate")), this.data.creationDate = this.creationDate, a = n.getRaw("Popup"), n.has("C") || (this.data.color = null);
    this.data.popupRef = a instanceof le ? a.toString() : null, n.has("RC") && (this.data.richText = Js.getRichTextAsHtml(n.get("RC")));
  }
  setCreationDate(e) {
    this.creationDate = typeof e == "string" ? e : null;
  }
  _setDefaultAppearance({
    xref: e,
    extra: n,
    strokeColor: a,
    fillColor: i,
    blendMode: s,
    strokeAlpha: r,
    fillAlpha: o,
    pointsCallback: c
  }) {
    const l = this.data.rect = [1 / 0, 1 / 0, -1 / 0, -1 / 0], h = ["q"];
    n && h.push(n), a && h.push(`${a[0]} ${a[1]} ${a[2]} RG`), i && h.push(`${i[0]} ${i[1]} ${i[2]} rg`);
    const f = this.data.quadPoints || Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]);
    for (let y = 0, w = f.length; y < w; y += 8) {
      const S = c(h, f.subarray(y, y + 8));
      Je.rectBoundingBox(...S, l);
    }
    h.push("Q");
    const d = new B(e), u = new B(e);
    u.setIfName("Subtype", "Form");
    const x = new rn(h.join(" "));
    x.dict = u, d.set("Fm0", x);
    const g = new B(e);
    s && g.setIfName("BM", s), g.setIfNumber("CA", r), g.setIfNumber("ca", o);
    const p = new B(e);
    p.set("GS0", g);
    const m = new B(e);
    m.set("ExtGState", p), m.set("XObject", d);
    const b = new B(e);
    b.set("Resources", m), b.set("BBox", l), this.appearance = new rn("/GS0 gs /Fm0 Do"), this.appearance.dict = b, this._streams.push(this.appearance, x);
  }
  static async createNewAnnotation(e, n, a, i) {
    const s = n.ref ||= e.getNewTemporaryRef(), r = await this.createNewAppearanceStream(n, e, i);
    let o;
    if (r) {
      const h = e.getNewTemporaryRef();
      o = this.createNewDict(n, e, {
        apRef: h
      }), a.put(h, {
        data: r
      });
    } else
      o = this.createNewDict(n, e, {});
    Number.isInteger(n.parentTreeId) && o.set("StructParent", n.parentTreeId), a.put(s, {
      data: o
    });
    const c = {
      ref: s
    }, {
      popup: l
    } = n;
    if (l) {
      if (l.deleted)
        return o.delete("Popup"), o.delete("Contents"), o.delete("RC"), c;
      const h = l.ref ||= e.getNewTemporaryRef();
      l.parent = s;
      const f = dc.createNewDict(l, e);
      return a.put(h, {
        data: f
      }), o.setIfDefined("Contents", kn(l.contents)), o.set("Popup", h), [c, {
        ref: h
      }];
    }
    return c;
  }
  static async createNewPrintAnnotation(e, n, a, i) {
    const s = await this.createNewAppearanceStream(a, n, i), r = this.createNewDict(a, n, s ? {
      ap: s
    } : {}), o = new this.prototype.constructor({
      dict: r,
      xref: n,
      annotationGlobals: e,
      evaluatorOptions: i.evaluatorOptions
    });
    return a.ref && (o.ref = o.refToReplace = a.ref), o;
  }
}
class Gn extends Qs {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a,
      annotationGlobals: i
    } = e, s = this.data;
    this._needAppearances = e.needAppearances, s.annotationType = Mt.WIDGET, s.fieldName === void 0 && (s.fieldName = this._constructFieldName(n)), s.actions === void 0 && (s.actions = a0(a, n, t1));
    let r = Bn({
      dict: n,
      key: "V",
      getArray: !0
    });
    s.fieldValue = this._decodeFormValue(r);
    const o = Bn({
      dict: n,
      key: "DV",
      getArray: !0
    });
    if (s.defaultFieldValue = this._decodeFormValue(o), r === void 0 && i.xfaDatasets) {
      const d = this._title.str;
      d && (this._hasValueFromXFA = !0, s.fieldValue = r = i.xfaDatasets.getValue(d));
    }
    r === void 0 && s.defaultFieldValue !== null && (s.fieldValue = s.defaultFieldValue), s.alternativeText = Ve(n.get("TU") || ""), this.setDefaultAppearance(e), s.hasAppearance ||= this._needAppearances && s.fieldValue !== void 0 && s.fieldValue !== null;
    const c = Bn({
      dict: n,
      key: "FT"
    });
    s.fieldType = c instanceof Z ? c.name : null;
    const l = Bn({
      dict: n,
      key: "DR"
    }), h = i.acroForm.get("DR"), f = this.appearance?.dict.get("Resources");
    this._fieldResources = {
      localResources: l,
      acroFormResources: h,
      appearanceResources: f,
      mergedResources: B.merge({
        xref: a,
        dictArray: [l, f, h],
        mergeSubDicts: !0
      })
    }, s.fieldFlags = Bn({
      dict: n,
      key: "Ff"
    }), (!Number.isInteger(s.fieldFlags) || s.fieldFlags < 0) && (s.fieldFlags = 0), s.password = this.hasFieldFlag(Hn.PASSWORD), s.readOnly = this.hasFieldFlag(Hn.READONLY), s.required = this.hasFieldFlag(Hn.REQUIRED), s.hidden = this._hasFlag(s.annotationFlags, Tt.HIDDEN) || this._hasFlag(s.annotationFlags, Tt.NOVIEW);
  }
  _decodeFormValue(e) {
    return Array.isArray(e) ? e.filter((n) => typeof n == "string").map((n) => Ve(n)) : e instanceof Z ? Ve(e.name) : typeof e == "string" ? Ve(e) : null;
  }
  hasFieldFlag(e) {
    return !!(this.data.fieldFlags & e);
  }
  _isViewable(e) {
    return !0;
  }
  mustBeViewed(e, n) {
    return n ? this.viewable : super.mustBeViewed(e, n) && !this._hasFlag(this.flags, Tt.NOVIEW);
  }
  getRotationMatrix(e) {
    let n = e?.get(this.data.id)?.rotation;
    return n === void 0 && (n = this.rotation), n === 0 ? $n : Ur(n, this.width, this.height);
  }
  getBorderAndBackgroundAppearances(e) {
    let n = e?.get(this.data.id)?.rotation;
    if (n === void 0 && (n = this.rotation), !this.backgroundColor && !this.borderColor)
      return "";
    const a = n === 0 || n === 180 ? `0 0 ${this.width} ${this.height} re` : `0 0 ${this.height} ${this.width} re`;
    let i = "";
    if (this.backgroundColor && (i = `${aa(this.backgroundColor, !0)} ${a} f `), this.borderColor) {
      const s = this.borderStyle.width || 1;
      i += `${s} w ${aa(this.borderColor, !1)} ${a} S `;
    }
    return i;
  }
  async getOperatorList(e, n, a, i) {
    if (a & tn.ANNOTATIONS_FORMS && !(this instanceof Rh) && !this.data.noHTML && !this.data.hasOwnCanvas)
      return {
        opList: new Ht(),
        separateForm: !0,
        separateCanvas: !1
      };
    if (!this._hasText)
      return super.getOperatorList(e, n, a, i);
    const s = await this._getAppearance(e, n, a, i);
    if (this.appearance && s === null)
      return super.getOperatorList(e, n, a, i);
    const r = new Ht();
    if (!this._defaultAppearance || s === null)
      return {
        opList: r,
        separateForm: !1,
        separateCanvas: !1
      };
    const o = !!(this.data.hasOwnCanvas && a & tn.DISPLAY), c = [1, 0, 0, 1, 0, 0], l = [0, 0, this.width, this.height], h = Fo(this.data.rect, l, c);
    let f;
    this.oc && (f = await e.parseMarkedContentProps(this.oc, null)), f !== void 0 && r.addOp(I.beginMarkedContentProps, ["OC", f]), r.addOp(I.beginAnnotation, [this.data.id, this.data.rect, h, this.getRotationMatrix(i), o]);
    const d = new rn(s);
    return await e.getOperatorList({
      stream: d,
      task: n,
      resources: this._fieldResources.mergedResources,
      operatorList: r
    }), r.addOp(I.endAnnotation, []), f !== void 0 && r.addOp(I.endMarkedContent, []), {
      opList: r,
      separateForm: !1,
      separateCanvas: o
    };
  }
  _getMKDict(e) {
    const n = new B(null);
    return e && n.set("R", e), n.setIfArray("BC", qt(this.borderColor)), n.setIfArray("BG", qt(this.backgroundColor)), n.size > 0 ? n : null;
  }
  amendSavedDict(e, n) {
  }
  setValue(e, n, a, i) {
    const {
      dict: s,
      ref: r
    } = lf(e, this.ref, a);
    if (!s)
      e.set("V", n);
    else if (!i.has(r)) {
      const o = s.clone();
      return o.set("V", n), i.put(r, {
        data: o
      }), o;
    }
    return null;
  }
  async save(e, n, a, i) {
    const s = a?.get(this.data.id), r = this._buildFlags(s?.noView, s?.noPrint);
    let o = s?.value, c = s?.rotation;
    if (o === this.data.fieldValue || o === void 0) {
      if (!this._hasValueFromXFA && c === void 0 && r === void 0)
        return;
      o ||= this.data.fieldValue;
    }
    if (c === void 0 && !this._hasValueFromXFA && Array.isArray(o) && Array.isArray(this.data.fieldValue) && Fs(o, this.data.fieldValue) && r === void 0)
      return;
    c === void 0 && (c = this.rotation);
    let l = null;
    if (!this._needAppearances && (l = await this._getAppearance(e, n, tn.SAVE, a), l === null && r === void 0))
      return;
    let h = !1;
    l?.needAppearances && (h = !0, l = null);
    const {
      xref: f
    } = e, d = f.fetchIfRef(this.ref);
    if (!(d instanceof B))
      return;
    const u = new B(f);
    for (const m of d.getKeys())
      m !== "AP" && u.set(m, d.getRaw(m));
    if (r !== void 0 && (u.set("F", r), l === null && !h)) {
      const m = d.getRaw("AP");
      m && u.set("AP", m);
    }
    const x = {
      path: this.data.fieldName,
      value: o
    }, g = this.setValue(u, Array.isArray(o) ? o.map(kn) : kn(o), f, i);
    this.amendSavedDict(a, g || u);
    const p = this._getMKDict(c);
    if (p && u.set("MK", p), i.put(this.ref, {
      data: u,
      xfa: x,
      needAppearances: h
    }), l !== null) {
      const m = f.getNewTemporaryRef(), b = new B(f);
      u.set("AP", b), b.set("N", m);
      const y = this._getSaveFieldResources(f), w = new rn(l), S = w.dict = new B(f);
      S.setIfName("Subtype", "Form"), S.set("Resources", y);
      const v = c % 180 === 0 ? [0, 0, this.width, this.height] : [0, 0, this.height, this.width];
      S.set("BBox", v);
      const k = this.getRotationMatrix(a);
      k !== $n && S.set("Matrix", k), i.put(m, {
        data: w,
        xfa: null,
        needAppearances: !1
      });
    }
    u.set("M", `D:${ci()}`);
  }
  async _getAppearance(e, n, a, i) {
    if (this.data.password)
      return null;
    const s = i?.get(this.data.id);
    let r, o;
    if (s && (r = s.formattedValue || s.value, o = s.rotation), o === void 0 && r === void 0 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
      return null;
    const c = this.getBorderAndBackgroundAppearances(i);
    if (r === void 0 && (r = this.data.fieldValue, !r))
      return `/Tx BMC q ${c}Q EMC`;
    if (Array.isArray(r) && r.length === 1 && (r = r[0]), at(typeof r == "string", "Expected `value` to be a string."), r = r.trimEnd(), this.data.combo && (r = this.data.options.find(({
      exportValue: O
    }) => r === O)?.displayValue || r), r === "")
      return `/Tx BMC q ${c}Q EMC`;
    o === void 0 && (o = this.rotation);
    let l = -1, h;
    this.data.multiLine ? (h = r.split(/\r\n?|\n/).map((M) => M.normalize("NFC")), l = h.length) : h = [r.replace(/\r\n?|\n/, "").normalize("NFC")];
    const f = 1, d = 2;
    let {
      width: u,
      height: x
    } = this;
    (o === 90 || o === 270) && ([u, x] = [x, u]), this._defaultAppearance || (this.data.defaultAppearanceData = Yo(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let g = await Gn._getFontData(e, n, this.data.defaultAppearanceData, this._fieldResources.mergedResources), p, m, b;
    const y = [];
    let w = !1;
    for (const M of h) {
      const O = g.encodeString(M);
      O.length > 1 && (w = !0), y.push(O.join(""));
    }
    if (w && a & tn.SAVE)
      return {
        needAppearances: !0
      };
    if (w && this._isOffscreenCanvasSupported) {
      const M = this.data.comb ? "monospace" : "sans-serif", O = new Jn(e.xref, M), N = O.createFontResources(h.join("")), H = N.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const j = this._fieldResources.mergedResources.get("Font");
        for (const P of H.getKeys())
          j.set(P, H.getRaw(P));
      } else
        this._fieldResources.mergedResources.set("Font", H);
      const J = O.fontName.name;
      g = await Gn._getFontData(e, n, {
        fontName: J,
        fontSize: 0
      }, N);
      for (let j = 0, P = y.length; j < P; j++)
        y[j] = f1(h[j]);
      const U = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = J, [p, m, b] = this._computeFontSize(x - 2 * f, u - 2 * d, r, g, l), this.data.defaultAppearanceData = U;
    } else
      this._isOffscreenCanvasSupported || F("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [p, m, b] = this._computeFontSize(x - 2 * f, u - 2 * d, r, g, l);
    let S = g.descent;
    isNaN(S) ? S = mc * b : S = Math.max(mc * b, Math.abs(S) * m);
    const v = Math.min(Math.floor((x - m) / 2), f), k = this.data.textAlignment;
    if (this.data.multiLine)
      return this._getMultilineAppearance(p, y, g, m, u, x, k, d, v, S, b, i);
    if (this.data.comb)
      return this._getCombAppearance(p, g, y[0], m, u, x, d, v, S, b, i);
    const A = v + S;
    if (k === 0 || k > 2)
      return `/Tx BMC q ${c}BT ` + p + ` 1 0 0 1 ${ze(d)} ${ze(A)} Tm (${Di(y[0])}) Tj ET Q EMC`;
    const C = {
      shift: 0
    }, T = this._renderText(y[0], g, m, u, k, C, d, A);
    return `/Tx BMC q ${c}BT ` + p + ` 1 0 0 1 0 0 Tm ${T} ET Q EMC`;
  }
  static async _getFontData(e, n, a, i) {
    const s = new Ht(), r = {
      font: null,
      clone() {
        return this;
      }
    }, {
      fontName: o,
      fontSize: c
    } = a;
    return await e.handleSetFont(i, [o && Z.get(o), c], null, s, n, r, null), r.font;
  }
  _getTextWidth(e, n) {
    return Math.sumPrecise(n.charsToGlyphs(e).map((a) => a.width)) / 1e3;
  }
  _computeFontSize(e, n, a, i, s) {
    let {
      fontSize: r
    } = this.data.defaultAppearanceData, o = (r || 12) * ua, c = Math.round(e / o);
    if (!r) {
      const l = (d) => Math.floor(d * 100) / 100;
      if (s === -1) {
        const d = this._getTextWidth(a, i);
        r = l(Math.min(e / ua, n / d)), c = 1;
      } else {
        const d = a.split(/\r\n?|\n/), u = [];
        for (const g of d) {
          const p = i.encodeString(g).join(""), m = i.charsToGlyphs(p), b = i.getCharPositions(p);
          u.push({
            line: p,
            glyphs: m,
            positions: b
          });
        }
        const x = (g) => {
          let p = 0;
          for (const m of u) {
            const b = this._splitLine(null, i, g, n, m);
            if (p += b.length * g, p > e)
              return !0;
          }
          return !1;
        };
        for (c = Math.max(c, s); ; ) {
          if (o = e / c, r = l(o / ua), x(r)) {
            c++;
            continue;
          }
          break;
        }
      }
      const {
        fontName: h,
        fontColor: f
      } = this.data.defaultAppearanceData;
      this._defaultAppearance = gx({
        fontSize: r,
        fontName: h,
        fontColor: f
      });
    }
    return [this._defaultAppearance, r, e / c];
  }
  _renderText(e, n, a, i, s, r, o, c) {
    let l;
    if (s === 1) {
      const f = this._getTextWidth(e, n) * a;
      l = (i - f) / 2;
    } else if (s === 2) {
      const f = this._getTextWidth(e, n) * a;
      l = i - f - o;
    } else
      l = o;
    const h = ze(l - r.shift);
    return r.shift = l, c = ze(c), `${h} ${c} Td (${Di(e)}) Tj`;
  }
  _getSaveFieldResources(e) {
    const {
      localResources: n,
      appearanceResources: a,
      acroFormResources: i
    } = this._fieldResources, s = this.data.defaultAppearanceData?.fontName;
    if (!s)
      return n || B.empty;
    for (const r of [n, a])
      if (r instanceof B) {
        const o = r.get("Font");
        if (o instanceof B && o.has(s))
          return r;
      }
    if (i instanceof B) {
      const r = i.get("Font");
      if (r instanceof B && r.has(s)) {
        const o = new B(e);
        o.set(s, r.getRaw(s));
        const c = new B(e);
        return c.set("Font", o), B.merge({
          xref: e,
          dictArray: [c, n],
          mergeSubDicts: !0
        });
      }
    }
    return n || B.empty;
  }
  getFieldObject() {
    return null;
  }
}
class m5 extends Gn {
  constructor(e) {
    super(e);
    const {
      dict: n
    } = e;
    n.has("PMD") && (this.flags |= Tt.HIDDEN, this.data.hidden = !0, F("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0, typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
    let a = Bn({
      dict: n,
      key: "Q"
    });
    (!Number.isInteger(a) || a < 0 || a > 2) && (a = null), this.data.textAlignment = a;
    let i = Bn({
      dict: n,
      key: "MaxLen"
    });
    (!Number.isInteger(i) || i < 0) && (i = 0), this.data.maxLen = i, this.data.multiLine = this.hasFieldFlag(Hn.MULTILINE), this.data.comb = this.hasFieldFlag(Hn.COMB) && !this.data.multiLine && !this.data.password && !this.hasFieldFlag(Hn.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(Hn.DONOTSCROLL);
    const {
      data: {
        actions: s
      }
    } = this;
    if (!s)
      return;
    const r = /^AF(Date|Time)_(?:Keystroke|Format)(?:Ex)?\(['"]?([^'"]+)['"]?\);$/;
    let o = !1;
    (s.Format?.length === 1 && s.Keystroke?.length === 1 && r.test(s.Format[0]) && r.test(s.Keystroke[0]) || s.Format?.length === 0 && s.Keystroke?.length === 1 && r.test(s.Keystroke[0]) || s.Keystroke?.length === 0 && s.Format?.length === 1 && r.test(s.Format[0])) && (o = !0);
    const c = [];
    s.Format && c.push(...s.Format), s.Keystroke && c.push(...s.Keystroke), o && (delete s.Keystroke, s.Format = c);
    for (const l of c) {
      const h = l.match(r);
      if (!h)
        continue;
      const f = h[1] === "Date";
      let d = h[2];
      const u = parseInt(d, 10);
      if (!isNaN(u) && Math.floor(Math.log10(u)) + 1 === h[2].length && (d = (f ? px : mx)[u] ?? d), this.data.datetimeFormat = d, !o)
        break;
      if (f) {
        /HH|MM|ss|h/.test(d) ? (this.data.datetimeType = "datetime-local", this.data.timeStep = /ss/.test(d) ? 1 : 60) : this.data.datetimeType = "date";
        break;
      }
      this.data.datetimeType = "time", this.data.timeStep = /ss/.test(d) ? 1 : 60;
      break;
    }
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(e, n, a, i, s, r, o, c, l, h, f) {
    const d = s / this.data.maxLen, u = this.getBorderAndBackgroundAppearances(f), x = [], g = n.getCharPositions(a);
    for (const [m, b] of g)
      x.push(`(${Di(a.substring(m, b))}) Tj`);
    const p = x.join(` ${ze(d)} 0 Td `);
    return `/Tx BMC q ${u}BT ` + e + ` 1 0 0 1 ${ze(o)} ${ze(c + l)} Tm ${p} ET Q EMC`;
  }
  _getMultilineAppearance(e, n, a, i, s, r, o, c, l, h, f, d) {
    const u = [], x = s - 2 * c, g = {
      shift: 0
    };
    for (let b = 0, y = n.length; b < y; b++) {
      const w = n[b], S = this._splitLine(w, a, i, x);
      for (let v = 0, k = S.length; v < k; v++) {
        const A = S[v], C = b === 0 && v === 0 ? -l - (f - h) : -f;
        u.push(this._renderText(A, a, i, s, o, g, c, C));
      }
    }
    const p = this.getBorderAndBackgroundAppearances(d), m = u.join(`
`);
    return `/Tx BMC q ${p}BT ` + e + ` 1 0 0 1 0 ${ze(r)} Tm ${m} ET Q EMC`;
  }
  _splitLine(e, n, a, i, s = {}) {
    e = s.line || e;
    const r = s.glyphs || n.charsToGlyphs(e);
    if (r.length <= 1)
      return [e];
    const o = s.positions || n.getCharPositions(e), c = a / 1e3, l = [];
    let h = -1, f = -1, d = -1, u = 0, x = 0;
    for (let g = 0, p = r.length; g < p; g++) {
      const [m, b] = o[g], y = r[g], w = y.width * c;
      y.unicode === " " ? x + w > i ? (l.push(e.substring(u, m)), u = m, x = w, h = -1, d = -1) : (x += w, h = m, f = b, d = g) : x + w > i ? h !== -1 ? (l.push(e.substring(u, f)), u = f, g = d + 1, h = -1, x = 0) : (l.push(e.substring(u, m)), u = m, x = w) : x += w;
    }
    return u < e.length && l.push(e.substring(u, e.length)), l;
  }
  async extractTextContent(e, n, a) {
    await super.extractTextContent(e, n, a);
    const i = this.data.textContent;
    if (!i)
      return;
    const s = i.join(`
`);
    if (s === this.data.fieldValue)
      return;
    const r = s.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (o, c) => c ? `\\${c}` : "\\s+");
    new RegExp(`^\\s*${r}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split(`
`));
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: this.data.fieldValue,
      defaultValue: this.data.defaultFieldValue || "",
      multiline: this.data.multiLine,
      password: this.data.password,
      charLimit: this.data.maxLen,
      comb: this.data.comb,
      editable: !this.data.readOnly,
      hidden: this.data.hidden,
      name: this.data.fieldName,
      rect: this.data.rect,
      actions: this.data.actions,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      datetimeFormat: this.data.datetimeFormat,
      hasDatetimeHTML: !!this.data.datetimeType,
      type: "text"
    };
  }
}
class b5 extends Gn {
  constructor(e) {
    super(e), this.checkedAppearance = null, this.uncheckedAppearance = null;
    const n = this.hasFieldFlag(Hn.RADIO), a = this.hasFieldFlag(Hn.PUSHBUTTON);
    this.data.checkBox = !n && !a, this.data.radioButton = n && !a, this.data.pushButton = a, this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(e) : this.data.radioButton ? this._processRadioButton(e) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this.data.noHTML = !1, this._processPushButton(e)) : F("Invalid field flags for button widget annotation");
  }
  async getOperatorList(e, n, a, i) {
    if (this.data.pushButton)
      return super.getOperatorList(e, n, a, !1, i);
    let s = null, r = null;
    if (i) {
      const c = i.get(this.data.id);
      s = c ? c.value : null, r = c ? c.rotation : null;
    }
    if (s === null && this.appearance)
      return super.getOperatorList(e, n, a, i);
    s == null && (s = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const o = s ? this.checkedAppearance : this.uncheckedAppearance;
    if (o) {
      const c = this.appearance, l = Fa(o.dict.getArray("Matrix"), $n);
      r && o.dict.set("Matrix", this.getRotationMatrix(i)), this.appearance = o;
      const h = super.getOperatorList(e, n, a, i);
      return this.appearance = c, o.dict.set("Matrix", l), h;
    }
    return {
      opList: new Ht(),
      separateForm: !1,
      separateCanvas: !1
    };
  }
  async save(e, n, a, i) {
    if (this.data.checkBox) {
      this._saveCheckbox(e, n, a, i);
      return;
    }
    this.data.radioButton && this._saveRadioButton(e, n, a, i);
  }
  async _saveCheckbox(e, n, a, i) {
    if (!a)
      return;
    const s = a.get(this.data.id), r = this._buildFlags(s?.noView, s?.noPrint);
    let o = s?.rotation, c = s?.value;
    if (o === void 0 && r === void 0 && (c === void 0 || this.data.fieldValue === this.data.exportValue === c))
      return;
    let l = e.xref.fetchIfRef(this.ref);
    if (!(l instanceof B))
      return;
    l = l.clone(), o === void 0 && (o = this.rotation), c === void 0 && (c = this.data.fieldValue === this.data.exportValue);
    const h = {
      path: this.data.fieldName,
      value: c ? this.data.exportValue : ""
    }, f = Z.get(c ? this.data.exportValue : "Off");
    this.setValue(l, f, e.xref, i), l.set("AS", f), l.set("M", `D:${ci()}`), r !== void 0 && l.set("F", r);
    const d = this._getMKDict(o);
    d && l.set("MK", d), i.put(this.ref, {
      data: l,
      xfa: h,
      needAppearances: !1
    });
  }
  async _saveRadioButton(e, n, a, i) {
    if (!a)
      return;
    const s = a.get(this.data.id), r = this._buildFlags(s?.noView, s?.noPrint);
    let o = s?.rotation, c = s?.value;
    if (o === void 0 && r === void 0 && (c === void 0 || this.data.fieldValue === this.data.buttonValue === c))
      return;
    let l = e.xref.fetchIfRef(this.ref);
    if (!(l instanceof B))
      return;
    l = l.clone(), c === void 0 && (c = this.data.fieldValue === this.data.buttonValue), o === void 0 && (o = this.rotation);
    const h = {
      path: this.data.fieldName,
      value: c ? this.data.buttonValue : ""
    }, f = Z.get(c ? this.data.buttonValue : "Off");
    c && this.setValue(l, f, e.xref, i), l.set("AS", f), l.set("M", `D:${ci()}`), r !== void 0 && l.set("F", r);
    const d = this._getMKDict(o);
    d && l.set("MK", d), i.put(this.ref, {
      data: l,
      xfa: h,
      needAppearances: !1
    });
  }
  _getDefaultCheckedAppearance(e, n) {
    const {
      width: a,
      height: i
    } = this, s = [0, 0, a, i], o = Math.min(a, i) * 0.8;
    let c, l;
    n === "check" ? (c = {
      width: 0.755 * o,
      height: 0.705 * o
    }, l = "3") : n === "disc" ? (c = {
      width: 0.791 * o,
      height: 0.705 * o
    }, l = "l") : _e(`_getDefaultCheckedAppearance - unsupported type: ${n}`);
    const h = ze((a - c.width) / 2), f = ze((i - c.height) / 2), d = `q BT /PdfJsZaDb ${o} Tf 0 g ${h} ${f} Td (${l}) Tj ET Q`, u = new B(e.xref);
    u.set("FormType", 1), u.setIfName("Subtype", "Form"), u.setIfName("Type", "XObject"), u.set("BBox", s), u.set("Matrix", [1, 0, 0, 1, 0, 0]), u.set("Length", d.length);
    const x = new B(e.xref), g = new B(e.xref);
    g.set("PdfJsZaDb", this.fallbackFontDict), x.set("Font", g), u.set("Resources", x), this.checkedAppearance = new rn(d), this.checkedAppearance.dict = u, this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(e) {
    const n = e.dict.get("AP");
    if (!(n instanceof B))
      return;
    const a = n.get("N");
    if (!(a instanceof B))
      return;
    const i = this._decodeFormValue(e.dict.get("AS"));
    typeof i == "string" && (this.data.fieldValue = i);
    const s = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", r = this._decodeFormValue(a.getKeys());
    if (r.length === 0)
      r.push("Off", s);
    else if (r.length === 1)
      r[0] === "Off" ? r.push(s) : r.unshift("Off");
    else if (r.includes(s))
      r.length = 0, r.push("Off", s);
    else {
      const l = r.find((h) => h !== "Off");
      r.length = 0, r.push("Off", l);
    }
    r.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = r[1];
    const o = a.get(this.data.exportValue);
    this.checkedAppearance = o instanceof Ne ? o : null;
    const c = a.get("Off");
    this.uncheckedAppearance = c instanceof Ne ? c : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(e) {
    this.data.buttonValue = null;
    const n = e.dict.get("Parent");
    if (n instanceof B) {
      this.parent = e.dict.getRaw("Parent");
      const o = n.get("V");
      o instanceof Z && (this.data.fieldValue = this._decodeFormValue(o));
    }
    const a = e.dict.get("AP");
    if (!(a instanceof B))
      return;
    const i = a.get("N");
    if (!(i instanceof B))
      return;
    for (const o of i.getKeys())
      if (o !== "Off") {
        this.data.buttonValue = this._decodeFormValue(o);
        break;
      }
    const s = i.get(this.data.buttonValue);
    this.checkedAppearance = s instanceof Ne ? s : null;
    const r = i.get("Off");
    this.uncheckedAppearance = r instanceof Ne ? r : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(e) {
    const {
      dict: n,
      annotationGlobals: a
    } = e;
    if (!n.has("A") && !n.has("AA") && !this.data.alternativeText) {
      F("Push buttons without action dictionaries are not supported");
      return;
    }
    this.data.isTooltipOnly = !n.has("A") && !n.has("AA"), ji.parseDestDictionary({
      destDict: n,
      resultObj: this.data,
      docBaseUrl: a.baseUrl,
      docAttachments: a.attachments
    });
  }
  getFieldObject() {
    let e = "button", n;
    return this.data.checkBox ? (e = "checkbox", n = this.data.exportValue) : this.data.radioButton && (e = "radiobutton", n = this.data.buttonValue), {
      id: this.data.id,
      value: this.data.fieldValue || "Off",
      defaultValue: this.data.defaultFieldValue,
      exportValues: n,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type: e
    };
  }
  get fallbackFontDict() {
    const e = new B();
    return e.setIfName("BaseFont", "ZapfDingbats"), e.setIfName("Type", "FallbackType"), e.setIfName("Subtype", "FallbackType"), e.setIfName("Encoding", "ZapfDingbatsEncoding"), ae(this, "fallbackFontDict", e);
  }
}
class y5 extends Gn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    this.indices = n.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
    const i = Bn({
      dict: n,
      key: "Opt"
    });
    if (Array.isArray(i))
      for (let s = 0, r = i.length; s < r; s++) {
        const o = a.fetchIfRef(i[s]), c = Array.isArray(o);
        this.data.options[s] = {
          exportValue: this._decodeFormValue(c ? a.fetchIfRef(o[0]) : o),
          displayValue: this._decodeFormValue(c ? a.fetchIfRef(o[1]) : o)
        };
      }
    if (!this.hasIndices)
      typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue ||= [];
    else {
      this.data.fieldValue = [];
      const s = this.data.options.length;
      for (const r of this.indices)
        Number.isInteger(r) && r >= 0 && r < s && this.data.fieldValue.push(this.data.options[r].exportValue);
    }
    this.data.options.length === 0 && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((s) => ({
      exportValue: s,
      displayValue: s
    }))), this.data.combo = this.hasFieldFlag(Hn.COMBO), this.data.multiSelect = this.hasFieldFlag(Hn.MULTISELECT), this._hasText = !0;
  }
  getFieldObject() {
    const e = this.data.combo ? "combobox" : "listbox", n = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return {
      id: this.data.id,
      value: n,
      defaultValue: this.data.defaultFieldValue,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      numItems: this.data.fieldValue.length,
      multipleSelection: this.data.multiSelect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      items: this.data.options,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type: e
    };
  }
  amendSavedDict(e, n) {
    if (!this.hasIndices)
      return;
    let a = e?.get(this.data.id)?.value;
    Array.isArray(a) || (a = [a]);
    const i = [], {
      options: s
    } = this.data;
    for (let r = 0, o = 0, c = s.length; r < c; r++)
      s[r].exportValue === a[o] && (i.push(r), o += 1);
    n.set("I", i);
  }
  async _getAppearance(e, n, a, i) {
    if (this.data.combo)
      return super._getAppearance(e, n, a, i);
    let s, r;
    const o = i?.get(this.data.id);
    if (o && (r = o.rotation, s = o.value), r === void 0 && s === void 0 && !this._needAppearances)
      return null;
    s === void 0 ? s = this.data.fieldValue : Array.isArray(s) || (s = [s]);
    const c = 1, l = 2;
    let {
      width: h,
      height: f
    } = this;
    (r === 90 || r === 270) && ([h, f] = [f, h]);
    const d = this.data.options.length, u = [];
    for (let A = 0; A < d; A++) {
      const {
        exportValue: C
      } = this.data.options[A];
      s.includes(C) && u.push(A);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = Yo(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const x = await Gn._getFontData(e, n, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let g, {
      fontSize: p
    } = this.data.defaultAppearanceData;
    if (p)
      g = this._defaultAppearance;
    else {
      const A = (f - c) / d;
      let C = -1, T;
      for (const {
        displayValue: M
      } of this.data.options) {
        const O = this._getTextWidth(M, x);
        O > C && (C = O, T = M);
      }
      [g, p] = this._computeFontSize(A, h - 2 * l, T, x, -1);
    }
    const m = p * ua, b = (m - p) / 2, y = Math.floor(f / m);
    let w = 0;
    if (u.length > 0) {
      const A = Math.min(...u), C = Math.max(...u);
      w = Math.max(0, C - y + 1), w > A && (w = A);
    }
    const S = Math.min(w + y + 1, d), v = ["/Tx BMC q", `1 1 ${h} ${f} re W n`];
    if (u.length) {
      v.push("0.600006 0.756866 0.854904 rg");
      for (const A of u)
        w <= A && A < S && v.push(`1 ${f - (A - w + 1) * m} ${h} ${m} re f`);
    }
    v.push("BT", g, `1 0 0 1 0 ${f} Tm`);
    const k = {
      shift: 0
    };
    for (let A = w; A < S; A++) {
      const {
        displayValue: C
      } = this.data.options[A], T = A === w ? b : 0;
      v.push(this._renderText(C, x, p, h, 0, k, l, -m + T));
    }
    return v.push("ET Q EMC"), v.join(`
`);
  }
}
class Rh extends Gn {
  constructor(e) {
    super(e), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: null,
      page: this.data.pageIndex,
      type: "signature"
    };
  }
}
class w5 extends mn {
  constructor(e) {
    super(e), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const {
      dict: a
    } = e;
    this.data.annotationType = Mt.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = a.has("Name") ? a.get("Name").name : "Note"), a.has("State") ? (this.data.state = a.get("State") || null, this.data.stateModel = a.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
  }
}
class v5 extends Qs {
  constructor(e) {
    super(e);
    const {
      dict: n,
      annotationGlobals: a
    } = e;
    this.data.annotationType = Mt.LINK, this.data.noHTML = !1;
    const i = Zs(n, this.rectangle);
    i && (this.data.quadPoints = i), this.data.borderColor ||= this.data.color, ji.parseDestDictionary({
      destDict: n,
      resultObj: this.data,
      docBaseUrl: a.baseUrl,
      docAttachments: a.attachments
    });
  }
  get overlaysTextContent() {
    return !0;
  }
}
class dc extends Qs {
  constructor(e) {
    super(e);
    const {
      dict: n
    } = e;
    this.data.annotationType = Mt.POPUP, this.data.noHTML = !1, (this.width === 0 || this.height === 0) && (this.data.rect = null);
    let a = n.get("Parent");
    if (!a) {
      F("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    this.data.parentRect = ma(a.getArray("Rect"), null), this.data.creationDate = a.get("CreationDate") || "";
    const i = a.get("RT");
    if (dt(i, K0.GROUP) && (a = a.get("IRT")), a.has("M") ? (this.setModificationDate(a.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, a.has("C") ? (this.setColor(a.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
      const s = a.get("F");
      this._isViewable(s) && this.setFlags(s);
    }
    this.setTitle(a.get("T")), this.data.titleObj = this._title, this.setContents(a.get("Contents")), this.data.contentsObj = this._contents, a.has("RC") && (this.data.richText = Js.getRichTextAsHtml(a.get("RC"))), this.data.open = !!n.get("Open");
  }
  static createNewDict(e, n, a) {
    const {
      oldAnnotation: i,
      rect: s,
      parent: r
    } = e, o = i || new B(n);
    return o.setIfNotExists("Type", Z.get("Annot")), o.setIfNotExists("Subtype", Z.get("Popup")), o.setIfNotExists("Open", !1), o.setIfArray("Rect", s), o.set("Parent", r), o;
  }
  static async createNewAppearanceStream(e, n, a) {
    return null;
  }
}
class W0 extends mn {
  constructor(e) {
    super(e), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
    const {
      annotationGlobals: n,
      evaluatorOptions: a,
      xref: i
    } = e;
    if (this.data.annotationType = Mt.FREETEXT, this.setDefaultAppearance(e), this._hasAppearance = !!this.appearance, this._hasAppearance) {
      const {
        fontColor: s,
        fontSize: r
      } = xx(this.appearance, a, i, n.globalColorSpaceCache);
      this.data.defaultAppearanceData.fontColor = s, this.data.defaultAppearanceData.fontSize = r || 10;
    } else {
      this.data.defaultAppearanceData.fontSize ||= 10;
      const {
        fontColor: s,
        fontSize: r
      } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((h) => h.trimEnd());
        const {
          coords: o,
          bbox: c,
          matrix: l
        } = Jn.getFirstPositionInfo(this.rectangle, this.rotation, r);
        this.data.textPosition = this._transformPoint(o, c, l);
      }
      if (this._isOffscreenCanvasSupported) {
        const o = e.dict.get("CA"), c = new Jn(i, "sans-serif");
        this.appearance = c.createAppearance(this._contents.str, this.rectangle, this.rotation, r, s, o), this._streams.push(this.appearance);
      } else
        F("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(e, n, {
    apRef: a,
    ap: i
  }) {
    const {
      color: s,
      date: r,
      fontSize: o,
      oldAnnotation: c,
      rect: l,
      rotation: h,
      user: f,
      value: d
    } = e, u = c || new B(n);
    u.setIfNotExists("Type", Z.get("Annot")), u.setIfNotExists("Subtype", Z.get("FreeText")), u.set(c ? "M" : "CreationDate", `D:${ci(r)}`), c && u.delete("RC"), u.setIfArray("Rect", l);
    const x = `/Helv ${o} Tf ${aa(s, !0)}`;
    if (u.set("DA", x), u.setIfDefined("Contents", kn(d)), u.setIfNotExists("F", 4), u.setIfNotExists("Border", [0, 0, 0]), u.setIfNumber("Rotate", h), u.setIfDefined("T", kn(f)), a || i) {
      const g = new B(n);
      u.set("AP", g), g.set("N", a || i);
    }
    return u;
  }
  static async createNewAppearanceStream(e, n, a) {
    const {
      baseFontRef: i,
      evaluator: s,
      task: r
    } = a, {
      color: o,
      fontSize: c,
      rect: l,
      rotation: h,
      value: f
    } = e;
    if (!o)
      return null;
    const d = new B(n), u = new B(n);
    if (i)
      u.set("Helv", i);
    else {
      const D = new B(n);
      D.setIfName("BaseFont", "Helvetica"), D.setIfName("Type", "Font"), D.setIfName("Subtype", "Type1"), D.setIfName("Encoding", "WinAnsiEncoding"), u.set("Helv", D);
    }
    d.set("Font", u);
    const x = await Gn._getFontData(s, r, {
      fontName: "Helv",
      fontSize: c
    }, d), [g, p, m, b] = l;
    let y = m - g, w = b - p;
    h % 180 !== 0 && ([y, w] = [w, y]);
    const S = f.split(`
`), v = c / 1e3;
    let k = -1 / 0;
    const A = [];
    for (let D of S) {
      const G = x.encodeString(D);
      if (G.length > 1)
        return null;
      D = G.join(""), A.push(D);
      let R = 0;
      const L = x.charsToGlyphs(D);
      for (const V of L)
        R += V.width * v;
      k = Math.max(k, R);
    }
    let C = 1;
    k > y && (C = y / k);
    let T = 1;
    const M = ua * c, O = (ua - Pr) * c, N = M * S.length;
    N > w && (T = w / N);
    const H = Math.min(C, T), J = c * H;
    let U, j, P;
    switch (h) {
      case 0:
        P = [1, 0, 0, 1], j = [l[0], l[1], y, w], U = [l[0], l[3] - O];
        break;
      case 90:
        P = [0, 1, -1, 0], j = [l[1], -l[2], y, w], U = [l[1], -l[0] - O];
        break;
      case 180:
        P = [-1, 0, 0, -1], j = [-l[2], -l[3], y, w], U = [-l[2], -l[1] - O];
        break;
      case 270:
        P = [0, -1, 1, 0], j = [-l[3], l[0], y, w], U = [-l[3], l[2] - O];
        break;
    }
    const K = ["q", `${P.join(" ")} 0 0 cm`, `${j.join(" ")} re W n`, "BT", `${aa(o, !0)}`, `0 Tc /Helv ${ze(J)} Tf`];
    K.push(`${U.join(" ")} Td (${Di(A[0])}) Tj`);
    const xe = ze(M);
    for (let D = 1, G = A.length; D < G; D++) {
      const R = A[D];
      K.push(`0 -${xe} Td (${Di(R)}) Tj`);
    }
    K.push("ET", "Q");
    const X = K.join(`
`), ye = new B(n);
    ye.set("FormType", 1), ye.setIfName("Subtype", "Form"), ye.setIfName("Type", "XObject"), ye.set("BBox", l), ye.set("Resources", d), ye.set("Matrix", [1, 0, 0, 1, -l[0], -l[1]]);
    const we = new rn(X);
    return we.dict = ye, we;
  }
}
class S5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    this.data.annotationType = Mt.LINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const i = no(n.getArray("L"), [0, 0, 0, 0]);
    if (this.data.lineCoordinates = Je.normalizeRect(i), this.setLineEndings(n.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
      const s = qt(this.color, [0, 0, 0]), r = n.get("CA"), o = oi(n.getArray("IC"), null), c = qt(o), l = c ? r : null, h = this.borderStyle.width || 1, f = 2 * h, d = [this.data.lineCoordinates[0] - f, this.data.lineCoordinates[1] - f, this.data.lineCoordinates[2] + f, this.data.lineCoordinates[3] + f];
      Je.intersect(this.rectangle, d) || (this.rectangle = d), this._setDefaultAppearance({
        xref: a,
        extra: `${h} w`,
        strokeColor: s,
        fillColor: c,
        strokeAlpha: r,
        fillAlpha: l,
        pointsCallback: (u, x) => (u.push(`${i[0]} ${i[1]} m`, `${i[2]} ${i[3]} l`, "S"), [x[0] - h, x[7] - h, x[2] + h, x[3] + h])
      });
    }
  }
}
class k5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    if (this.data.annotationType = Mt.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, !this.appearance) {
      const i = qt(this.color, [0, 0, 0]), s = n.get("CA"), r = oi(n.getArray("IC"), null), o = qt(r), c = o ? s : null;
      if (this.borderStyle.width === 0 && !o)
        return;
      this._setDefaultAppearance({
        xref: a,
        extra: `${this.borderStyle.width} w`,
        strokeColor: i,
        fillColor: o,
        strokeAlpha: s,
        fillAlpha: c,
        pointsCallback: (l, h) => {
          const f = h[4] + this.borderStyle.width / 2, d = h[5] + this.borderStyle.width / 2, u = h[6] - h[4] - this.borderStyle.width, x = h[3] - h[7] - this.borderStyle.width;
          return l.push(`${f} ${d} ${u} ${x} re`), o ? l.push("B") : l.push("S"), [h[0], h[7], h[2], h[3]];
        }
      });
    }
  }
}
class A5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    if (this.data.annotationType = Mt.CIRCLE, !this.appearance) {
      const i = qt(this.color, [0, 0, 0]), s = n.get("CA"), r = oi(n.getArray("IC"), null), o = qt(r), c = o ? s : null;
      if (this.borderStyle.width === 0 && !o)
        return;
      const l = 4 / 3 * Math.tan(Math.PI / 8);
      this._setDefaultAppearance({
        xref: a,
        extra: `${this.borderStyle.width} w`,
        strokeColor: i,
        fillColor: o,
        strokeAlpha: s,
        fillAlpha: c,
        pointsCallback: (h, f) => {
          const d = f[0] + this.borderStyle.width / 2, u = f[1] - this.borderStyle.width / 2, x = f[6] - this.borderStyle.width / 2, g = f[7] + this.borderStyle.width / 2, p = d + (x - d) / 2, m = u + (g - u) / 2, b = (x - d) / 2 * l, y = (g - u) / 2 * l;
          return h.push(`${p} ${g} m`, `${p + b} ${g} ${x} ${m + y} ${x} ${m} c`, `${x} ${m - y} ${p + b} ${u} ${p} ${u} c`, `${p - b} ${u} ${d} ${m - y} ${d} ${m} c`, `${d} ${m + y} ${p - b} ${g} ${p} ${g} c`, "h"), o ? h.push("B") : h.push("S"), [f[0], f[7], f[2], f[3]];
        }
      });
    }
  }
}
class Oh extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    this.data.annotationType = Mt.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.vertices = null, this instanceof Bh || (this.setLineEndings(n.getArray("LE")), this.data.lineEndings = this.lineEndings);
    const i = n.getArray("Vertices");
    if (!an(i, null))
      return;
    const s = this.data.vertices = Float32Array.from(i);
    if (!this.appearance) {
      const r = qt(this.color, [0, 0, 0]), o = n.get("CA");
      let c = oi(n.getArray("IC"), null);
      c && (c = qt(c));
      let l;
      c ? this.color ? l = c.every((u, x) => u === r[x]) ? "f" : "B" : l = "f" : l = "S";
      const h = this.borderStyle.width || 1, f = 2 * h, d = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let u = 0, x = s.length; u < x; u += 2)
        Je.rectBoundingBox(s[u] - f, s[u + 1] - f, s[u] + f, s[u + 1] + f, d);
      Je.intersect(this.rectangle, d) || (this.rectangle = d), this._setDefaultAppearance({
        xref: a,
        extra: `${h} w`,
        strokeColor: r,
        strokeAlpha: o,
        fillColor: c,
        fillAlpha: c ? o : null,
        pointsCallback: (u, x) => {
          for (let g = 0, p = s.length; g < p; g += 2)
            u.push(`${s[g]} ${s[g + 1]} ${g === 0 ? "m" : "l"}`);
          return u.push(l), [x[0], x[7], x[2], x[3]];
        }
      });
    }
  }
}
class Bh extends Oh {
  constructor(e) {
    super(e), this.data.annotationType = Mt.POLYGON;
  }
}
class C5 extends mn {
  constructor(e) {
    super(e), this.data.annotationType = Mt.CARET;
  }
}
class fs extends mn {
  constructor(e) {
    super(e), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const {
      dict: n,
      xref: a
    } = e;
    this.data.annotationType = Mt.INK, this.data.inkLists = [], this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = n.get("CA") || 1;
    const i = n.getArray("InkList");
    if (Array.isArray(i)) {
      for (let s = 0, r = i.length; s < r; ++s) {
        if (!Array.isArray(i[s]))
          continue;
        const o = new Float32Array(i[s].length);
        this.data.inkLists.push(o);
        for (let c = 0, l = i[s].length; c < l; c += 2) {
          const h = a.fetchIfRef(i[s][c]), f = a.fetchIfRef(i[s][c + 1]);
          typeof h == "number" && typeof f == "number" && (o[c] = h, o[c + 1] = f);
        }
      }
      if (!this.appearance) {
        const s = qt(this.color, [0, 0, 0]), r = n.get("CA"), o = this.borderStyle.width || 1, c = 2 * o, l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const h of this.data.inkLists)
          for (let f = 0, d = h.length; f < d; f += 2)
            Je.rectBoundingBox(h[f] - c, h[f + 1] - c, h[f] + c, h[f + 1] + c, l);
        Je.intersect(this.rectangle, l) || (this.rectangle = l), this._setDefaultAppearance({
          xref: a,
          extra: `${o} w`,
          strokeColor: s,
          strokeAlpha: r,
          pointsCallback: (h, f) => {
            for (const d of this.data.inkLists) {
              for (let u = 0, x = d.length; u < x; u += 2)
                h.push(`${d[u]} ${d[u + 1]} ${u === 0 ? "m" : "l"}`);
              h.push("S");
            }
            return [f[0], f[7], f[2], f[3]];
          }
        });
      }
    }
  }
  static createNewDict(e, n, {
    apRef: a,
    ap: i
  }) {
    const {
      oldAnnotation: s,
      color: r,
      date: o,
      opacity: c,
      paths: l,
      outlines: h,
      rect: f,
      rotation: d,
      thickness: u,
      user: x
    } = e, g = s || new B(n);
    if (g.setIfNotExists("Type", Z.get("Annot")), g.setIfNotExists("Subtype", Z.get("Ink")), g.set(s ? "M" : "CreationDate", `D:${ci(o)}`), g.setIfArray("Rect", f), g.setIfArray("InkList", h?.points || l?.points), g.setIfNotExists("F", 4), g.setIfNumber("Rotate", d), g.setIfDefined("T", kn(x)), h && g.setIfName("IT", "InkHighlight"), u > 0) {
      const p = new B(n);
      g.set("BS", p), p.set("W", u);
    }
    if (g.setIfArray("C", qt(r)), g.setIfNumber("CA", c), i || a) {
      const p = new B(n);
      g.set("AP", p), p.set("N", a || i);
    }
    return g;
  }
  static async createNewAppearanceStream(e, n, a) {
    if (e.outlines)
      return this.createNewAppearanceStreamForHighlight(e, n, a);
    const {
      color: i,
      rect: s,
      paths: r,
      thickness: o,
      opacity: c
    } = e;
    if (!i)
      return null;
    const l = [`${o} w 1 J 1 j`, `${aa(i, !1)}`];
    c !== 1 && l.push("/R0 gs");
    for (const u of r.lines) {
      l.push(`${ze(u[4])} ${ze(u[5])} m`);
      for (let x = 6, g = u.length; x < g; x += 6)
        if (isNaN(u[x]))
          l.push(`${ze(u[x + 4])} ${ze(u[x + 5])} l`);
        else {
          const [p, m, b, y, w, S] = u.slice(x, x + 6);
          l.push([p, m, b, y, w, S].map(ze).join(" ") + " c");
        }
      u.length === 6 && l.push(`${ze(u[4])} ${ze(u[5])} l`);
    }
    l.push("S");
    const h = l.join(`
`), f = new B(n);
    if (f.set("FormType", 1), f.setIfName("Subtype", "Form"), f.setIfName("Type", "XObject"), f.set("BBox", s), f.set("Length", h.length), c !== 1) {
      const u = new B(n), x = new B(n), g = new B(n);
      g.set("CA", c), g.setIfName("Type", "ExtGState"), x.set("R0", g), u.set("ExtGState", x), f.set("Resources", u);
    }
    const d = new rn(h);
    return d.dict = f, d;
  }
  static async createNewAppearanceStreamForHighlight(e, n, a) {
    const {
      color: i,
      rect: s,
      outlines: {
        outline: r
      },
      opacity: o
    } = e;
    if (!i)
      return null;
    const c = [`${aa(i, !0)}`, "/R0 gs"];
    c.push(`${ze(r[4])} ${ze(r[5])} m`);
    for (let g = 6, p = r.length; g < p; g += 6)
      if (isNaN(r[g]))
        c.push(`${ze(r[g + 4])} ${ze(r[g + 5])} l`);
      else {
        const [m, b, y, w, S, v] = r.slice(g, g + 6);
        c.push([m, b, y, w, S, v].map(ze).join(" ") + " c");
      }
    c.push("h f");
    const l = c.join(`
`), h = new B(n);
    h.set("FormType", 1), h.setIfName("Subtype", "Form"), h.setIfName("Type", "XObject"), h.set("BBox", s), h.set("Length", l.length);
    const f = new B(n), d = new B(n);
    f.set("ExtGState", d), h.set("Resources", f);
    const u = new B(n);
    d.set("R0", u), u.setIfName("BM", "Multiply"), o !== 1 && (u.set("ca", o), u.setIfName("Type", "ExtGState"));
    const x = new rn(l);
    return x.dict = h, x;
  }
}
class V0 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    if (this.data.annotationType = Mt.HIGHLIGHT, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = n.get("CA") || 1, this.data.quadPoints = Zs(n, null)) {
      const s = this.appearance?.dict.get("Resources");
      if (!this.appearance || !s?.has("ExtGState")) {
        this.appearance && F("HighlightAnnotation - ignoring built-in appearance stream.");
        const r = qt(this.color, [1, 1, 0]), o = n.get("CA");
        this._setDefaultAppearance({
          xref: a,
          fillColor: r,
          blendMode: "Multiply",
          fillAlpha: o,
          pointsCallback: (c, l) => (c.push(`${l[0]} ${l[1]} m`, `${l[2]} ${l[3]} l`, `${l[6]} ${l[7]} l`, `${l[4]} ${l[5]} l`, "f"), [l[0], l[7], l[2], l[3]])
        });
      }
    } else
      this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return !0;
  }
  static createNewDict(e, n, {
    apRef: a,
    ap: i
  }) {
    const {
      color: s,
      date: r,
      oldAnnotation: o,
      opacity: c,
      rect: l,
      rotation: h,
      user: f,
      quadPoints: d
    } = e, u = o || new B(n);
    if (u.setIfNotExists("Type", Z.get("Annot")), u.setIfNotExists("Subtype", Z.get("Highlight")), u.set(o ? "M" : "CreationDate", `D:${ci(r)}`), u.setIfArray("Rect", l), u.setIfNotExists("F", 4), u.setIfNotExists("Border", [0, 0, 0]), u.setIfNumber("Rotate", h), u.setIfArray("QuadPoints", d), u.setIfArray("C", qt(s)), u.setIfNumber("CA", c), u.setIfDefined("T", kn(f)), a || i) {
      const x = new B(n);
      u.set("AP", x), x.set("N", a || i);
    }
    return u;
  }
  static async createNewAppearanceStream(e, n, a) {
    const {
      color: i,
      rect: s,
      outlines: r,
      opacity: o
    } = e;
    if (!i)
      return null;
    const c = [`${aa(i, !0)}`, "/R0 gs"], l = [];
    for (const p of r) {
      l.length = 0, l.push(`${ze(p[0])} ${ze(p[1])} m`);
      for (let m = 2, b = p.length; m < b; m += 2)
        l.push(`${ze(p[m])} ${ze(p[m + 1])} l`);
      l.push("h"), c.push(l.join(`
`));
    }
    c.push("f*");
    const h = c.join(`
`), f = new B(n);
    f.set("FormType", 1), f.setIfName("Subtype", "Form"), f.setIfName("Type", "XObject"), f.set("BBox", s), f.set("Length", h.length);
    const d = new B(n), u = new B(n);
    d.set("ExtGState", u), f.set("Resources", d);
    const x = new B(n);
    u.set("R0", x), x.setIfName("BM", "Multiply"), o !== 1 && (x.set("ca", o), x.setIfName("Type", "ExtGState"));
    const g = new rn(h);
    return g.dict = f, g;
  }
}
class I5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    if (this.data.annotationType = Mt.UNDERLINE, this.data.quadPoints = Zs(n, null)) {
      if (!this.appearance) {
        const s = qt(this.color, [0, 0, 0]), r = n.get("CA");
        this._setDefaultAppearance({
          xref: a,
          extra: "[] 0 d 0.571 w",
          strokeColor: s,
          strokeAlpha: r,
          pointsCallback: (o, c) => (o.push(`${c[4]} ${c[5] + 1.3} m`, `${c[6]} ${c[7] + 1.3} l`, "S"), [c[0], c[7], c[2], c[3]])
        });
      }
    } else
      this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return !0;
  }
}
class T5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    if (this.data.annotationType = Mt.SQUIGGLY, this.data.quadPoints = Zs(n, null)) {
      if (!this.appearance) {
        const s = qt(this.color, [0, 0, 0]), r = n.get("CA");
        this._setDefaultAppearance({
          xref: a,
          extra: "[] 0 d 1 w",
          strokeColor: s,
          strokeAlpha: r,
          pointsCallback: (o, c) => {
            const l = (c[1] - c[5]) / 6;
            let h = l, f = c[4];
            const d = c[5], u = c[6];
            o.push(`${f} ${d + h} m`);
            do
              f += 2, h = h === 0 ? l : 0, o.push(`${f} ${d + h} l`);
            while (f < u);
            return o.push("S"), [c[4], d - 2 * l, u, d + 2 * l];
          }
        });
      }
    } else
      this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return !0;
  }
}
class E5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e;
    if (this.data.annotationType = Mt.STRIKEOUT, this.data.quadPoints = Zs(n, null)) {
      if (!this.appearance) {
        const s = qt(this.color, [0, 0, 0]), r = n.get("CA");
        this._setDefaultAppearance({
          xref: a,
          extra: "[] 0 d 1 w",
          strokeColor: s,
          strokeAlpha: r,
          pointsCallback: (o, c) => (o.push(`${(c[0] + c[4]) / 2} ${(c[1] + c[5]) / 2} m`, `${(c[2] + c[6]) / 2} ${(c[3] + c[7]) / 2} l`, "S"), [c[0], c[7], c[2], c[3]])
        });
      }
    } else
      this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return !0;
  }
}
class Si extends mn {
  #e = null;
  constructor(e) {
    super(e), this.data.annotationType = Mt.STAMP, this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
  }
  mustBeViewedWhenEditing(e, n = null) {
    return e ? (this.data.isEditable && (this.#e ??= this.data.hasOwnCanvas, this.data.hasOwnCanvas = !0), !0) : (this.#e !== null && (this.data.hasOwnCanvas = this.#e, this.#e = null), !n?.has(this.data.id));
  }
  static async createImage(e, n) {
    const {
      width: a,
      height: i
    } = e, s = new OffscreenCanvas(a, i), r = s.getContext("2d", {
      alpha: !0
    });
    r.drawImage(e, 0, 0);
    const o = r.getImageData(0, 0, a, i).data, c = new Uint32Array(o.buffer), l = c.some(gn.isLittleEndian ? (p) => p >>> 24 !== 255 : (p) => (p & 255) !== 255);
    l && (r.fillStyle = "white", r.fillRect(0, 0, a, i), r.drawImage(e, 0, 0));
    const h = s.convertToBlob({
      type: "image/jpeg",
      quality: 1
    }).then((p) => p.arrayBuffer()), f = Z.get("XObject"), d = Z.get("Image"), u = new B(n);
    u.set("Type", f), u.set("Subtype", d), u.set("BitsPerComponent", 8), u.setIfName("ColorSpace", "DeviceRGB"), u.setIfName("Filter", "DCTDecode"), u.set("BBox", [0, 0, a, i]), u.set("Width", a), u.set("Height", i);
    let x = null;
    if (l) {
      const p = new Uint8Array(c.length);
      if (gn.isLittleEndian)
        for (let b = 0, y = c.length; b < y; b++)
          p[b] = c[b] >>> 24;
      else
        for (let b = 0, y = c.length; b < y; b++)
          p[b] = c[b] & 255;
      const m = new B(n);
      m.set("Type", f), m.set("Subtype", d), m.set("BitsPerComponent", 8), m.setIfName("ColorSpace", "DeviceGray"), m.set("Width", a), m.set("Height", i), x = new pt(p, 0, 0, m);
    }
    return {
      imageStream: new pt(await h, 0, 0, u),
      smaskStream: x,
      width: a,
      height: i
    };
  }
  static createNewDict(e, n, {
    apRef: a,
    ap: i
  }) {
    const {
      date: s,
      oldAnnotation: r,
      rect: o,
      rotation: c,
      user: l
    } = e, h = r || new B(n);
    if (h.setIfNotExists("Type", Z.get("Annot")), h.setIfNotExists("Subtype", Z.get("Stamp")), h.set(r ? "M" : "CreationDate", `D:${ci(s)}`), h.setIfArray("Rect", o), h.setIfNotExists("F", 4), h.setIfNotExists("Border", [0, 0, 0]), h.setIfNumber("Rotate", c), h.setIfDefined("T", kn(l)), a || i) {
      const f = new B(n);
      h.set("AP", f), f.set("N", a || i);
    }
    return h;
  }
  static async #t(e, n) {
    const {
      areContours: a,
      color: i,
      rect: s,
      lines: r,
      thickness: o
    } = e;
    if (!i)
      return null;
    const c = [`${o} w 1 J 1 j`, `${aa(i, a)}`];
    for (const d of r) {
      c.push(`${ze(d[4])} ${ze(d[5])} m`);
      for (let u = 6, x = d.length; u < x; u += 6)
        if (isNaN(d[u]))
          c.push(`${ze(d[u + 4])} ${ze(d[u + 5])} l`);
        else {
          const [g, p, m, b, y, w] = d.slice(u, u + 6);
          c.push([g, p, m, b, y, w].map(ze).join(" ") + " c");
        }
      d.length === 6 && c.push(`${ze(d[4])} ${ze(d[5])} l`);
    }
    c.push(a ? "F" : "S");
    const l = c.join(`
`), h = new B(n);
    h.set("FormType", 1), h.setIfName("Subtype", "Form"), h.setIfName("Type", "XObject"), h.set("BBox", s), h.set("Length", l.length);
    const f = new rn(l);
    return f.dict = h, f;
  }
  static async createNewAppearanceStream(e, n, a) {
    if (e.oldAnnotation)
      return null;
    if (e.isSignature)
      return this.#t(e, n);
    const {
      rotation: i
    } = e, {
      imageRef: s,
      width: r,
      height: o
    } = a.image, c = new B(n), l = new B(n);
    c.set("XObject", l), l.set("Im0", s);
    const h = `q ${r} 0 0 ${o} 0 0 cm /Im0 Do Q`, f = new B(n);
    if (f.set("FormType", 1), f.setIfName("Subtype", "Form"), f.setIfName("Type", "XObject"), f.set("BBox", [0, 0, r, o]), f.set("Resources", c), i) {
      const u = Ur(i, r, o);
      f.set("Matrix", u);
    }
    const d = new rn(h);
    return d.dict = f, d;
  }
}
class F5 extends mn {
  constructor(e) {
    super(e);
    const {
      dict: n,
      xref: a
    } = e, i = new yo(n.get("FS"), a);
    this.data.annotationType = Mt.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.file = i.serializable;
    const s = n.get("Name");
    this.data.name = s instanceof Z ? Ve(s.name) : "PushPin";
    const r = n.get("ca");
    this.data.fillAlpha = typeof r == "number" && r >= 0 && r <= 1 ? r : null;
  }
}
const R5 = {
  get r() {
    return ae(this, "r", new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]));
  },
  get k() {
    return ae(this, "k", new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]));
  }
};
function Ia(t, e, n) {
  let a = 1732584193, i = -271733879, s = -1732584194, r = 271733878;
  const o = n + 72 & -64, c = new Uint8Array(o);
  let l, h;
  for (l = 0; l < n; ++l)
    c[l] = t[e++];
  c[l++] = 128;
  const f = o - 8;
  l < f && (l = f), c[l++] = n << 3 & 255, c[l++] = n >> 5 & 255, c[l++] = n >> 13 & 255, c[l++] = n >> 21 & 255, c[l++] = n >>> 29 & 255, l += 3;
  const d = new Int32Array(16), {
    k: u,
    r: x
  } = R5;
  for (l = 0; l < o; ) {
    for (h = 0; h < 16; ++h, l += 4)
      d[h] = c[l] | c[l + 1] << 8 | c[l + 2] << 16 | c[l + 3] << 24;
    let g = a, p = i, m = s, b = r, y, w;
    for (h = 0; h < 64; ++h) {
      h < 16 ? (y = p & m | ~p & b, w = h) : h < 32 ? (y = b & p | ~b & m, w = 5 * h + 1 & 15) : h < 48 ? (y = p ^ m ^ b, w = 3 * h + 5 & 15) : (y = m ^ (p | ~b), w = 7 * h & 15);
      const S = b, v = g + y + u[h] + d[w] | 0, k = x[h];
      b = m, m = p, p = p + (v << k | v >>> 32 - k) | 0, g = S;
    }
    a = a + g | 0, i = i + p | 0, s = s + m | 0, r = r + b | 0;
  }
  return new Uint8Array([a & 255, a >> 8 & 255, a >> 16 & 255, a >>> 24 & 255, i & 255, i >> 8 & 255, i >> 16 & 255, i >>> 24 & 255, s & 255, s >> 8 & 255, s >> 16 & 255, s >>> 24 & 255, r & 255, r >> 8 & 255, r >> 16 & 255, r >>> 24 & 255]);
}
function _l(t) {
  try {
    return Es(t);
  } catch (e) {
    return F(`UTF-8 decoding failed: "${e}".`), t;
  }
}
class O5 extends o0 {
  constructor(e) {
    super(e), this.node = null;
  }
  onEndElement(e) {
    const n = super.onEndElement(e);
    if (n && e === "xfa:datasets")
      throw this.node = n, new Error("Aborting DatasetXMLParser.");
  }
}
class B5 {
  constructor(e) {
    if (e.datasets)
      this.node = new o0({
        hasAttributes: !0
      }).parseFromString(e.datasets).documentElement;
    else {
      const n = new O5({
        hasAttributes: !0
      });
      try {
        n.parseFromString(e["xdp:xdp"]);
      } catch {
      }
      this.node = n.node;
    }
  }
  getValue(e) {
    if (!this.node || !e)
      return "";
    const n = this.node.searchNode(c1(e), 0);
    return n ? n.firstChild?.nodeName === "value" ? n.children.map((i) => _l(i.textContent)) : _l(n.textContent) : "";
  }
}
class M5 {
  #e;
  #t = 1 / 0;
  #n = 1 / 0;
  #a = -1 / 0;
  #s = -1 / 0;
  #r = null;
  #c = [];
  #i = [];
  #o = -1;
  #l = !1;
  constructor(e) {
    this.#e = e;
    const n = e.data.quadPoints;
    if (!n) {
      [this.#t, this.#n, this.#a, this.#s] = e.data.rect;
      return;
    }
    for (let a = 0, i = n.length; a < i; a += 8)
      this.#t = Math.min(this.#t, n[a]), this.#a = Math.max(this.#a, n[a + 2]), this.#n = Math.min(this.#n, n[a + 5]), this.#s = Math.max(this.#s, n[a + 1]);
    n.length > 8 && (this.#r = n);
  }
  overlaps(e) {
    return !(this.#t >= e.#a || this.#a <= e.#t || this.#n >= e.#s || this.#s <= e.#n);
  }
  #h(e, n) {
    if (this.#t >= e || this.#a <= e || this.#n >= n || this.#s <= n)
      return !1;
    const a = this.#r;
    if (!a)
      return !0;
    if (this.#o >= 0) {
      const i = this.#o;
      if (!(a[i] >= e || a[i + 2] <= e || a[i + 5] >= n || a[i + 1] <= n))
        return !0;
      this.#o = -1;
    }
    for (let i = 0, s = a.length; i < s; i += 8)
      if (!(a[i] >= e || a[i + 2] <= e || a[i + 5] >= n || a[i + 1] <= n))
        return this.#o = i, !0;
    return !1;
  }
  addGlyph(e, n, a) {
    return this.#h(e, n) ? (this.#i.length > 0 && (this.#c.push(this.#i.join("")), this.#i.length = 0), this.#c.push(a), this.#l = !0, !0) : (this.disableExtraChars(), !1);
  }
  addExtraChar(e) {
    this.#l && this.#i.push(e);
  }
  disableExtraChars() {
    this.#l && (this.#l = !1, this.#i.length = 0);
  }
  setText() {
    this.#e.data.overlaidText = this.#c.join("");
  }
}
class P5 {
  #e = /* @__PURE__ */ new Map();
  constructor(e) {
    for (const n of e) {
      if (!n.data.quadPoints && !n.data.rect)
        continue;
      const a = new M5(n);
      for (const [i, s] of this.#e)
        i.overlaps(a) && (s ? s.add(a) : this.#e.set(i, /* @__PURE__ */ new Set([a])));
      this.#e.set(a, null);
    }
  }
  addGlyph(e, n, a, i) {
    const s = e[4] + n / 2, r = e[5] + a / 2;
    let o;
    for (const [c, l] of this.#e) {
      if (o) {
        o.has(c) ? c.addGlyph(s, r, i) : c.disableExtraChars();
        continue;
      }
      c.addGlyph(s, r, i) && (o = l);
    }
  }
  addExtraChar(e) {
    for (const n of this.#e.keys())
      n.addExtraChar(e);
  }
  setText() {
    for (const e of this.#e.keys())
      e.setText();
  }
}
class oe {
  constructor(e, n) {
    this.high = e | 0, this.low = n | 0;
  }
  and(e) {
    this.high &= e.high, this.low &= e.low;
  }
  xor(e) {
    this.high ^= e.high, this.low ^= e.low;
  }
  shiftRight(e) {
    e >= 32 ? (this.low = this.high >>> e - 32 | 0, this.high = 0) : (this.low = this.low >>> e | this.high << 32 - e, this.high = this.high >>> e | 0);
  }
  rotateRight(e) {
    let n, a;
    e & 32 ? (a = this.low, n = this.high) : (n = this.low, a = this.high), e &= 31, this.low = n >>> e | a << 32 - e, this.high = a >>> e | n << 32 - e;
  }
  not() {
    this.high = ~this.high, this.low = ~this.low;
  }
  add(e) {
    const n = (this.low >>> 0) + (e.low >>> 0);
    let a = (this.high >>> 0) + (e.high >>> 0);
    n > 4294967295 && (a += 1), this.low = n | 0, this.high = a | 0;
  }
  copyTo(e, n) {
    e[n] = this.high >>> 24 & 255, e[n + 1] = this.high >> 16 & 255, e[n + 2] = this.high >> 8 & 255, e[n + 3] = this.high & 255, e[n + 4] = this.low >>> 24 & 255, e[n + 5] = this.low >> 16 & 255, e[n + 6] = this.low >> 8 & 255, e[n + 7] = this.low & 255;
  }
  assign(e) {
    this.high = e.high, this.low = e.low;
  }
}
const N5 = {
  get k() {
    return ae(this, "k", [new oe(1116352408, 3609767458), new oe(1899447441, 602891725), new oe(3049323471, 3964484399), new oe(3921009573, 2173295548), new oe(961987163, 4081628472), new oe(1508970993, 3053834265), new oe(2453635748, 2937671579), new oe(2870763221, 3664609560), new oe(3624381080, 2734883394), new oe(310598401, 1164996542), new oe(607225278, 1323610764), new oe(1426881987, 3590304994), new oe(1925078388, 4068182383), new oe(2162078206, 991336113), new oe(2614888103, 633803317), new oe(3248222580, 3479774868), new oe(3835390401, 2666613458), new oe(4022224774, 944711139), new oe(264347078, 2341262773), new oe(604807628, 2007800933), new oe(770255983, 1495990901), new oe(1249150122, 1856431235), new oe(1555081692, 3175218132), new oe(1996064986, 2198950837), new oe(2554220882, 3999719339), new oe(2821834349, 766784016), new oe(2952996808, 2566594879), new oe(3210313671, 3203337956), new oe(3336571891, 1034457026), new oe(3584528711, 2466948901), new oe(113926993, 3758326383), new oe(338241895, 168717936), new oe(666307205, 1188179964), new oe(773529912, 1546045734), new oe(1294757372, 1522805485), new oe(1396182291, 2643833823), new oe(1695183700, 2343527390), new oe(1986661051, 1014477480), new oe(2177026350, 1206759142), new oe(2456956037, 344077627), new oe(2730485921, 1290863460), new oe(2820302411, 3158454273), new oe(3259730800, 3505952657), new oe(3345764771, 106217008), new oe(3516065817, 3606008344), new oe(3600352804, 1432725776), new oe(4094571909, 1467031594), new oe(275423344, 851169720), new oe(430227734, 3100823752), new oe(506948616, 1363258195), new oe(659060556, 3750685593), new oe(883997877, 3785050280), new oe(958139571, 3318307427), new oe(1322822218, 3812723403), new oe(1537002063, 2003034995), new oe(1747873779, 3602036899), new oe(1955562222, 1575990012), new oe(2024104815, 1125592928), new oe(2227730452, 2716904306), new oe(2361852424, 442776044), new oe(2428436474, 593698344), new oe(2756734187, 3733110249), new oe(3204031479, 2999351573), new oe(3329325298, 3815920427), new oe(3391569614, 3928383900), new oe(3515267271, 566280711), new oe(3940187606, 3454069534), new oe(4118630271, 4000239992), new oe(116418474, 1914138554), new oe(174292421, 2731055270), new oe(289380356, 3203993006), new oe(460393269, 320620315), new oe(685471733, 587496836), new oe(852142971, 1086792851), new oe(1017036298, 365543100), new oe(1126000580, 2618297676), new oe(1288033470, 3409855158), new oe(1501505948, 4234509866), new oe(1607167915, 987167468), new oe(1816402316, 1246189591)]);
  }
};
function D5(t, e, n, a, i) {
  t.assign(e), t.and(n), i.assign(e), i.not(), i.and(a), t.xor(i);
}
function L5(t, e, n, a, i) {
  t.assign(e), t.and(n), i.assign(e), i.and(a), t.xor(i), i.assign(n), i.and(a), t.xor(i);
}
function U5(t, e, n) {
  t.assign(e), t.rotateRight(28), n.assign(e), n.rotateRight(34), t.xor(n), n.assign(e), n.rotateRight(39), t.xor(n);
}
function j5(t, e, n) {
  t.assign(e), t.rotateRight(14), n.assign(e), n.rotateRight(18), t.xor(n), n.assign(e), n.rotateRight(41), t.xor(n);
}
function H5(t, e, n) {
  t.assign(e), t.rotateRight(1), n.assign(e), n.rotateRight(8), t.xor(n), n.assign(e), n.shiftRight(7), t.xor(n);
}
function $5(t, e, n) {
  t.assign(e), t.rotateRight(19), n.assign(e), n.rotateRight(61), t.xor(n), n.assign(e), n.shiftRight(6), t.xor(n);
}
function Mh(t, e, n, a = !1) {
  let i, s, r, o, c, l, h, f;
  a ? (i = new oe(3418070365, 3238371032), s = new oe(1654270250, 914150663), r = new oe(2438529370, 812702999), o = new oe(355462360, 4144912697), c = new oe(1731405415, 4290775857), l = new oe(2394180231, 1750603025), h = new oe(3675008525, 1694076839), f = new oe(1203062813, 3204075428)) : (i = new oe(1779033703, 4089235720), s = new oe(3144134277, 2227873595), r = new oe(1013904242, 4271175723), o = new oe(2773480762, 1595750129), c = new oe(1359893119, 2917565137), l = new oe(2600822924, 725511199), h = new oe(528734635, 4215389547), f = new oe(1541459225, 327033209));
  const d = Math.ceil((n + 17) / 128) * 128, u = new Uint8Array(d);
  let x, g;
  for (x = 0; x < n; ++x)
    u[x] = t[e++];
  u[x++] = 128;
  const p = d - 16;
  x < p && (x = p), x += 11, u[x++] = n >>> 29 & 255, u[x++] = n >> 21 & 255, u[x++] = n >> 13 & 255, u[x++] = n >> 5 & 255, u[x++] = n << 3 & 255;
  const m = new Array(80);
  for (x = 0; x < 80; x++)
    m[x] = new oe(0, 0);
  const {
    k: b
  } = N5;
  let y = new oe(0, 0), w = new oe(0, 0), S = new oe(0, 0), v = new oe(0, 0), k = new oe(0, 0), A = new oe(0, 0), C = new oe(0, 0), T = new oe(0, 0);
  const M = new oe(0, 0), O = new oe(0, 0), N = new oe(0, 0), H = new oe(0, 0);
  let J;
  for (x = 0; x < d; ) {
    for (g = 0; g < 16; ++g)
      m[g].high = u[x] << 24 | u[x + 1] << 16 | u[x + 2] << 8 | u[x + 3], m[g].low = u[x + 4] << 24 | u[x + 5] << 16 | u[x + 6] << 8 | u[x + 7], x += 8;
    for (g = 16; g < 80; ++g)
      J = m[g], $5(J, m[g - 2], H), J.add(m[g - 7]), H5(N, m[g - 15], H), J.add(N), J.add(m[g - 16]);
    for (y.assign(i), w.assign(s), S.assign(r), v.assign(o), k.assign(c), A.assign(l), C.assign(h), T.assign(f), g = 0; g < 80; ++g)
      M.assign(T), j5(N, k, H), M.add(N), D5(N, k, A, C, H), M.add(N), M.add(b[g]), M.add(m[g]), U5(O, y, H), L5(N, y, w, S, H), O.add(N), J = T, T = C, C = A, A = k, v.add(M), k = v, v = S, S = w, w = y, J.assign(M), J.add(O), y = J;
    i.add(y), s.add(w), r.add(S), o.add(v), c.add(k), l.add(A), h.add(C), f.add(T);
  }
  let U;
  return a ? (U = new Uint8Array(48), i.copyTo(U, 0), s.copyTo(U, 8), r.copyTo(U, 16), o.copyTo(U, 24), c.copyTo(U, 32), l.copyTo(U, 40)) : (U = new Uint8Array(64), i.copyTo(U, 0), s.copyTo(U, 8), r.copyTo(U, 16), o.copyTo(U, 24), c.copyTo(U, 32), l.copyTo(U, 40), h.copyTo(U, 48), f.copyTo(U, 56)), U;
}
function G5(t, e, n) {
  return Mh(t, e, n, !0);
}
const z5 = {
  get k() {
    return ae(this, "k", [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
  }
};
function na(t, e) {
  return t >>> e | t << 32 - e;
}
function _5(t, e, n) {
  return t & e ^ ~t & n;
}
function W5(t, e, n) {
  return t & e ^ t & n ^ e & n;
}
function V5(t) {
  return na(t, 2) ^ na(t, 13) ^ na(t, 22);
}
function X5(t) {
  return na(t, 6) ^ na(t, 11) ^ na(t, 25);
}
function q5(t) {
  return na(t, 7) ^ na(t, 18) ^ t >>> 3;
}
function K5(t) {
  return na(t, 17) ^ na(t, 19) ^ t >>> 10;
}
function Ro(t, e, n) {
  let a = 1779033703, i = 3144134277, s = 1013904242, r = 2773480762, o = 1359893119, c = 2600822924, l = 528734635, h = 1541459225;
  const f = Math.ceil((n + 9) / 64) * 64, d = new Uint8Array(f);
  let u, x;
  for (u = 0; u < n; ++u)
    d[u] = t[e++];
  d[u++] = 128;
  const g = f - 8;
  u < g && (u = g), u += 3, d[u++] = n >>> 29 & 255, d[u++] = n >> 21 & 255, d[u++] = n >> 13 & 255, d[u++] = n >> 5 & 255, d[u++] = n << 3 & 255;
  const p = new Uint32Array(64), {
    k: m
  } = z5;
  for (u = 0; u < f; ) {
    for (x = 0; x < 16; ++x)
      p[x] = d[u] << 24 | d[u + 1] << 16 | d[u + 2] << 8 | d[u + 3], u += 4;
    for (x = 16; x < 64; ++x)
      p[x] = K5(p[x - 2]) + p[x - 7] + q5(p[x - 15]) + p[x - 16] | 0;
    let b = a, y = i, w = s, S = r, v = o, k = c, A = l, C = h, T, M;
    for (x = 0; x < 64; ++x)
      T = C + X5(v) + _5(v, k, A) + m[x] + p[x], M = V5(b) + W5(b, y, w), C = A, A = k, k = v, v = S + T | 0, S = w, w = y, y = b, b = T + M | 0;
    a = a + b | 0, i = i + y | 0, s = s + w | 0, r = r + S | 0, o = o + v | 0, c = c + k | 0, l = l + A | 0, h = h + C | 0;
  }
  return new Uint8Array([a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, r & 255, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, o & 255, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, c & 255, l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, l & 255, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, h & 255]);
}
const Wl = 512;
class Y5 extends on {
  constructor(e, n, a) {
    super(n), this.str = e, this.dict = e.dict, this.decrypt = a, this.nextChunk = null, this.initialized = !1;
  }
  readBlock() {
    let e;
    if (this.initialized ? e = this.nextChunk : (e = this.str.getBytes(Wl), this.initialized = !0), !e?.length) {
      this.eof = !0;
      return;
    }
    this.nextChunk = this.str.getBytes(Wl);
    const n = this.nextChunk?.length > 0, a = this.decrypt;
    e = a(e, !n);
    const i = this.bufferLength, s = i + e.length;
    this.ensureBuffer(s).set(e, i), this.bufferLength = s;
  }
}
class Xa {
  constructor(e) {
    this.a = 0, this.b = 0;
    const n = new Uint8Array(256), a = e.length;
    for (let i = 0; i < 256; ++i)
      n[i] = i;
    for (let i = 0, s = 0; i < 256; ++i) {
      const r = n[i];
      s = s + r + e[i % a] & 255, n[i] = n[s], n[s] = r;
    }
    this.s = n;
  }
  encryptBlock(e) {
    let n = this.a, a = this.b;
    const i = this.s, s = e.length, r = new Uint8Array(s);
    for (let o = 0; o < s; ++o) {
      n = n + 1 & 255;
      const c = i[n];
      a = a + c & 255;
      const l = i[a];
      i[n] = l, i[a] = c, r[o] = e[o] ^ i[c + l & 255];
    }
    return this.a = n, this.b = a, r;
  }
  decryptBlock(e) {
    return this.encryptBlock(e);
  }
  encrypt(e) {
    return this.encryptBlock(e);
  }
}
class J5 {
  decryptBlock(e) {
    return e;
  }
  encrypt(e) {
    return e;
  }
}
class xc {
  _s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
  _inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
  _mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
  _mixCol = new Uint8Array(256).map((e, n) => n < 128 ? n << 1 : n << 1 ^ 27);
  constructor() {
    this.buffer = new Uint8Array(16), this.bufferPosition = 0;
  }
  _expandKey(e) {
    _e("Cannot call `_expandKey` on the base class");
  }
  _decrypt(e, n) {
    let a, i, s;
    const r = new Uint8Array(16);
    r.set(e);
    for (let o = 0, c = this._keySize; o < 16; ++o, ++c)
      r[o] ^= n[c];
    for (let o = this._cyclesOfRepetition - 1; o >= 1; --o) {
      a = r[13], r[13] = r[9], r[9] = r[5], r[5] = r[1], r[1] = a, a = r[14], i = r[10], r[14] = r[6], r[10] = r[2], r[6] = a, r[2] = i, a = r[15], i = r[11], s = r[7], r[15] = r[3], r[11] = a, r[7] = i, r[3] = s;
      for (let c = 0; c < 16; ++c)
        r[c] = this._inv_s[r[c]];
      for (let c = 0, l = o * 16; c < 16; ++c, ++l)
        r[c] ^= n[l];
      for (let c = 0; c < 16; c += 4) {
        const l = this._mix[r[c]], h = this._mix[r[c + 1]], f = this._mix[r[c + 2]], d = this._mix[r[c + 3]];
        a = l ^ h >>> 8 ^ h << 24 ^ f >>> 16 ^ f << 16 ^ d >>> 24 ^ d << 8, r[c] = a >>> 24 & 255, r[c + 1] = a >> 16 & 255, r[c + 2] = a >> 8 & 255, r[c + 3] = a & 255;
      }
    }
    a = r[13], r[13] = r[9], r[9] = r[5], r[5] = r[1], r[1] = a, a = r[14], i = r[10], r[14] = r[6], r[10] = r[2], r[6] = a, r[2] = i, a = r[15], i = r[11], s = r[7], r[15] = r[3], r[11] = a, r[7] = i, r[3] = s;
    for (let o = 0; o < 16; ++o)
      r[o] = this._inv_s[r[o]], r[o] ^= n[o];
    return r;
  }
  _encrypt(e, n) {
    const a = this._s;
    let i, s, r;
    const o = new Uint8Array(16);
    o.set(e);
    for (let c = 0; c < 16; ++c)
      o[c] ^= n[c];
    for (let c = 1; c < this._cyclesOfRepetition; c++) {
      for (let l = 0; l < 16; ++l)
        o[l] = a[o[l]];
      r = o[1], o[1] = o[5], o[5] = o[9], o[9] = o[13], o[13] = r, r = o[2], s = o[6], o[2] = o[10], o[6] = o[14], o[10] = r, o[14] = s, r = o[3], s = o[7], i = o[11], o[3] = o[15], o[7] = r, o[11] = s, o[15] = i;
      for (let l = 0; l < 16; l += 4) {
        const h = o[l], f = o[l + 1], d = o[l + 2], u = o[l + 3];
        i = h ^ f ^ d ^ u, o[l] ^= i ^ this._mixCol[h ^ f], o[l + 1] ^= i ^ this._mixCol[f ^ d], o[l + 2] ^= i ^ this._mixCol[d ^ u], o[l + 3] ^= i ^ this._mixCol[u ^ h];
      }
      for (let l = 0, h = c * 16; l < 16; ++l, ++h)
        o[l] ^= n[h];
    }
    for (let c = 0; c < 16; ++c)
      o[c] = a[o[c]];
    r = o[1], o[1] = o[5], o[5] = o[9], o[9] = o[13], o[13] = r, r = o[2], s = o[6], o[2] = o[10], o[6] = o[14], o[10] = r, o[14] = s, r = o[3], s = o[7], i = o[11], o[3] = o[15], o[7] = r, o[11] = s, o[15] = i;
    for (let c = 0, l = this._keySize; c < 16; ++c, ++l)
      o[c] ^= n[l];
    return o;
  }
  _decryptBlock2(e, n) {
    const a = e.length;
    let i = this.buffer, s = this.bufferPosition;
    const r = [];
    let o = this.iv;
    for (let h = 0; h < a; ++h) {
      if (i[s] = e[h], ++s, s < 16)
        continue;
      const f = this._decrypt(i, this._key);
      for (let d = 0; d < 16; ++d)
        f[d] ^= o[d];
      o = i, r.push(f), i = new Uint8Array(16), s = 0;
    }
    if (this.buffer = i, this.bufferLength = s, this.iv = o, r.length === 0)
      return new Uint8Array(0);
    let c = 16 * r.length;
    if (n) {
      const h = r.at(-1);
      let f = h[15];
      if (f <= 16) {
        for (let d = 15, u = 16 - f; d >= u; --d)
          if (h[d] !== f) {
            f = 0;
            break;
          }
        c -= f, r[r.length - 1] = h.subarray(0, 16 - f);
      }
    }
    const l = new Uint8Array(c);
    for (let h = 0, f = 0, d = r.length; h < d; ++h, f += 16)
      l.set(r[h], f);
    return l;
  }
  decryptBlock(e, n, a = null) {
    const i = e.length, s = this.buffer;
    let r = this.bufferPosition;
    if (a)
      this.iv = a;
    else {
      for (let o = 0; r < 16 && o < i; ++o, ++r)
        s[r] = e[o];
      if (r < 16)
        return this.bufferLength = r, new Uint8Array(0);
      this.iv = s, e = e.subarray(16);
    }
    return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(e, n);
  }
  encrypt(e, n) {
    const a = e.length;
    let i = this.buffer, s = this.bufferPosition;
    const r = [];
    n ||= new Uint8Array(16);
    for (let l = 0; l < a; ++l) {
      if (i[s] = e[l], ++s, s < 16)
        continue;
      for (let f = 0; f < 16; ++f)
        i[f] ^= n[f];
      const h = this._encrypt(i, this._key);
      n = h, r.push(h), i = new Uint8Array(16), s = 0;
    }
    if (this.buffer = i, this.bufferLength = s, this.iv = n, r.length === 0)
      return new Uint8Array(0);
    const o = 16 * r.length, c = new Uint8Array(o);
    for (let l = 0, h = 0, f = r.length; l < f; ++l, h += 16)
      c.set(r[l], h);
    return c;
  }
}
class Ph extends xc {
  _rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
  constructor(e) {
    super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._key = this._expandKey(e);
  }
  _expandKey(e) {
    const a = this._s, i = this._rcon, s = new Uint8Array(176);
    s.set(e);
    for (let r = 16, o = 1; r < 176; ++o) {
      let c = s[r - 3], l = s[r - 2], h = s[r - 1], f = s[r - 4];
      c = a[c], l = a[l], h = a[h], f = a[f], c ^= i[o];
      for (let d = 0; d < 4; ++d)
        s[r] = c ^= s[r - 16], r++, s[r] = l ^= s[r - 16], r++, s[r] = h ^= s[r - 16], r++, s[r] = f ^= s[r - 16], r++;
    }
    return s;
  }
}
class Oo extends xc {
  constructor(e) {
    super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(e);
  }
  _expandKey(e) {
    const a = this._s, i = new Uint8Array(240);
    i.set(e);
    let s = 1, r, o, c, l;
    for (let h = 32, f = 1; h < 240; ++f) {
      h % 32 === 16 ? (r = a[r], o = a[o], c = a[c], l = a[l]) : h % 32 === 0 && (r = i[h - 3], o = i[h - 2], c = i[h - 1], l = i[h - 4], r = a[r], o = a[o], c = a[c], l = a[l], r ^= s, (s <<= 1) >= 256 && (s = (s ^ 27) & 255));
      for (let d = 0; d < 4; ++d)
        i[h] = r ^= i[h - 32], h++, i[h] = o ^= i[h - 32], h++, i[h] = c ^= i[h - 32], h++, i[h] = l ^= i[h - 32], h++;
    }
    return i;
  }
}
class Nh {
  _hash(e, n, a) {
    _e("Abstract method `_hash` called");
  }
  checkOwnerPassword(e, n, a, i) {
    const s = new Uint8Array(e.length + 56);
    s.set(e, 0), s.set(n, e.length), s.set(a, e.length + n.length);
    const r = this._hash(e, s, a);
    return Fs(r, i);
  }
  checkUserPassword(e, n, a) {
    const i = new Uint8Array(e.length + 8);
    i.set(e, 0), i.set(n, e.length);
    const s = this._hash(e, i, []);
    return Fs(s, a);
  }
  getOwnerKey(e, n, a, i) {
    const s = new Uint8Array(e.length + 56);
    s.set(e, 0), s.set(n, e.length), s.set(a, e.length + n.length);
    const r = this._hash(e, s, a);
    return new Oo(r).decryptBlock(i, !1, new Uint8Array(16));
  }
  getUserKey(e, n, a) {
    const i = new Uint8Array(e.length + 8);
    i.set(e, 0), i.set(n, e.length);
    const s = this._hash(e, i, []);
    return new Oo(s).decryptBlock(a, !1, new Uint8Array(16));
  }
}
class Z5 extends Nh {
  _hash(e, n, a) {
    return Ro(n, 0, n.length);
  }
}
class Q5 extends Nh {
  _hash(e, n, a) {
    let i = Ro(n, 0, n.length).subarray(0, 32), s = [0], r = 0;
    for (; r < 64 || s.at(-1) > r - 32; ) {
      const o = e.length + i.length + a.length, c = new Uint8Array(o);
      let l = 0;
      c.set(e, l), l += e.length, c.set(i, l), l += i.length, c.set(a, l);
      const h = new Uint8Array(o * 64);
      for (let u = 0, x = 0; u < 64; u++, x += o)
        h.set(c, x);
      s = new Ph(i.subarray(0, 16)).encrypt(h, i.subarray(16, 32));
      const d = Math.sumPrecise(s.slice(0, 16)) % 3;
      d === 0 ? i = Ro(s, 0, s.length) : d === 1 ? i = G5(s, 0, s.length) : d === 2 && (i = Mh(s, 0, s.length)), r++;
    }
    return i.subarray(0, 32);
  }
}
class Vl {
  constructor(e, n) {
    this.StringCipherConstructor = e, this.StreamCipherConstructor = n;
  }
  createStream(e, n) {
    const a = new this.StreamCipherConstructor();
    return new Y5(e, n, function(s, r) {
      return a.decryptBlock(s, r);
    });
  }
  decryptString(e) {
    const n = new this.StringCipherConstructor();
    let a = Vt(e);
    return a = n.decryptBlock(a, !0), xn(a);
  }
  encryptString(e) {
    const n = new this.StringCipherConstructor();
    if (n instanceof xc) {
      const s = 16 - e.length % 16;
      e += String.fromCharCode(s).repeat(s);
      const r = new Uint8Array(16);
      crypto.getRandomValues(r);
      let o = Vt(e);
      o = n.encrypt(o, r);
      const c = new Uint8Array(16 + o.length);
      return c.set(r), c.set(o, 16), xn(c);
    }
    let a = Vt(e);
    return a = n.encrypt(a), xn(a);
  }
}
class Ei {
  static get _defaultPasswordBytes() {
    return ae(this, "_defaultPasswordBytes", new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
  }
  #e(e, n, a, i, s, r, o, c, l, h, f, d) {
    if (n) {
      const x = Math.min(127, n.length);
      n = n.subarray(0, x);
    } else
      n = [];
    const u = e === 6 ? new Q5() : new Z5();
    return u.checkUserPassword(n, c, o) ? u.getUserKey(n, l, f) : n.length && u.checkOwnerPassword(n, i, r, a) ? u.getOwnerKey(n, s, r, h) : null;
  }
  #t(e, n, a, i, s, r, o, c) {
    const l = 40 + a.length + e.length, h = new Uint8Array(l);
    let f = 0, d, u;
    if (n)
      for (u = Math.min(32, n.length); f < u; ++f)
        h[f] = n[f];
    for (d = 0; f < 32; )
      h[f++] = Ei._defaultPasswordBytes[d++];
    h.set(a, f), f += a.length, h[f++] = s & 255, h[f++] = s >> 8 & 255, h[f++] = s >> 16 & 255, h[f++] = s >>> 24 & 255, h.set(e, f), f += e.length, r >= 4 && !c && (h.fill(255, f, f + 4), f += 4);
    let x = Ia(h, 0, f);
    const g = o >> 3;
    if (r >= 3)
      for (d = 0; d < 50; ++d)
        x = Ia(x, 0, g);
    const p = x.subarray(0, g);
    let m, b;
    if (r >= 3) {
      f = 0, h.set(Ei._defaultPasswordBytes, f), f += 32, h.set(e, f), f += e.length, m = new Xa(p), b = m.encryptBlock(Ia(h, 0, f)), u = p.length;
      const y = new Uint8Array(u);
      for (d = 1; d <= 19; ++d) {
        for (let w = 0; w < u; ++w)
          y[w] = p[w] ^ d;
        m = new Xa(y), b = m.encryptBlock(b);
      }
    } else
      m = new Xa(p), b = m.encryptBlock(Ei._defaultPasswordBytes);
    return b.every((y, w) => i[w] === y) ? p : null;
  }
  #n(e, n, a, i) {
    const s = new Uint8Array(32);
    let r = 0;
    const o = Math.min(32, e.length);
    for (; r < o; ++r)
      s[r] = e[r];
    let c = 0;
    for (; r < 32; )
      s[r++] = Ei._defaultPasswordBytes[c++];
    let l = Ia(s, 0, r);
    const h = i >> 3;
    if (a >= 3)
      for (c = 0; c < 50; ++c)
        l = Ia(l, 0, l.length);
    let f, d;
    if (a >= 3) {
      d = n;
      const u = new Uint8Array(h);
      for (c = 19; c >= 0; c--) {
        for (let x = 0; x < h; ++x)
          u[x] = l[x] ^ c;
        f = new Xa(u), d = f.encryptBlock(d);
      }
    } else
      f = new Xa(l.subarray(0, h)), d = f.encryptBlock(n);
    return d;
  }
  #a(e, n, a, i = !1) {
    const s = a.length, r = new Uint8Array(s + 9);
    r.set(a);
    let o = s;
    return r[o++] = e & 255, r[o++] = e >> 8 & 255, r[o++] = e >> 16 & 255, r[o++] = n & 255, r[o++] = n >> 8 & 255, i && (r[o++] = 115, r[o++] = 65, r[o++] = 108, r[o++] = 84), Ia(r, 0, o).subarray(0, Math.min(s + 5, 16));
  }
  #s(e, n, a, i, s) {
    if (!(n instanceof Z))
      throw new W("Invalid crypt filter name.");
    const r = this, c = e.get(n.name)?.get("CFM");
    if (!c || c.name === "None")
      return function() {
        return new J5();
      };
    if (c.name === "V2")
      return function() {
        return new Xa(r.#a(a, i, s, !1));
      };
    if (c.name === "AESV2")
      return function() {
        return new Ph(r.#a(a, i, s, !0));
      };
    if (c.name === "AESV3")
      return function() {
        return new Oo(s);
      };
    throw new W("Unknown crypto method");
  }
  constructor(e, n, a) {
    const i = e.get("Filter");
    if (!dt(i, "Standard"))
      throw new W("unknown encryption method");
    this.filterName = i.name, this.dict = e;
    const s = e.get("V");
    if (!Number.isInteger(s) || s !== 1 && s !== 2 && s !== 4 && s !== 5)
      throw new W("unsupported encryption algorithm");
    this.algorithm = s;
    let r = e.get("Length");
    if (!r)
      if (s <= 3)
        r = 40;
      else {
        const m = e.get("CF"), b = e.get("StmF");
        m instanceof B && b instanceof Z && (m.suppressEncryption = !0, r = m.get(b.name)?.get("Length") || 128, r < 40 && (r <<= 3));
      }
    if (!Number.isInteger(r) || r < 40 || r % 8 !== 0)
      throw new W("invalid key length");
    const o = Vt(e.get("O")), c = Vt(e.get("U")), l = o.subarray(0, 32), h = c.subarray(0, 32), f = e.get("P"), d = e.get("R"), u = (s === 4 || s === 5) && e.get("EncryptMetadata") !== !1;
    this.encryptMetadata = u;
    const x = Vt(n);
    let g;
    if (a) {
      if (d === 6)
        try {
          a = Y0(a);
        } catch {
          F("CipherTransformFactory: Unable to convert UTF8 encoded password.");
        }
      g = Vt(a);
    }
    let p;
    if (s !== 5)
      p = this.#t(x, g, l, h, f, d, r, u);
    else {
      const m = o.subarray(32, 40), b = o.subarray(40, 48), y = c.subarray(0, 48), w = c.subarray(32, 40), S = c.subarray(40, 48), v = Vt(e.get("OE")), k = Vt(e.get("UE")), A = Vt(e.get("Perms"));
      p = this.#e(d, g, l, m, b, y, h, w, S, v, k, A);
    }
    if (!p) {
      if (!a)
        throw new Is("No password given", yc.NEED_PASSWORD);
      const m = this.#n(g, l, d, r);
      p = this.#t(x, m, l, h, f, d, r, u);
    }
    if (!p)
      throw new Is("Incorrect Password", yc.INCORRECT_PASSWORD);
    if (s === 4 && p.length < 16 ? (this.encryptionKey = new Uint8Array(16), this.encryptionKey.set(p)) : this.encryptionKey = p, s >= 4) {
      const m = e.get("CF");
      m instanceof B && (m.suppressEncryption = !0), this.cf = m, this.stmf = e.get("StmF") || Z.get("Identity"), this.strf = e.get("StrF") || Z.get("Identity"), this.eff = e.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(e, n) {
    if (this.algorithm === 4 || this.algorithm === 5)
      return new Vl(this.#s(this.cf, this.strf, e, n, this.encryptionKey), this.#s(this.cf, this.stmf, e, n, this.encryptionKey));
    const a = this.#a(e, n, this.encryptionKey, !1), i = function() {
      return new Xa(a);
    };
    return new Vl(i, i);
  }
}
class e7 {
  constructor(e, n) {
    this.stream = e, this.pdfManager = n, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new St(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
  }
  getNewPersistentRef(e) {
    this._newPersistentRefNum === null && (this._newPersistentRefNum = this.entries.length || 1);
    const n = this._newPersistentRefNum++;
    return this._cacheMap.set(n, e), le.get(n, 0);
  }
  getNewTemporaryRef() {
    if (this._newTemporaryRefNum === null && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
      this._persistentRefsCache = /* @__PURE__ */ new Map();
      for (let e = this._newTemporaryRefNum; e < this._newPersistentRefNum; e++)
        this._persistentRefsCache.set(e, this._cacheMap.get(e)), this._cacheMap.delete(e);
    }
    return le.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    if (this._newTemporaryRefNum = null, this._persistentRefsCache)
      for (const [e, n] of this._persistentRefsCache)
        this._cacheMap.set(e, n);
    this._persistentRefsCache = null;
  }
  setStartXRef(e) {
    this.startXRefQueue = [e];
  }
  parse(e = !1) {
    let n;
    e ? (F("Indexing all PDF objects"), n = this.indexObjects()) : n = this.readXRef(), n.assignXref(this), this.trailer = n;
    let a;
    try {
      a = n.get("Encrypt");
    } catch (s) {
      if (s instanceof ht)
        throw s;
      F(`XRef.parse - Invalid "Encrypt" reference: "${s}".`);
    }
    if (a instanceof B) {
      const s = n.get("ID"), r = s?.length ? s[0] : "";
      a.suppressEncryption = !0, this.encrypt = new Ei(a, r, this.pdfManager.password);
    }
    let i;
    try {
      i = n.get("Root");
    } catch (s) {
      if (s instanceof ht)
        throw s;
      F(`XRef.parse - Invalid "Root" reference: "${s}".`);
    }
    if (i instanceof B)
      try {
        if (i.get("Pages") instanceof B) {
          this.root = i;
          return;
        }
      } catch (s) {
        if (s instanceof ht)
          throw s;
        F(`XRef.parse - Invalid "Pages" reference: "${s}".`);
      }
    throw e ? new Ts("Invalid Root reference.") : new Ri();
  }
  processXRefTable(e) {
    "tableState" in this || (this.tableState = {
      entryNum: 0,
      streamPos: e.lexer.stream.pos,
      parserBuf1: e.buf1,
      parserBuf2: e.buf2
    });
    const n = this.readXRefTable(e);
    if (!Bt(n, "trailer"))
      throw new W("Invalid XRef table: could not find trailer dictionary");
    let a = e.getObj();
    if (!(a instanceof B) && a.dict && (a = a.dict), !(a instanceof B))
      throw new W("Invalid XRef table: could not parse trailer dictionary");
    return delete this.tableState, a;
  }
  readXRefTable(e) {
    const n = e.lexer.stream, a = this.tableState;
    n.pos = a.streamPos, e.buf1 = a.parserBuf1, e.buf2 = a.parserBuf2;
    let i;
    for (; ; ) {
      if (!("firstEntryNum" in a) || !("entryCount" in a)) {
        if (Bt(i = e.getObj(), "trailer"))
          break;
        a.firstEntryNum = i, a.entryCount = e.getObj();
      }
      let s = a.firstEntryNum;
      const r = a.entryCount;
      if (!Number.isInteger(s) || !Number.isInteger(r))
        throw new W("Invalid XRef table: wrong types in subsection header");
      for (let o = a.entryNum; o < r; o++) {
        a.streamPos = n.pos, a.entryNum = o, a.parserBuf1 = e.buf1, a.parserBuf2 = e.buf2;
        const c = {};
        c.offset = e.getObj(), c.gen = e.getObj();
        const l = e.getObj();
        if (l instanceof Ct)
          switch (l.cmd) {
            case "f":
              c.free = !0;
              break;
            case "n":
              c.uncompressed = !0;
              break;
          }
        if (!Number.isInteger(c.offset) || !Number.isInteger(c.gen) || !(c.free || c.uncompressed))
          throw new W(`Invalid entry in XRef subsection: ${s}, ${r}`);
        o === 0 && c.free && s === 1 && (s = 0), this.entries[o + s] || (this.entries[o + s] = c);
      }
      a.entryNum = 0, a.streamPos = n.pos, a.parserBuf1 = e.buf1, a.parserBuf2 = e.buf2, delete a.firstEntryNum, delete a.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free)
      throw new W("Invalid XRef table: unexpected first object");
    return i;
  }
  processXRefStream(e) {
    if (!("streamState" in this)) {
      const {
        dict: n,
        pos: a
      } = e, i = n.get("W"), s = n.get("Index") || [0, n.get("Size")];
      this.streamState = {
        entryRanges: s,
        byteWidths: i,
        entryNum: 0,
        streamPos: a
      };
    }
    return this.readXRefStream(e), delete this.streamState, e.dict;
  }
  readXRefStream(e) {
    const n = this.streamState;
    e.pos = n.streamPos;
    const [a, i, s] = n.byteWidths, r = n.entryRanges;
    for (; r.length > 0; ) {
      const [o, c] = r;
      if (!Number.isInteger(o) || !Number.isInteger(c))
        throw new W(`Invalid XRef range fields: ${o}, ${c}`);
      if (!Number.isInteger(a) || !Number.isInteger(i) || !Number.isInteger(s))
        throw new W(`Invalid XRef entry fields length: ${o}, ${c}`);
      for (let l = n.entryNum; l < c; ++l) {
        n.entryNum = l, n.streamPos = e.pos;
        let h = 0, f = 0, d = 0;
        for (let x = 0; x < a; ++x) {
          const g = e.getByte();
          if (g === -1)
            throw new W("Invalid XRef byteWidths 'type'.");
          h = h << 8 | g;
        }
        a === 0 && (h = 1);
        for (let x = 0; x < i; ++x) {
          const g = e.getByte();
          if (g === -1)
            throw new W("Invalid XRef byteWidths 'offset'.");
          f = f << 8 | g;
        }
        for (let x = 0; x < s; ++x) {
          const g = e.getByte();
          if (g === -1)
            throw new W("Invalid XRef byteWidths 'generation'.");
          d = d << 8 | g;
        }
        const u = {};
        switch (u.offset = f, u.gen = d, h) {
          case 0:
            u.free = !0;
            break;
          case 1:
            u.uncompressed = !0;
            break;
          case 2:
            break;
          default:
            throw new W(`Invalid XRef entry type: ${h}`);
        }
        this.entries[o + l] || (this.entries[o + l] = u);
      }
      n.entryNum = 0, n.streamPos = e.pos, r.splice(0, 2);
    }
  }
  indexObjects() {
    function o(T, M) {
      let O = "", N = T[M];
      for (; N !== 10 && N !== 13 && N !== 60 && !(++M >= T.length); )
        O += String.fromCharCode(N), N = T[M];
      return O;
    }
    function c(T, M, O) {
      const N = O.length, H = T.length;
      let J = 0;
      for (; M < H; ) {
        let U = 0;
        for (; U < N && T[M + U] === O[U]; )
          ++U;
        if (U >= N)
          break;
        M++, J++;
      }
      return J;
    }
    const l = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, h = /\b(startxref|\d+\s+\d+\s+obj)\b/g, f = /^(\d+)\s+(\d+)\s+obj\b/, d = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), u = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), x = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0, this._cacheMap.clear();
    const g = this.stream;
    g.pos = 0;
    const p = g.getBytes(), m = xn(p), b = p.length;
    let y = g.start;
    const w = [], S = [];
    for (; y < b; ) {
      let T = p[y];
      if (T === 9 || T === 10 || T === 13 || T === 32) {
        ++y;
        continue;
      }
      if (T === 37) {
        do {
          if (++y, y >= b)
            break;
          T = p[y];
        } while (T !== 10 && T !== 13);
        continue;
      }
      const M = o(p, y);
      let O;
      if (M.startsWith("xref") && (M.length === 4 || /\s/.test(M[4])))
        y += c(p, y, d), w.push(y), y += c(p, y, u);
      else if (O = f.exec(M)) {
        const N = O[1] | 0, H = O[2] | 0, J = y + M.length;
        let U, j = !1;
        if (!this.entries[N])
          j = !0;
        else if (this.entries[N].gen === H)
          try {
            new ka({
              lexer: new Un(g.makeSubStream(J))
            }).getObj(), j = !0;
          } catch (X) {
            X instanceof eo ? F(`indexObjects -- checking object (${M}): "${X}".`) : j = !0;
          }
        j && (this.entries[N] = {
          offset: y - g.start,
          gen: H,
          uncompressed: !0
        }), l.lastIndex = J;
        const P = l.exec(m);
        P ? (U = l.lastIndex + 1 - y, P[1] !== "endobj" && (F(`indexObjects: Found "${P[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), U -= P[1].length + 1)) : U = b - y;
        const K = p.subarray(y, y + U), xe = c(K, 0, x);
        xe < U && K[xe + 5] < 64 && (S.push(y - g.start), this._xrefStms.add(y - g.start)), y += U;
      } else if (M.startsWith("trailer") && (M.length === 7 || /\s/.test(M[7]))) {
        w.push(y);
        const N = y + M.length;
        let H;
        h.lastIndex = N;
        const J = h.exec(m);
        J ? (H = h.lastIndex + 1 - y, J[1] !== "startxref" && (F(`indexObjects: Found "${J[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), H -= J[1].length + 1)) : H = b - y, y += H;
      } else
        y += M.length + 1;
    }
    for (const T of S)
      this.startXRefQueue.push(T), this.readXRef(!0);
    const v = [];
    let k = !1;
    for (const T of w) {
      g.pos = T;
      const M = new ka({
        lexer: new Un(g),
        xref: this,
        allowStreams: !0,
        recoveryMode: !0
      }), O = M.getObj();
      if (!Bt(O, "trailer"))
        continue;
      const N = M.getObj();
      N instanceof B && (v.push(N), N.has("Encrypt") && (k = !0));
    }
    let A, C;
    for (const T of [...v, "genFallback", ...v]) {
      if (T === "genFallback") {
        if (!C)
          break;
        this._generationFallback = !0;
        continue;
      }
      let M = !1;
      try {
        const O = T.get("Root");
        if (!(O instanceof B))
          continue;
        const N = O.get("Pages");
        if (!(N instanceof B))
          continue;
        const H = N.get("Count");
        Number.isInteger(H) && (M = !0);
      } catch (O) {
        C = O;
        continue;
      }
      if (M && (!k || T.has("Encrypt")) && T.has("ID"))
        return T;
      A = T;
    }
    if (A)
      return A;
    if (this.topDict)
      return this.topDict;
    if (!v.length)
      for (const T in this.entries) {
        if (!Object.hasOwn(this.entries, T))
          continue;
        const M = this.entries[T], O = le.get(parseInt(T), M.gen);
        let N;
        try {
          N = this.fetch(O);
        } catch {
          continue;
        }
        if (N instanceof Ne && (N = N.dict), N instanceof B && N.has("Root"))
          return N;
      }
    throw new Ts("Invalid PDF structure.");
  }
  readXRef(e = !1) {
    const n = this.stream, a = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const i = this.startXRefQueue[0];
        if (a.has(i)) {
          F("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
          continue;
        }
        a.add(i), n.pos = i + n.start;
        const s = new ka({
          lexer: new Un(n),
          xref: this,
          allowStreams: !0
        });
        let r = s.getObj(), o;
        if (Bt(r, "xref"))
          o = this.processXRefTable(s), this.topDict || (this.topDict = o), r = o.get("XRefStm"), Number.isInteger(r) && !this._xrefStms.has(r) && (this._xrefStms.add(r), this.startXRefQueue.push(r));
        else if (Number.isInteger(r)) {
          if (!Number.isInteger(s.getObj()) || !Bt(s.getObj(), "obj") || !((r = s.getObj()) instanceof Ne))
            throw new W("Invalid XRef stream");
          if (o = this.processXRefStream(r), this.topDict || (this.topDict = o), !o)
            throw new W("Failed to read XRef stream");
        } else
          throw new W("Invalid XRef stream header");
        r = o.get("Prev"), Number.isInteger(r) ? this.startXRefQueue.push(r) : r instanceof le && this.startXRefQueue.push(r.num);
      } catch (i) {
        if (i instanceof ht)
          throw i;
        Ue("(while reading XRef): " + i);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict)
      return this.topDict;
    if (!e)
      throw new Ri();
  }
  getEntry(e) {
    const n = this.entries[e];
    return n && !n.free && n.offset ? n : null;
  }
  fetchIfRef(e, n = !1) {
    return e instanceof le ? this.fetch(e, n) : e;
  }
  fetch(e, n = !1) {
    if (!(e instanceof le))
      throw new Error("ref object is not a reference");
    const a = e.num, i = this._cacheMap.get(a);
    if (i !== void 0)
      return i instanceof B && !i.objId && (i.objId = e.toString()), i;
    let s = this.getEntry(a);
    if (s === null)
      return s;
    if (this._pendingRefs.has(e))
      return this._pendingRefs.remove(e), F(`Ignoring circular reference: ${e}.`), rf;
    this._pendingRefs.put(e);
    try {
      s = s.uncompressed ? this.fetchUncompressed(e, s, n) : this.fetchCompressed(e, s, n), this._pendingRefs.remove(e);
    } catch (r) {
      throw this._pendingRefs.remove(e), r;
    }
    return s instanceof B ? s.objId = e.toString() : s instanceof Ne && (s.dict.objId = e.toString()), s;
  }
  fetchUncompressed(e, n, a = !1) {
    const i = e.gen;
    let s = e.num;
    if (n.gen !== i) {
      const f = `Inconsistent generation in XRef: ${e}`;
      if (this._generationFallback && n.gen < i)
        return F(f), this.fetchUncompressed(le.get(s, n.gen), n, a);
      throw new Ea(f);
    }
    const r = this.stream.makeSubStream(n.offset + this.stream.start), o = new ka({
      lexer: new Un(r),
      xref: this,
      allowStreams: !0
    }), c = o.getObj(), l = o.getObj(), h = o.getObj();
    if (c !== s || l !== i || !(h instanceof Ct))
      throw new Ea(`Bad (uncompressed) XRef entry: ${e}`);
    if (h.cmd !== "obj") {
      if (h.cmd.startsWith("obj") && (s = parseInt(h.cmd.substring(3), 10), !Number.isNaN(s)))
        return s;
      throw new Ea(`Bad (uncompressed) XRef entry: ${e}`);
    }
    return n = this.encrypt && !a ? o.getObj(this.encrypt.createCipherTransform(s, i)) : o.getObj(), n instanceof Ne || this._cacheMap.set(s, n), n;
  }
  fetchCompressed(e, n, a = !1) {
    const i = n.offset, s = this.fetch(le.get(i, 0));
    if (!(s instanceof Ne))
      throw new W("bad ObjStm stream");
    const r = s.dict.get("First"), o = s.dict.get("N");
    if (!Number.isInteger(r) || !Number.isInteger(o))
      throw new W("invalid first and n parameters for ObjStm stream");
    let c = new ka({
      lexer: new Un(s),
      xref: this,
      allowStreams: !0
    });
    const l = new Array(o), h = new Array(o);
    for (let u = 0; u < o; ++u) {
      const x = c.getObj();
      if (!Number.isInteger(x))
        throw new W(`invalid object number in the ObjStm stream: ${x}`);
      const g = c.getObj();
      if (!Number.isInteger(g))
        throw new W(`invalid object offset in the ObjStm stream: ${g}`);
      l[u] = x;
      const p = this.getEntry(x);
      p?.offset === i && p.gen !== u && (p.gen = u), h[u] = g;
    }
    const f = (s.start || 0) + r, d = new Array(o);
    for (let u = 0; u < o; ++u) {
      const x = u < o - 1 ? h[u + 1] - h[u] : void 0;
      if (x < 0)
        throw new W("Invalid offset in the ObjStm stream.");
      c = new ka({
        lexer: new Un(s.makeSubStream(f + h[u], x, s.dict)),
        xref: this,
        allowStreams: !0
      });
      const g = c.getObj();
      if (d[u] = g, g instanceof Ne)
        continue;
      const p = l[u], m = this.entries[p];
      m && m.offset === i && m.gen === u && this._cacheMap.set(p, g);
    }
    if (n = d[n.gen], n === void 0)
      throw new Ea(`Bad (compressed) XRef entry: ${e}`);
    return n;
  }
  async fetchIfRefAsync(e, n) {
    return e instanceof le ? this.fetchAsync(e, n) : e;
  }
  async fetchAsync(e, n) {
    try {
      return this.fetch(e, n);
    } catch (a) {
      if (!(a instanceof ht))
        throw a;
      return await this.pdfManager.requestRange(a.begin, a.end), this.fetchAsync(e, n);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
const t7 = [0, 0, 612, 792];
class Xl {
  #e = !1;
  #t = null;
  constructor({
    pdfManager: e,
    xref: n,
    pageIndex: a,
    pageDict: i,
    ref: s,
    globalIdFactory: r,
    fontCache: o,
    builtInCMapCache: c,
    standardFontDataCache: l,
    globalColorSpaceCache: h,
    globalImageCache: f,
    systemFontCache: d,
    nonBlendModesSet: u,
    xfaFactory: x
  }) {
    this.pdfManager = e, this.pageIndex = a, this.pageDict = i, this.xref = n, this.ref = s, this.fontCache = o, this.builtInCMapCache = c, this.standardFontDataCache = l, this.globalColorSpaceCache = h, this.globalImageCache = f, this.systemFontCache = d, this.nonBlendModesSet = u, this.evaluatorOptions = e.evaluatorOptions, this.xfaFactory = x;
    const g = {
      obj: 0
    };
    this._localIdFactory = class extends r {
      static createObjId() {
        return `p${a}_${++g.obj}`;
      }
      static getPageObjId() {
        return `p${s.toString()}`;
      }
    };
  }
  #n(e) {
    return new Ui({
      xref: this.xref,
      handler: e,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalColorSpaceCache: this.globalColorSpaceCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    });
  }
  #a(e, n = !1) {
    const a = Bn({
      dict: this.pageDict,
      key: e,
      getArray: n,
      stopWhenFound: !1
    });
    return Array.isArray(a) ? a.length === 1 || !(a[0] instanceof B) ? a[0] : B.merge({
      xref: this.xref,
      dictArray: a
    }) : a;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const e = this.#a("Resources");
    return ae(this, "resources", e instanceof B ? e : B.empty);
  }
  #s(e) {
    if (this.xfaData)
      return this.xfaData.bbox;
    const n = ma(this.#a(e, !0), null);
    if (n) {
      if (n[2] - n[0] > 0 && n[3] - n[1] > 0)
        return n;
      F(`Empty, or invalid, /${e} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return ae(this, "mediaBox", this.#s("MediaBox") || t7);
  }
  get cropBox() {
    return ae(this, "cropBox", this.#s("CropBox") || this.mediaBox);
  }
  get userUnit() {
    const e = this.pageDict.get("UserUnit");
    return ae(this, "userUnit", typeof e == "number" && e > 0 ? e : 1);
  }
  get view() {
    const {
      cropBox: e,
      mediaBox: n
    } = this;
    if (e !== n && !Fs(e, n)) {
      const a = Je.intersect(e, n);
      if (a && a[2] - a[0] > 0 && a[3] - a[1] > 0)
        return ae(this, "view", a);
      F("Empty /CropBox and /MediaBox intersection.");
    }
    return ae(this, "view", n);
  }
  get rotate() {
    let e = this.#a("Rotate") || 0;
    return e % 90 !== 0 ? e = 0 : e >= 360 ? e %= 360 : e < 0 && (e = (e % 360 + 360) % 360), ae(this, "rotate", e);
  }
  #r(e, n) {
    if (this.evaluatorOptions.ignoreErrors) {
      F(`getContentStream - ignoring sub-stream (${n}): "${e}".`);
      return;
    }
    throw e;
  }
  async getContentStream() {
    const e = await this.pdfManager.ensure(this, "content");
    return e instanceof Ne ? e : Array.isArray(e) ? new Xf(e, this.#r.bind(this)) : new io();
  }
  get xfaData() {
    return ae(this, "xfaData", this.xfaFactory ? {
      bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
    } : null);
  }
  async #c(e, n, a) {
    const i = [];
    for (const s of e)
      if (s.id) {
        const r = le.fromString(s.id);
        if (!r) {
          F(`A non-linked annotation cannot be modified: ${s.id}`);
          continue;
        }
        if (s.deleted) {
          if (n.put(r, r), s.popupRef) {
            const o = le.fromString(s.popupRef);
            o && n.put(o, o);
          }
          continue;
        }
        if (s.popup?.deleted) {
          const o = le.fromString(s.popupRef);
          o && n.put(o, o);
        }
        a?.put(r), s.ref = r, i.push(this.xref.fetchAsync(r).then((o) => {
          o instanceof B && (s.oldAnnotation = o.clone());
        }, () => {
          F(`Cannot fetch \`oldAnnotation\` for: ${r}.`);
        })), delete s.id;
      }
    await Promise.all(i);
  }
  async saveNewAnnotations(e, n, a, i, s) {
    if (this.xfaFactory)
      throw new Error("XFA: Cannot save new annotations.");
    const r = this.#n(e), o = new un(), c = new St();
    await this.#c(a, o, c);
    const l = this.pageDict, h = this.annotations.filter((u) => !(u instanceof le && o.has(u))), f = await la.saveNewAnnotations(r, n, a, i, s);
    for (const {
      ref: u
    } of f.annotations)
      u instanceof le && !c.has(u) && h.push(u);
    const d = l.clone();
    d.set("Annots", h), s.put(this.ref, {
      data: d
    });
    for (const u of o)
      s.put(u, {
        data: null
      });
  }
  async save(e, n, a, i) {
    const s = this.#n(e), r = await this._parsedAnnotations, o = [];
    for (const c of r)
      o.push(c.save(s, n, a, i).catch(function(l) {
        return F(`save - ignoring annotation data during "${n.name}" task: "${l}".`), null;
      }));
    return Promise.all(o);
  }
  async loadResources(e) {
    await (this.#t ??= this.pdfManager.ensure(this, "resources")), await Hi.load(this.resources, e, this.xref);
  }
  async #i(e, n) {
    const a = e?.get("Resources");
    return a instanceof B && a.size ? (await Hi.load(a, n, this.xref), B.merge({
      xref: this.xref,
      dictArray: [a, this.resources],
      mergeSubDicts: !0
    })) : this.resources;
  }
  async getOperatorList({
    handler: e,
    sink: n,
    task: a,
    intent: i,
    cacheKey: s,
    annotationStorage: r = null,
    modifiedIds: o = null
  }) {
    const c = this.getContentStream(), l = this.loadResources(Z0), h = this.#n(e), d = (this.xfaFactory ? null : h1(r))?.get(this.pageIndex);
    let u = Promise.resolve(null), x = null;
    if (d) {
      const O = this.pdfManager.ensureDoc("annotationGlobals");
      let N;
      const H = /* @__PURE__ */ new Set();
      for (const {
        bitmapId: U,
        bitmap: j
      } of d)
        U && !j && !H.has(U) && H.add(U);
      const {
        isOffscreenCanvasSupported: J
      } = this.evaluatorOptions;
      if (H.size > 0) {
        const U = d.slice();
        for (const [j, P] of r)
          j.startsWith(Ql) && P.bitmap && H.has(P.bitmapId) && U.push(P);
        N = la.generateImages(U, this.xref, J);
      } else
        N = la.generateImages(d, this.xref, J);
      x = new St(), u = Promise.all([O, this.#c(d, x, null)]).then(([U]) => U ? la.printNewAnnotations(U, h, a, d, N) : null);
    }
    const g = Promise.all([c, l]).then(async ([O]) => {
      const N = await this.#i(O.dict, Z0), H = new Ht(i, n);
      return e.send("StartRenderPage", {
        transparency: h.hasBlendModes(N, this.nonBlendModesSet),
        pageIndex: this.pageIndex,
        cacheKey: s
      }), await h.getOperatorList({
        stream: O,
        task: a,
        resources: N,
        operatorList: H
      }), H;
    });
    let [p, m, b] = await Promise.all([g, this._parsedAnnotations, u]);
    if (b) {
      m = m.filter((O) => !(O.ref && x.has(O.ref)));
      for (let O = 0, N = b.length; O < N; O++) {
        const H = b[O];
        if (H.refToReplace) {
          const J = m.findIndex((U) => U.ref && Dr(U.ref, H.refToReplace));
          J >= 0 && (m.splice(J, 1, H), b.splice(O--, 1), N--);
        }
      }
      m = m.concat(b);
    }
    if (m.length === 0 || i & tn.ANNOTATIONS_DISABLE)
      return p.flush(!0), {
        length: p.totalLength
      };
    const y = !!(i & tn.ANNOTATIONS_FORMS), w = !!(i & tn.IS_EDITING), S = !!(i & tn.ANY), v = !!(i & tn.DISPLAY), k = !!(i & tn.PRINT), A = [];
    for (const O of m)
      (S || v && O.mustBeViewed(r, y) && O.mustBeViewedWhenEditing(w, o) || k && O.mustBePrinted(r)) && A.push(O.getOperatorList(h, a, i, r).catch(function(N) {
        return F(`getOperatorList - ignoring annotation data during "${a.name}" task: "${N}".`), {
          opList: null,
          separateForm: !1,
          separateCanvas: !1
        };
      }));
    const C = await Promise.all(A);
    let T = !1, M = !1;
    for (const {
      opList: O,
      separateForm: N,
      separateCanvas: H
    } of C)
      p.addOpList(O), T ||= N, M ||= H;
    return p.flush(!0, {
      form: T,
      canvas: M
    }), {
      length: p.totalLength
    };
  }
  async extractTextContent({
    handler: e,
    task: n,
    includeMarkedContent: a,
    disableNormalization: i,
    sink: s,
    intersector: r = null
  }) {
    const o = this.getContentStream(), c = this.loadResources(Q0), l = this.pdfManager.ensureCatalog("lang"), [h, , f] = await Promise.all([o, c, l]), d = await this.#i(h.dict, Q0);
    return this.#n(e).getTextContent({
      stream: h,
      task: n,
      resources: d,
      includeMarkedContent: a,
      disableNormalization: i,
      sink: s,
      viewBox: this.view,
      lang: f,
      intersector: r
    });
  }
  async getStructTree() {
    const e = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!e)
      return null;
    await this._parsedAnnotations;
    try {
      const n = await this.pdfManager.ensure(this, "_parseStructTree", [e]);
      return await this.pdfManager.ensure(n, "serializable");
    } catch (n) {
      return F(`getStructTree: "${n}".`), null;
    }
  }
  _parseStructTree(e) {
    const n = new q1(e, this.pageDict);
    return n.parse(this.ref), n;
  }
  async getAnnotationsData(e, n, a) {
    const i = await this._parsedAnnotations;
    if (i.length === 0)
      return i;
    const s = [], r = [];
    let o;
    const c = !!(a & tn.ANY), l = !!(a & tn.DISPLAY), h = !!(a & tn.PRINT), f = [];
    for (const d of i) {
      const u = c || l && d.viewable;
      (u || h && d.printable) && s.push(d.data), d.hasTextContent && u ? (o ??= this.#n(e), r.push(d.extractTextContent(o, n, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(x) {
        F(`getAnnotationsData - ignoring textContent during "${n.name}" task: "${x}".`);
      }))) : d.overlaysTextContent && u && f.push(d);
    }
    if (f.length > 0) {
      const d = new P5(f);
      r.push(this.extractTextContent({
        handler: e,
        task: n,
        includeMarkedContent: !1,
        disableNormalization: !1,
        sink: null,
        viewBox: this.view,
        lang: null,
        intersector: d
      }).then(() => {
        d.setText();
      }));
    }
    return await Promise.all(r), s;
  }
  get annotations() {
    const e = this.#a("Annots");
    return ae(this, "annotations", Array.isArray(e) ? e : []);
  }
  get _parsedAnnotations() {
    const e = this.pdfManager.ensure(this, "annotations").then(async (n) => {
      if (n.length === 0)
        return n;
      const [a, i] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureDoc("fieldObjects")]);
      if (!a)
        return [];
      const s = i?.orphanFields, r = [];
      for (const h of n)
        r.push(la.create(this.xref, h, a, this._localIdFactory, !1, s, null, this.ref).catch(function(f) {
          return F(`_parsedAnnotations: "${f}".`), null;
        }));
      const o = [];
      let c, l;
      for (const h of await Promise.all(r))
        if (h) {
          if (h instanceof Gn) {
            (l ||= []).push(h);
            continue;
          }
          if (h instanceof dc) {
            (c ||= []).push(h);
            continue;
          }
          o.push(h);
        }
      return l && o.push(...l), c && o.push(...c), o;
    });
    return this.#e = !0, ae(this, "_parsedAnnotations", e);
  }
  get jsActions() {
    const e = a0(this.xref, this.pageDict, qh);
    return ae(this, "jsActions", e);
  }
  async collectAnnotationsByType(e, n, a, i, s) {
    const {
      pageIndex: r
    } = this;
    if (this.#e) {
      const c = await this._parsedAnnotations;
      for (const {
        data: l
      } of c)
        (!a || a.has(l.annotationType)) && (l.pageIndex = r, i.push(Promise.resolve(l)));
      return;
    }
    const o = await this.pdfManager.ensure(this, "annotations");
    for (const c of o)
      i.push(la.create(this.xref, c, s, this._localIdFactory, !1, null, a, this.ref).then(async (l) => {
        if (!l)
          return null;
        if (l.data.pageIndex = r, l.hasTextContent && l.viewable) {
          const h = this.#n(e);
          await l.extractTextContent(h, n, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]);
        }
        return l.data;
      }).catch(function(l) {
        return F(`collectAnnotationsByType: "${l}".`), null;
      }));
  }
}
const ql = new Uint8Array([37, 80, 68, 70, 45]), Kl = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), n7 = new Uint8Array([101, 110, 100, 111, 98, 106]);
function X0(t, e, n = 1024, a = !1) {
  const i = e.length, s = t.peekBytes(n), r = s.length - i;
  if (r <= 0)
    return !1;
  if (a) {
    const o = i - 1;
    let c = s.length - 1;
    for (; c >= o; ) {
      let l = 0;
      for (; l < i && s[c - l] === e[o - l]; )
        l++;
      if (l >= i)
        return t.pos += c - o, !0;
      c--;
    }
  } else {
    let o = 0;
    for (; o <= r; ) {
      let c = 0;
      for (; c < i && s[o + c] === e[c]; )
        c++;
      if (c >= i)
        return t.pos += o, !0;
      o++;
    }
  }
  return !1;
}
class Dh {
  #e = /* @__PURE__ */ new Map();
  #t = null;
  constructor(e, n) {
    if (n.length <= 0)
      throw new Ts("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = e, this.stream = n, this.xref = new e7(n, e);
    const a = {
      font: 0
    };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${e.docId}`;
      }
      static createFontId() {
        return `f${++a.font}`;
      }
      static createObjId() {
        _e("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        _e("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(e) {
    this.xref.parse(e), this.catalog = new ji(this.pdfManager, this.xref);
  }
  get linearization() {
    let e = null;
    try {
      e = Uu.create(this.stream);
    } catch (n) {
      if (n instanceof ht)
        throw n;
      Ue(n);
    }
    return ae(this, "linearization", e);
  }
  get startXRef() {
    const e = this.stream;
    let n = 0;
    if (this.linearization) {
      if (e.reset(), X0(e, n7)) {
        e.skip(6);
        let a = e.peekByte();
        for (; An(a); )
          e.pos++, a = e.peekByte();
        n = e.pos - e.start;
      }
    } else {
      const i = Kl.length;
      let s = !1, r = e.end;
      for (; !s && r > 0; )
        r -= 1024 - i, r < 0 && (r = 0), e.pos = r, s = X0(e, Kl, 1024, !0);
      if (s) {
        e.skip(9);
        let o;
        do
          o = e.getByte();
        while (An(o));
        let c = "";
        for (; o >= 32 && o <= 57; )
          c += String.fromCharCode(o), o = e.getByte();
        n = parseInt(c, 10), isNaN(n) && (n = 0);
      }
    }
    return ae(this, "startXRef", n);
  }
  checkHeader() {
    const e = this.stream;
    if (e.reset(), !X0(e, ql))
      return;
    e.moveStart(), e.skip(ql.length);
    let n = "", a;
    for (; (a = e.getByte()) > 32 && n.length < 7; )
      n += String.fromCharCode(a);
    r1.test(n) ? this.#t = n : F(`Invalid PDF header version: ${n}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let e = 0;
    return this.catalog.hasActualNumPages ? e = this.catalog.numPages : this.xfaFactory ? e = this.xfaFactory.getNumPages() : this.linearization ? e = this.linearization.numPages : e = this.catalog.numPages, ae(this, "numPages", e);
  }
  #n(e, n = 0) {
    return Array.isArray(e) ? e.every((i) => {
      if (i = this.xref.fetchIfRef(i), !(i instanceof B))
        return !1;
      if (i.has("Kids"))
        return ++n > 10 ? (F("#hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this.#n(i.get("Kids"), n);
      const s = dt(i.get("FT"), "Sig"), r = i.get("Rect"), o = Array.isArray(r) && r.every((c) => c === 0);
      return s && o;
    }) : !1;
  }
  #a(e, n, a = new St()) {
    if (Array.isArray(e))
      for (let i of e) {
        if (i instanceof le) {
          if (a.has(i))
            continue;
          a.put(i);
        }
        if (i = this.xref.fetchIfRef(i), !(i instanceof B))
          continue;
        if (i.has("Kids")) {
          this.#a(i.get("Kids"), n, a);
          continue;
        }
        if (!dt(i.get("FT"), "Sig"))
          continue;
        const r = i.get("V");
        if (!(r instanceof B))
          continue;
        const o = r.get("SubFilter");
        o instanceof Z && n.add(o.name);
      }
  }
  get _xfaStreams() {
    const {
      acroForm: e
    } = this.catalog;
    if (!e)
      return null;
    const n = e.get("XFA"), a = new Map(["xdp:xdp", "template", "datasets", "config", "connectionSet", "localeSet", "stylesheet", "/xdp:xdp"].map((i) => [i, null]));
    if (n instanceof Ne && !n.isEmpty)
      return a.set("xdp:xdp", n), a;
    if (!Array.isArray(n) || n.length === 0)
      return null;
    for (let i = 0, s = n.length; i < s; i += 2) {
      let r;
      if (i === 0 ? r = "xdp:xdp" : i === s - 2 ? r = "/xdp:xdp" : r = n[i], !a.has(r))
        continue;
      const o = this.xref.fetchIfRef(n[i + 1]);
      !(o instanceof Ne) || o.isEmpty || a.set(r, o);
    }
    return a;
  }
  get xfaDatasets() {
    const e = this._xfaStreams;
    if (!e)
      return ae(this, "xfaDatasets", null);
    for (const n of ["datasets", "xdp:xdp"]) {
      const a = e.get(n);
      if (a)
        try {
          const i = Es(a.getString()), s = {
            [n]: i
          };
          return ae(this, "xfaDatasets", new B5(s));
        } catch {
          F("XFA - Invalid utf-8 string.");
          break;
        }
    }
    return ae(this, "xfaDatasets", null);
  }
  get xfaData() {
    const e = this._xfaStreams;
    if (!e)
      return null;
    const n = /* @__PURE__ */ Object.create(null);
    for (const [a, i] of e)
      if (i)
        try {
          n[a] = Es(i.getString());
        } catch {
          return F("XFA - Invalid utf-8 string."), null;
        }
    return n;
  }
  get xfaFactory() {
    let e;
    return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e = this.xfaData), ae(this, "xfaFactory", e ? new Js(e) : null);
  }
  get isPureXfa() {
    return this.xfaFactory ? this.xfaFactory.isValid() : !1;
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async #s() {
    const e = await this.pdfManager.ensureCatalog("xfaImages");
    e && this.xfaFactory.setImages(e);
  }
  async #r(e, n) {
    const a = await this.pdfManager.ensureCatalog("acroForm");
    if (!a)
      return;
    const i = await a.getAsync("DR");
    if (!(i instanceof B))
      return;
    await Hi.load(i, ["Font"], this.xref);
    const s = i.get("Font");
    if (!(s instanceof B))
      return;
    const r = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions, {
      useSystemFonts: !1
    }), {
      builtInCMapCache: o,
      fontCache: c,
      standardFontDataCache: l
    } = this.catalog, h = new Ui({
      xref: this.xref,
      handler: e,
      pageIndex: -1,
      idFactory: this._globalIdFactory,
      fontCache: c,
      builtInCMapCache: o,
      standardFontDataCache: l,
      options: r
    }), f = new Ht(), d = [], u = {
      get font() {
        return d.at(-1);
      },
      set font(b) {
        d.push(b);
      },
      clone() {
        return this;
      }
    }, x = (b, y, w) => h.handleSetFont(i, [Z.get(b), 1], null, f, n, u, y, w).catch((S) => (F(`loadXfaFonts: "${S}".`), null)), g = [];
    for (const [b, y] of s) {
      const w = y.get("FontDescriptor");
      if (!(w instanceof B))
        continue;
      let S = w.get("FontFamily");
      S = S.replaceAll(/[ ]+(\d)/g, "$1");
      const v = w.get("FontWeight"), k = -w.get("ItalicAngle"), A = {
        fontFamily: S,
        fontWeight: v,
        italicAngle: k
      };
      xf(A) && g.push(x(b, null, A));
    }
    await Promise.all(g);
    const p = this.xfaFactory.setFonts(d);
    if (!p)
      return;
    r.ignoreErrors = !0, g.length = 0, d.length = 0;
    const m = /* @__PURE__ */ new Set();
    for (const b of p)
      qo(`${b}-Regular`) || m.add(b);
    m.size && p.push("PdfJS-Fallback");
    for (const b of p)
      if (!m.has(b))
        for (const y of [{
          name: "Regular",
          fontWeight: 400,
          italicAngle: 0
        }, {
          name: "Bold",
          fontWeight: 700,
          italicAngle: 0
        }, {
          name: "Italic",
          fontWeight: 400,
          italicAngle: 12
        }, {
          name: "BoldItalic",
          fontWeight: 700,
          italicAngle: 12
        }]) {
          const w = `${b}-${y.name}`;
          g.push(x(w, H1(w), {
            fontFamily: b,
            fontWeight: y.fontWeight,
            italicAngle: y.italicAngle
          }));
        }
    await Promise.all(g), this.xfaFactory.appendFonts(d, m);
  }
  loadXfaResources(e, n) {
    return Promise.all([this.#r(e, n).catch(() => {
    }), this.#s()]);
  }
  serializeXfaData(e) {
    return this.xfaFactory ? this.xfaFactory.serializeData(e) : null;
  }
  get version() {
    return this.catalog.version || this.#t;
  }
  get formInfo() {
    const e = {
      hasFields: !1,
      hasAcroForm: !1,
      hasXfa: !1,
      hasSignatures: !1
    }, {
      acroForm: n
    } = this.catalog;
    if (!n)
      return ae(this, "formInfo", e);
    try {
      const a = n.get("Fields"), i = Array.isArray(a) && a.length > 0;
      e.hasFields = i;
      const s = n.get("XFA");
      e.hasXfa = Array.isArray(s) && s.length > 0 || s instanceof Ne && !s.isEmpty;
      const o = !!(n.get("SigFlags") & 1), c = o && this.#n(a);
      e.hasAcroForm = i && !c, e.hasSignatures = o;
    } catch (a) {
      if (a instanceof ht)
        throw a;
      F(`Cannot fetch form information: "${a}".`);
    }
    return ae(this, "formInfo", e);
  }
  get documentInfo() {
    const {
      catalog: e,
      formInfo: n,
      xref: a
    } = this, i = {
      PDFFormatVersion: this.version,
      Language: e.lang,
      EncryptFilterName: a.encrypt?.filterName ?? null,
      IsLinearized: !!this.linearization,
      IsAcroFormPresent: n.hasAcroForm,
      IsXFAPresent: n.hasXfa,
      IsCollectionPresent: !!e.collection,
      IsSignaturesPresent: n.hasSignatures
    };
    let s;
    try {
      s = a.trailer.get("Info");
    } catch (r) {
      if (r instanceof ht)
        throw r;
      Ue("The document information dictionary is invalid.");
    }
    if (!(s instanceof B))
      return ae(this, "documentInfo", i);
    for (const [r, o] of s) {
      switch (r) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if (typeof o == "string") {
            i[r] = Ve(o);
            continue;
          }
          break;
        case "Trapped":
          if (o instanceof Z) {
            i[r] = o;
            continue;
          }
          break;
        default:
          let c;
          switch (typeof o) {
            case "string":
              c = Ve(o);
              break;
            case "number":
            case "boolean":
              c = o;
              break;
            default:
              o instanceof Z && (c = o);
              break;
          }
          if (c === void 0) {
            F(`Bad value, for custom key "${r}", in Info: ${o}.`);
            continue;
          }
          i.Custom ??= /* @__PURE__ */ Object.create(null), i.Custom[r] = c;
          continue;
      }
      F(`Bad value, for key "${r}", in Info: ${o}.`);
    }
    return ae(this, "documentInfo", i);
  }
  get fingerprints() {
    const n = "\0".repeat(16);
    function a(o) {
      return typeof o == "string" && o.length === 16 && o !== n;
    }
    const i = this.xref.trailer.get("ID");
    let s, r;
    return Array.isArray(i) && a(i[0]) ? (s = Vt(i[0]), i[1] !== i[0] && a(i[1]) && (r = Vt(i[1]))) : s = Ia(this.stream.getByteRange(0, 1024), 0, 1024), ae(this, "fingerprints", [Sc(s), r ? Sc(r) : null]);
  }
  async #c(e) {
    const {
      catalog: n,
      linearization: a,
      xref: i
    } = this, s = le.get(a.objectNumberFirst, 0);
    try {
      const r = await i.fetchAsync(s);
      if (r instanceof B) {
        let o = r.getRaw("Type");
        if (o instanceof le && (o = await i.fetchAsync(o)), dt(o, "Page") || !r.has("Type") && !r.has("Kids") && r.has("Contents"))
          return n.pageKidsCountCache.has(s) || n.pageKidsCountCache.put(s, 1), n.pageIndexCache.has(s) || n.pageIndexCache.put(s, 0), [r, s];
      }
      throw new W("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (r) {
      return F(`_getLinearizationPage: "${r.message}".`), n.getPageDict(e);
    }
  }
  getPage(e) {
    const n = this.#e.get(e);
    if (n)
      return n;
    const {
      catalog: a,
      linearization: i,
      xfaFactory: s
    } = this;
    let r;
    return s ? r = Promise.resolve([B.empty, null]) : i?.pageFirst === e ? r = this.#c(e) : r = a.getPageDict(e), r = r.then(([o, c]) => new Xl({
      pdfManager: this.pdfManager,
      xref: this.xref,
      pageIndex: e,
      pageDict: o,
      ref: c,
      globalIdFactory: this._globalIdFactory,
      fontCache: a.fontCache,
      builtInCMapCache: a.builtInCMapCache,
      standardFontDataCache: a.standardFontDataCache,
      globalColorSpaceCache: a.globalColorSpaceCache,
      globalImageCache: a.globalImageCache,
      systemFontCache: a.systemFontCache,
      nonBlendModesSet: a.nonBlendModesSet,
      xfaFactory: s
    })), this.#e.set(e, r), r;
  }
  async checkFirstPage(e = !1) {
    if (!e)
      try {
        await this.getPage(0);
      } catch (n) {
        if (n instanceof Ea)
          throw this.#e.delete(0), await this.cleanup(), new Ri();
      }
  }
  async checkLastPage(e = !1) {
    const {
      catalog: n,
      pdfManager: a
    } = this;
    n.setActualNumPages();
    let i;
    try {
      if (await Promise.all([a.ensureDoc("xfaFactory"), a.ensureDoc("linearization"), a.ensureCatalog("numPages")]), this.xfaFactory)
        return;
      if (this.linearization ? i = this.linearization.numPages : i = n.numPages, Number.isInteger(i)) {
        if (i <= 1)
          return;
      } else throw new W("Page count is not an integer.");
      await this.getPage(i - 1);
    } catch (s) {
      if (this.#e.delete(i - 1), await this.cleanup(), s instanceof Ea && !e)
        throw new Ri();
      F(`checkLastPage - invalid /Pages tree /Count: ${i}.`);
      let r;
      try {
        r = await n.getAllPageDicts(e);
      } catch (o) {
        if (o instanceof Ea && !e)
          throw new Ri();
        n.setActualNumPages(1);
        return;
      }
      for (const [o, [c, l]] of r) {
        let h;
        c instanceof Error ? (h = Promise.reject(c), h.catch(() => {
        })) : h = Promise.resolve(new Xl({
          pdfManager: a,
          xref: this.xref,
          pageIndex: o,
          pageDict: c,
          ref: l,
          globalIdFactory: this._globalIdFactory,
          fontCache: n.fontCache,
          builtInCMapCache: n.builtInCMapCache,
          standardFontDataCache: n.standardFontDataCache,
          globalColorSpaceCache: this.globalColorSpaceCache,
          globalImageCache: n.globalImageCache,
          systemFontCache: n.systemFontCache,
          nonBlendModesSet: n.nonBlendModesSet,
          xfaFactory: null
        })), this.#e.set(o, h);
      }
      n.setActualNumPages(r.size);
    }
  }
  async fontFallback(e, n) {
    const {
      catalog: a,
      pdfManager: i
    } = this;
    for (const s of await Promise.all(a.fontCache))
      if (s.loadedName === e) {
        s.fallback(n, i.evaluatorOptions);
        return;
      }
  }
  async cleanup(e = !1) {
    return this.catalog ? this.catalog.cleanup(e) : Jo();
  }
  async #i(e, n, a, i, s, r, o) {
    const {
      xref: c
    } = this;
    if (!(a instanceof le) || r.has(a))
      return;
    r.put(a);
    const l = await c.fetchAsync(a);
    if (!(l instanceof B))
      return;
    let h = await l.getAsync("Subtype");
    switch (h = h instanceof Z ? h.name : null, h) {
      case "Link":
        return;
    }
    if (l.has("T")) {
      const d = Ve(await l.getAsync("T"));
      e = e === "" ? d : `${e}.${d}`;
    } else {
      let d = l;
      for (; ; ) {
        if (d = d.getRaw("Parent") || n, d instanceof le) {
          if (r.has(d))
            break;
          d = await c.fetchAsync(d);
        }
        if (!(d instanceof B))
          break;
        if (d.has("T")) {
          const u = Ve(await d.getAsync("T"));
          e = e === "" ? u : `${e}.${u}`;
          break;
        }
      }
    }
    if (n && !l.has("Parent") && dt(l.get("Subtype"), "Widget") && o.put(a, n), i.has(e) || i.set(e, []), i.get(e).push(la.create(c, a, s, null, !0, o, null, null).then((d) => d?.getFieldObject()).catch(function(d) {
      return F(`#collectFieldObjects: "${d}".`), null;
    })), !l.has("Kids"))
      return;
    const f = await l.getAsync("Kids");
    if (Array.isArray(f))
      for (const d of f)
        await this.#i(e, a, d, i, s, r, o);
  }
  get fieldObjects() {
    const e = this.pdfManager.ensureDoc("formInfo").then(async (n) => {
      if (!n.hasFields)
        return null;
      const a = await this.annotationGlobals;
      if (!a)
        return null;
      const {
        acroForm: i
      } = a, s = new St(), r = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map(), c = new un();
      for (const h of i.get("Fields"))
        await this.#i("", null, h, o, a, s, c);
      const l = [];
      for (const [h, f] of o)
        l.push(Promise.all(f).then((d) => {
          d = d.filter((u) => !!u), d.length > 0 && (r[h] = d);
        }));
      return await Promise.all(l), {
        allFields: Mo(r) > 0 ? r : null,
        orphanFields: c
      };
    });
    return ae(this, "fieldObjects", e);
  }
  get hasJSActions() {
    const e = this.pdfManager.ensureDoc("_parseHasJSActions");
    return ae(this, "hasJSActions", e);
  }
  async _parseHasJSActions() {
    const [e, n] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return e ? !0 : n?.allFields ? Object.values(n.allFields).some((a) => a.some((i) => i.actions !== null)) : !1;
  }
  get calculationOrderIds() {
    const e = this.catalog.acroForm?.get("CO");
    if (!Array.isArray(e) || e.length === 0)
      return ae(this, "calculationOrderIds", null);
    const n = [];
    for (const a of e)
      a instanceof le && n.push(a.toString());
    return ae(this, "calculationOrderIds", n.length ? n : null);
  }
  get annotationGlobals() {
    return ae(this, "annotationGlobals", la.createGlobals(this.pdfManager));
  }
}
function a7(t) {
  if (t) {
    const e = Nr(t);
    if (e)
      return e.href;
    F(`Invalid absolute docBaseUrl: "${t}".`);
  }
  return null;
}
class Lh {
  constructor({
    docBaseUrl: e,
    docId: n,
    enableXfa: a,
    evaluatorOptions: i,
    handler: s,
    password: r
  }) {
    this._docBaseUrl = a7(e), this._docId = n, this._password = r, this.enableXfa = a, i.isOffscreenCanvasSupported &&= gn.isOffscreenCanvasSupported, i.isImageDecoderSupported &&= gn.isImageDecoderSupported, this.evaluatorOptions = Object.freeze(i), fn.setOptions(i), Wi.setOptions(i), Ht.setOptions(i);
    const o = {
      ...i,
      handler: s
    };
    s0.setOptions(o), da.setOptions(o), Rs.setOptions(o);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  ensureDoc(e, n) {
    return this.ensure(this.pdfDocument, e, n);
  }
  ensureXRef(e, n) {
    return this.ensure(this.pdfDocument.xref, e, n);
  }
  ensureCatalog(e, n) {
    return this.ensure(this.pdfDocument.catalog, e, n);
  }
  getPage(e) {
    return this.pdfDocument.getPage(e);
  }
  fontFallback(e, n) {
    return this.pdfDocument.fontFallback(e, n);
  }
  cleanup(e = !1) {
    return this.pdfDocument.cleanup(e);
  }
  async ensure(e, n, a) {
    _e("Abstract method `ensure` called");
  }
  requestRange(e, n) {
    _e("Abstract method `requestRange` called");
  }
  requestLoadedStream(e = !1) {
    _e("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(e) {
    _e("Abstract method `sendProgressiveData` called");
  }
  updatePassword(e) {
    this._password = e;
  }
  terminate(e) {
    _e("Abstract method `terminate` called");
  }
}
class Yl extends Lh {
  constructor(e) {
    super(e);
    const n = new pt(e.source);
    this.pdfDocument = new Dh(this, n), this._loadedStreamPromise = Promise.resolve(n);
  }
  async ensure(e, n, a) {
    const i = e[n];
    return typeof i == "function" ? i.apply(e, a) : i;
  }
  requestRange(e, n) {
    return Promise.resolve();
  }
  requestLoadedStream(e = !1) {
    return this._loadedStreamPromise;
  }
  terminate(e) {
  }
}
class i7 extends Lh {
  constructor(e) {
    super(e), this.streamManager = new Gf(e.source, {
      msgHandler: e.handler,
      length: e.length,
      disableAutoFetch: e.disableAutoFetch,
      rangeChunkSize: e.rangeChunkSize
    }), this.pdfDocument = new Dh(this, this.streamManager.getStream());
  }
  async ensure(e, n, a) {
    try {
      const i = e[n];
      return typeof i == "function" ? i.apply(e, a) : i;
    } catch (i) {
      if (!(i instanceof ht))
        throw i;
      return await this.requestRange(i.begin, i.end), this.ensure(e, n, a);
    }
  }
  requestRange(e, n) {
    return this.streamManager.requestRange(e, n);
  }
  requestLoadedStream(e = !1) {
    return this.streamManager.requestAllChunks(e);
  }
  sendProgressiveData(e) {
    this.streamManager.onReceiveData({
      chunk: e
    });
  }
  terminate(e) {
    this.streamManager.abort(e);
  }
}
const Ir = {
  DATA: 1,
  ERROR: 2
}, It = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function Jl() {
}
function wn(t) {
  if (t instanceof _t || t instanceof Ts || t instanceof Is || t instanceof wc || t instanceof v0)
    return t;
  switch (t instanceof Error || typeof t == "object" && t !== null || _e('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), t.name) {
    case "AbortException":
      return new _t(t.message);
    case "InvalidPDFException":
      return new Ts(t.message);
    case "PasswordException":
      return new Is(t.message, t.code);
    case "ResponseException":
      return new wc(t.message, t.status, t.missing);
    case "UnknownErrorException":
      return new v0(t.message, t.details);
  }
  return new v0(t.message, t.toString());
}
class Zl {
  #e = new AbortController();
  constructor(e, n, a) {
    this.sourceName = e, this.targetName = n, this.comObj = a, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), a.addEventListener("message", this.#t.bind(this), {
      signal: this.#e.signal
    });
  }
  #t({
    data: e
  }) {
    if (e.targetName !== this.sourceName)
      return;
    if (e.stream) {
      this.#a(e);
      return;
    }
    if (e.callback) {
      const a = e.callbackId, i = this.callbackCapabilities[a];
      if (!i)
        throw new Error(`Cannot resolve callback ${a}`);
      if (delete this.callbackCapabilities[a], e.callback === Ir.DATA)
        i.resolve(e.data);
      else if (e.callback === Ir.ERROR)
        i.reject(wn(e.reason));
      else
        throw new Error("Unexpected callback case");
      return;
    }
    const n = this.actionHandler[e.action];
    if (!n)
      throw new Error(`Unknown action from worker: ${e.action}`);
    if (e.callbackId) {
      const a = this.sourceName, i = e.sourceName, s = this.comObj;
      Promise.try(n, e.data).then(function(r) {
        s.postMessage({
          sourceName: a,
          targetName: i,
          callback: Ir.DATA,
          callbackId: e.callbackId,
          data: r
        });
      }, function(r) {
        s.postMessage({
          sourceName: a,
          targetName: i,
          callback: Ir.ERROR,
          callbackId: e.callbackId,
          reason: wn(r)
        });
      });
      return;
    }
    if (e.streamId) {
      this.#n(e);
      return;
    }
    n(e.data);
  }
  on(e, n) {
    const a = this.actionHandler;
    if (a[e])
      throw new Error(`There is already an actionName called "${e}"`);
    a[e] = n;
  }
  send(e, n, a) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: e,
      data: n
    }, a);
  }
  sendWithPromise(e, n, a) {
    const i = this.callbackId++, s = Promise.withResolvers();
    this.callbackCapabilities[i] = s;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: e,
        callbackId: i,
        data: n
      }, a);
    } catch (r) {
      s.reject(r);
    }
    return s.promise;
  }
  sendWithStream(e, n, a, i) {
    const s = this.streamId++, r = this.sourceName, o = this.targetName, c = this.comObj;
    return new ReadableStream({
      start: (l) => {
        const h = Promise.withResolvers();
        return this.streamControllers[s] = {
          controller: l,
          startCall: h,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, c.postMessage({
          sourceName: r,
          targetName: o,
          action: e,
          streamId: s,
          data: n,
          desiredSize: l.desiredSize
        }, i), h.promise;
      },
      pull: (l) => {
        const h = Promise.withResolvers();
        return this.streamControllers[s].pullCall = h, c.postMessage({
          sourceName: r,
          targetName: o,
          stream: It.PULL,
          streamId: s,
          desiredSize: l.desiredSize
        }), h.promise;
      },
      cancel: (l) => {
        at(l instanceof Error, "cancel must have a valid reason");
        const h = Promise.withResolvers();
        return this.streamControllers[s].cancelCall = h, this.streamControllers[s].isClosed = !0, c.postMessage({
          sourceName: r,
          targetName: o,
          stream: It.CANCEL,
          streamId: s,
          reason: wn(l)
        }), h.promise;
      }
    }, a);
  }
  #n(e) {
    const n = e.streamId, a = this.sourceName, i = e.sourceName, s = this.comObj, r = this, o = this.actionHandler[e.action], c = {
      enqueue(l, h = 1, f) {
        if (this.isCancelled)
          return;
        const d = this.desiredSize;
        this.desiredSize -= h, d > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), s.postMessage({
          sourceName: a,
          targetName: i,
          stream: It.ENQUEUE,
          streamId: n,
          chunk: l
        }, f);
      },
      close() {
        this.isCancelled || (this.isCancelled = !0, s.postMessage({
          sourceName: a,
          targetName: i,
          stream: It.CLOSE,
          streamId: n
        }), delete r.streamSinks[n]);
      },
      error(l) {
        at(l instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, s.postMessage({
          sourceName: a,
          targetName: i,
          stream: It.ERROR,
          streamId: n,
          reason: wn(l)
        }));
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: !1,
      desiredSize: e.desiredSize,
      ready: null
    };
    c.sinkCapability.resolve(), c.ready = c.sinkCapability.promise, this.streamSinks[n] = c, Promise.try(o, e.data, c).then(function() {
      s.postMessage({
        sourceName: a,
        targetName: i,
        stream: It.START_COMPLETE,
        streamId: n,
        success: !0
      });
    }, function(l) {
      s.postMessage({
        sourceName: a,
        targetName: i,
        stream: It.START_COMPLETE,
        streamId: n,
        reason: wn(l)
      });
    });
  }
  #a(e) {
    const n = e.streamId, a = this.sourceName, i = e.sourceName, s = this.comObj, r = this.streamControllers[n], o = this.streamSinks[n];
    switch (e.stream) {
      case It.START_COMPLETE:
        e.success ? r.startCall.resolve() : r.startCall.reject(wn(e.reason));
        break;
      case It.PULL_COMPLETE:
        e.success ? r.pullCall.resolve() : r.pullCall.reject(wn(e.reason));
        break;
      case It.PULL:
        if (!o) {
          s.postMessage({
            sourceName: a,
            targetName: i,
            stream: It.PULL_COMPLETE,
            streamId: n,
            success: !0
          });
          break;
        }
        o.desiredSize <= 0 && e.desiredSize > 0 && o.sinkCapability.resolve(), o.desiredSize = e.desiredSize, Promise.try(o.onPull || Jl).then(function() {
          s.postMessage({
            sourceName: a,
            targetName: i,
            stream: It.PULL_COMPLETE,
            streamId: n,
            success: !0
          });
        }, function(l) {
          s.postMessage({
            sourceName: a,
            targetName: i,
            stream: It.PULL_COMPLETE,
            streamId: n,
            reason: wn(l)
          });
        });
        break;
      case It.ENQUEUE:
        if (at(r, "enqueue should have stream controller"), r.isClosed)
          break;
        r.controller.enqueue(e.chunk);
        break;
      case It.CLOSE:
        if (at(r, "close should have stream controller"), r.isClosed)
          break;
        r.isClosed = !0, r.controller.close(), this.#s(r, n);
        break;
      case It.ERROR:
        at(r, "error should have stream controller"), r.controller.error(wn(e.reason)), this.#s(r, n);
        break;
      case It.CANCEL_COMPLETE:
        e.success ? r.cancelCall.resolve() : r.cancelCall.reject(wn(e.reason)), this.#s(r, n);
        break;
      case It.CANCEL:
        if (!o)
          break;
        const c = wn(e.reason);
        Promise.try(o.onCancel || Jl, c).then(function() {
          s.postMessage({
            sourceName: a,
            targetName: i,
            stream: It.CANCEL_COMPLETE,
            streamId: n,
            success: !0
          });
        }, function(l) {
          s.postMessage({
            sourceName: a,
            targetName: i,
            stream: It.CANCEL_COMPLETE,
            streamId: n,
            reason: wn(l)
          });
        }), o.sinkCapability.reject(c), o.isCancelled = !0, delete this.streamSinks[n];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #s(e, n) {
    await Promise.allSettled([e.startCall?.promise, e.pullCall?.promise, e.cancelCall?.promise]), delete this.streamControllers[n];
  }
  destroy() {
    this.#e?.abort(), this.#e = null;
  }
}
async function Uh(t, e, n, {
  encrypt: a = null
}) {
  const i = a?.createCipherTransform(t.num, t.gen);
  n.push(`${t.num} ${t.gen} obj
`), e instanceof B ? await b0(e, n, i) : e instanceof Ne ? await jh(e, n, i) : (Array.isArray(e) || ArrayBuffer.isView(e)) && await Hh(e, n, i), n.push(`
endobj
`);
}
async function b0(t, e, n) {
  e.push("<<");
  for (const a of t.getKeys())
    e.push(` /${No(a)} `), await $h(t.getRaw(a), e, n);
  e.push(">>");
}
async function jh(t, e, n) {
  let a = t.getBytes();
  const {
    dict: i
  } = t, [s, r] = await Promise.all([i.getAsync("Filter"), i.getAsync("DecodeParms")]), o = Array.isArray(s) ? await i.xref.fetchIfRefAsync(s[0]) : s, c = dt(o, "FlateDecode");
  if (a.length >= 256 || c)
    try {
      const f = new CompressionStream("deflate"), d = f.writable.getWriter();
      await d.ready, d.write(a).then(async () => {
        await d.ready, await d.close();
      }).catch(() => {
      });
      const u = await new Response(f.readable).arrayBuffer();
      a = new Uint8Array(u);
      let x, g;
      s ? c || (x = Array.isArray(s) ? [Z.get("FlateDecode"), ...s] : [Z.get("FlateDecode"), s], r && (g = Array.isArray(r) ? [null, ...r] : [null, r])) : x = Z.get("FlateDecode"), x && i.set("Filter", x), g && i.set("DecodeParms", g);
    } catch (f) {
      Ue(`writeStream - cannot compress data: "${f}".`);
    }
  let h = xn(a);
  n && (h = n.encryptString(h)), i.set("Length", h.length), await b0(i, e, n), e.push(` stream
`, h, `
endstream`);
}
async function Hh(t, e, n) {
  e.push("[");
  let a = !0;
  for (const i of t)
    a ? a = !1 : e.push(" "), await $h(i, e, n);
  e.push("]");
}
async function $h(t, e, n) {
  t instanceof Z ? e.push(`/${No(t.name)}`) : t instanceof le ? e.push(`${t.num} ${t.gen} R`) : Array.isArray(t) || ArrayBuffer.isView(t) ? await Hh(t, e, n) : typeof t == "string" ? (n && (t = n.encryptString(t)), e.push(`(${Di(t)})`)) : typeof t == "number" ? e.push(ze(t)) : typeof t == "boolean" ? e.push(t.toString()) : t instanceof B ? await b0(t, e, n) : t instanceof Ne ? await jh(t, e, n) : t === null ? e.push("null") : F(`Unhandled value in writer: ${typeof t}, please file a bug.`);
}
function q0(t, e, n, a) {
  for (let i = e + n - 1; i > n - 1; i--)
    a[i] = t & 255, t >>= 8;
  return n + e;
}
function Gh(t, e, n) {
  const a = t.length;
  for (let i = 0; i < a; i++)
    n[e + i] = t.charCodeAt(i) & 255;
  return e + a;
}
function s7(t, e) {
  const n = Math.floor(Date.now() / 1e3), a = e.filename || "", i = [n.toString(), a, t.toString(), ...e.infoMap.values()], s = Math.sumPrecise(i.map((c) => c.length)), r = new Uint8Array(s);
  let o = 0;
  for (const c of i)
    o = Gh(c, o, r);
  return xn(Ia(r, 0, r.length));
}
function r7(t, e) {
  const n = new o0({
    hasAttributes: !0
  }).parseFromString(t);
  for (const {
    xfa: i
  } of e) {
    if (!i)
      continue;
    const {
      path: s,
      value: r
    } = i;
    if (!s)
      continue;
    const o = c1(s);
    let c = n.documentElement.searchNode(o, 0);
    !c && o.length > 1 && (c = n.documentElement.searchNode([o.at(-1)], 0)), c ? c.childNodes = Array.isArray(r) ? r.map((l) => new ws("value", l)) : [new ws("#text", r)] : F(`Node not found for path: ${s}`);
  }
  const a = [];
  return n.documentElement.dump(a), a.join("");
}
async function o7({
  xref: t,
  acroForm: e,
  acroFormRef: n,
  hasXfa: a,
  hasXfaDatasetsEntry: i,
  xfaDatasetsRef: s,
  needAppearances: r,
  changes: o
}) {
  if (a && !i && !s && F("XFA - Cannot save it"), !r && (!a || !s || i))
    return;
  const c = e.clone();
  if (a && !i) {
    const l = e.get("XFA").slice();
    l.splice(2, 0, "datasets"), l.splice(3, 0, s), c.set("XFA", l);
  }
  r && c.set("NeedAppearances", !0), o.put(n, {
    data: c
  });
}
function c7({
  xfaData: t,
  xfaDatasetsRef: e,
  changes: n,
  xref: a
}) {
  if (t === null) {
    const s = a.fetchIfRef(e);
    t = r7(s.getString(), n);
  }
  const i = new rn(t);
  i.dict = new B(a), i.dict.setIfName("Type", "EmbeddedFile"), n.put(e, {
    data: i
  });
}
async function l7(t, e, n, a, i) {
  i.push(`xref
`);
  const s = zh(n);
  let r = 0;
  for (const {
    ref: o,
    data: c
  } of n)
    o.num === s[r] && (i.push(`${s[r]} ${s[r + 1]}
`), r += 2), c !== null ? (i.push(`${e.toString().padStart(10, "0")} ${Math.min(o.gen, 65535).toString().padStart(5, "0")} n\r
`), e += c.length) : i.push(`0000000000 ${Math.min(o.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
  _h(e, t, a), i.push(`trailer
`), await b0(a, i), i.push(`
startxref
`, e.toString(), `
%%EOF
`);
}
function zh(t) {
  const e = [];
  for (const {
    ref: n
  } of t)
    n.num === e.at(-2) + e.at(-1) ? e[e.length - 1] += 1 : e.push(n.num, 1);
  return e;
}
async function h7(t, e, n, a, i) {
  const s = [];
  let r = 0, o = 0;
  for (const {
    ref: g,
    data: p
  } of n) {
    let m;
    r = Math.max(r, e), p !== null ? (m = Math.min(g.gen, 65535), s.push([1, e, m]), e += p.length) : (m = Math.min(g.gen + 1, 65535), s.push([0, 0, m])), o = Math.max(o, m);
  }
  a.set("Index", zh(n));
  const c = kc(r), l = kc(o), h = [1, c, l];
  a.set("W", h), _h(e, t, a);
  const f = Math.sumPrecise(h), d = new Uint8Array(f * s.length), u = new pt(d);
  u.dict = a;
  let x = 0;
  for (const [g, p, m] of s)
    x = q0(g, h[0], x, d), x = q0(p, h[1], x, d), x = q0(m, h[2], x, d);
  await Uh(t.newRef, u, i, {}), i.push(`startxref
`, e.toString(), `
%%EOF
`);
}
function _h(t, e, n) {
  if (Array.isArray(e.fileIds) && e.fileIds.length > 0) {
    const a = s7(t, e);
    n.set("ID", [e.fileIds[0], a]);
  }
}
function f7(t, e, n) {
  const a = new B(null);
  a.set("Prev", t.startXRef);
  const i = t.newRef;
  return n ? (e.put(i, {
    data: ""
  }), a.set("Size", i.num + 1), a.setIfName("Type", "XRef")) : a.set("Size", i.num), t.rootRef !== null && a.set("Root", t.rootRef), t.infoRef !== null && a.set("Info", t.infoRef), t.encryptRef !== null && a.set("Encrypt", t.encryptRef), a;
}
async function u7(t, e, n = []) {
  const a = [];
  for (const [i, {
    data: s
  }] of t.items()) {
    if (s === null || typeof s == "string") {
      a.push({
        ref: i,
        data: s
      });
      continue;
    }
    await Uh(i, s, n, e), a.push({
      ref: i,
      data: n.join("")
    }), n.length = 0;
  }
  return a.sort((i, s) => i.ref.num - s.ref.num);
}
async function d7({
  originalData: t,
  xrefInfo: e,
  changes: n,
  xref: a = null,
  hasXfa: i = !1,
  xfaDatasetsRef: s = null,
  hasXfaDatasetsEntry: r = !1,
  needAppearances: o,
  acroFormRef: c = null,
  acroForm: l = null,
  xfaData: h = null,
  useXrefStream: f = !1
}) {
  await o7({
    xref: a,
    acroForm: l,
    acroFormRef: c,
    hasXfa: i,
    hasXfaDatasetsEntry: r,
    xfaDatasetsRef: s,
    needAppearances: o,
    changes: n
  }), i && c7({
    xfaData: h,
    xfaDatasetsRef: s,
    changes: n,
    xref: a
  });
  const d = f7(e, n, f), u = [], x = await u7(n, a, u);
  let g = t.length;
  const p = t.at(-1);
  p !== 10 && p !== 13 && (u.push(`
`), g += 1);
  for (const {
    data: w
  } of x)
    w !== null && u.push(w);
  await (f ? h7(e, g, x, d, u) : l7(e, g, x, d, u));
  const m = t.length + Math.sumPrecise(u.map((w) => w.length)), b = new Uint8Array(m);
  b.set(t);
  let y = t.length;
  for (const w of u)
    y = Gh(w, y, b);
  return b;
}
class x7 {
  constructor(e) {
    this._msgHandler = e, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  getFullReader() {
    return at(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new g7(this._msgHandler), this._fullRequestReader;
  }
  getRangeReader(e, n) {
    const a = new p7(e, n, this._msgHandler);
    return this._rangeRequestReaders.push(a), a;
  }
  cancelAllRequests(e) {
    this._fullRequestReader?.cancel(e);
    for (const n of this._rangeRequestReaders.slice(0))
      n.cancel(e);
  }
}
class g7 {
  constructor(e) {
    this._msgHandler = e, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
    const n = this._msgHandler.sendWithStream("GetReader");
    this._reader = n.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((a) => {
      this._isStreamingSupported = a.isStreamingSupported, this._isRangeSupported = a.isRangeSupported, this._contentLength = a.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const {
      value: e,
      done: n
    } = await this._reader.read();
    return n ? {
      value: void 0,
      done: !0
    } : {
      value: e.buffer,
      done: !1
    };
  }
  cancel(e) {
    this._reader.cancel(e);
  }
}
class p7 {
  constructor(e, n, a) {
    this._msgHandler = a, this.onProgress = null;
    const i = this._msgHandler.sendWithStream("GetRangeReader", {
      begin: e,
      end: n
    });
    this._reader = i.getReader();
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    const {
      value: e,
      done: n
    } = await this._reader.read();
    return n ? {
      value: void 0,
      done: !0
    } : {
      value: e.buffer,
      done: !1
    };
  }
  cancel(e) {
    this._reader.cancel(e);
  }
}
class Sa {
  constructor(e) {
    this.name = e, this.terminated = !1, this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = !0;
  }
  ensureNotTerminated() {
    if (this.terminated)
      throw new Error("Worker task was terminated");
  }
}
const gc = class gc {
  static setup(e, n) {
    let a = !1;
    e.on("test", (i) => {
      a || (a = !0, e.send("test", i instanceof Uint8Array));
    }), e.on("configure", (i) => {
      Kh(i.verbosity);
    }), e.on("GetDocRequest", (i) => this.createDocumentHandler(i, n));
  }
  static createDocumentHandler(e, n) {
    let a, i = !1, s = null;
    const r = /* @__PURE__ */ new Set(), o = Yh(), {
      docId: c,
      apiVersion: l
    } = e, h = "5.4.296";
    if (l !== h)
      throw new Error(`The API version "${l}" does not match the Worker version "${h}".`);
    const f = (w, S) => `The \`${w}.prototype\` contains unexpected enumerable property "${S}", thus breaking e.g. \`for...in\` iteration of ${w}s.`;
    for (const w in {})
      throw new Error(f("Object", w));
    for (const w in [])
      throw new Error(f("Array", w));
    const d = c + "_worker";
    let u = new Zl(d, c, n);
    function x() {
      if (i)
        throw new Error("Worker was terminated");
    }
    function g(w) {
      r.add(w);
    }
    function p(w) {
      w.finish(), r.delete(w);
    }
    async function m(w) {
      await a.ensureDoc("checkHeader"), await a.ensureDoc("parseStartXRef"), await a.ensureDoc("parse", [w]), await a.ensureDoc("checkFirstPage", [w]), await a.ensureDoc("checkLastPage", [w]);
      const S = await a.ensureDoc("isPureXfa");
      if (S) {
        const C = new Sa("loadXfaResources");
        g(C), await a.ensureDoc("loadXfaResources", [u, C]), p(C);
      }
      const [v, k] = await Promise.all([a.ensureDoc("numPages"), a.ensureDoc("fingerprints")]), A = S ? await a.ensureDoc("htmlForXfa") : null;
      return {
        numPages: v,
        fingerprints: k,
        htmlForXfa: A
      };
    }
    async function b({
      data: w,
      password: S,
      disableAutoFetch: v,
      rangeChunkSize: k,
      length: A,
      docBaseUrl: C,
      enableXfa: T,
      evaluatorOptions: M
    }) {
      const O = {
        source: null,
        disableAutoFetch: v,
        docBaseUrl: C,
        docId: c,
        enableXfa: T,
        evaluatorOptions: M,
        handler: u,
        length: A,
        password: S,
        rangeChunkSize: k
      };
      if (w)
        return O.source = w, new Yl(O);
      const N = new x7(u), H = N.getFullReader(), J = Promise.withResolvers();
      let U, j = [], P = 0;
      return H.headersReady.then(function() {
        if (H.isRangeSupported) {
          O.source = N, O.length = H.contentLength, O.disableAutoFetch ||= H.isStreamingSupported, U = new i7(O);
          for (const K of j)
            U.sendProgressiveData(K);
          j = [], J.resolve(U), s = null;
        }
      }).catch(function(K) {
        J.reject(K), s = null;
      }), new Promise(function(K, xe) {
        const X = function({
          value: ye,
          done: we
        }) {
          try {
            if (x(), we) {
              if (!U) {
                const D = o1(j);
                j = [], A && D.length !== A && F("reported HTTP length is different from actual"), O.source = D, U = new Yl(O), J.resolve(U);
              }
              s = null;
              return;
            }
            P += ye.byteLength, H.isStreamingSupported || u.send("DocProgress", {
              loaded: P,
              total: Math.max(P, H.contentLength || 0)
            }), U ? U.sendProgressiveData(ye) : j.push(ye), H.read().then(X, xe);
          } catch (D) {
            xe(D);
          }
        };
        H.read().then(X, xe);
      }).catch(function(K) {
        J.reject(K), s = null;
      }), s = (K) => {
        N.cancelAllRequests(K);
      }, J.promise;
    }
    function y(w) {
      function S(A) {
        x(), u.send("GetDoc", {
          pdfInfo: A
        });
      }
      function v(A) {
        if (x(), A instanceof Is) {
          const C = new Sa(`PasswordException: response ${A.code}`);
          g(C), u.sendWithPromise("PasswordRequest", A).then(function({
            password: T
          }) {
            p(C), a.updatePassword(T), k();
          }).catch(function() {
            p(C), u.send("DocException", A);
          });
        } else
          u.send("DocException", wn(A));
      }
      function k() {
        x(), m(!1).then(S, function(A) {
          if (x(), !(A instanceof Ri)) {
            v(A);
            return;
          }
          a.requestLoadedStream().then(function() {
            x(), m(!0).then(S, v);
          });
        });
      }
      x(), b(w).then(function(A) {
        if (i)
          throw A.terminate(new _t("Worker was terminated.")), new Error("Worker was terminated");
        a = A, a.requestLoadedStream(!0).then((C) => {
          u.send("DataLoaded", {
            length: C.bytes.byteLength
          });
        });
      }).then(k, v);
    }
    return u.on("GetPage", function(w) {
      return a.getPage(w.pageIndex).then(function(S) {
        return Promise.all([a.ensure(S, "rotate"), a.ensure(S, "ref"), a.ensure(S, "userUnit"), a.ensure(S, "view")]).then(function([v, k, A, C]) {
          return {
            rotate: v,
            ref: k,
            refStr: k?.toString() ?? null,
            userUnit: A,
            view: C
          };
        });
      });
    }), u.on("GetPageIndex", function(w) {
      const S = le.get(w.num, w.gen);
      return a.ensureCatalog("getPageIndex", [S]);
    }), u.on("GetDestinations", function(w) {
      return a.ensureCatalog("destinations");
    }), u.on("GetDestination", function(w) {
      return a.ensureCatalog("getDestination", [w.id]);
    }), u.on("GetPageLabels", function(w) {
      return a.ensureCatalog("pageLabels");
    }), u.on("GetPageLayout", function(w) {
      return a.ensureCatalog("pageLayout");
    }), u.on("GetPageMode", function(w) {
      return a.ensureCatalog("pageMode");
    }), u.on("GetViewerPreferences", function(w) {
      return a.ensureCatalog("viewerPreferences");
    }), u.on("GetOpenAction", function(w) {
      return a.ensureCatalog("openAction");
    }), u.on("GetAttachments", function(w) {
      return a.ensureCatalog("attachments");
    }), u.on("GetDocJSActions", function(w) {
      return a.ensureCatalog("jsActions");
    }), u.on("GetPageJSActions", function({
      pageIndex: w
    }) {
      return a.getPage(w).then((S) => a.ensure(S, "jsActions"));
    }), u.on("GetAnnotationsByType", async function({
      types: w,
      pageIndexesToSkip: S
    }) {
      const [v, k] = await Promise.all([a.ensureDoc("numPages"), a.ensureDoc("annotationGlobals")]);
      if (!k)
        return null;
      const A = [], C = [];
      let T = null;
      try {
        for (let O = 0, N = v; O < N; O++)
          S?.has(O) || (T || (T = new Sa("GetAnnotationsByType"), g(T)), A.push(a.getPage(O).then(async (H) => H ? H.collectAnnotationsByType(u, T, w, C, k) || [] : [])));
        return await Promise.all(A), (await Promise.all(C)).filter((O) => !!O);
      } finally {
        T && p(T);
      }
    }), u.on("GetOutline", function(w) {
      return a.ensureCatalog("documentOutline");
    }), u.on("GetOptionalContentConfig", function(w) {
      return a.ensureCatalog("optionalContentConfig");
    }), u.on("GetPermissions", function(w) {
      return a.ensureCatalog("permissions");
    }), u.on("GetMetadata", function(w) {
      return Promise.all([a.ensureDoc("documentInfo"), a.ensureCatalog("metadata")]);
    }), u.on("GetMarkInfo", function(w) {
      return a.ensureCatalog("markInfo");
    }), u.on("GetData", function(w) {
      return a.requestLoadedStream().then((S) => S.bytes);
    }), u.on("GetAnnotations", function({
      pageIndex: w,
      intent: S
    }) {
      return a.getPage(w).then(function(v) {
        const k = new Sa(`GetAnnotations: page ${w}`);
        return g(k), v.getAnnotationsData(u, k, S).then((A) => (p(k), A), (A) => {
          throw p(k), A;
        });
      });
    }), u.on("GetFieldObjects", function(w) {
      return a.ensureDoc("fieldObjects").then((S) => S?.allFields || null);
    }), u.on("HasJSActions", function(w) {
      return a.ensureDoc("hasJSActions");
    }), u.on("GetCalculationOrderIds", function(w) {
      return a.ensureDoc("calculationOrderIds");
    }), u.on("SaveDocument", async function({
      isPureXfa: w,
      numPages: S,
      annotationStorage: v,
      filename: k
    }) {
      const A = [a.requestLoadedStream(), a.ensureCatalog("acroForm"), a.ensureCatalog("acroFormRef"), a.ensureDoc("startXRef"), a.ensureDoc("xref"), a.ensureCatalog("structTreeRoot")], C = new un(), T = [], M = w ? null : h1(v), [O, N, H, J, U, j] = await Promise.all(A), P = U.trailer.getRaw("Root") || null;
      let K;
      if (M) {
        j ? await j.canUpdateStructTree({
          pdfManager: a,
          newAnnotationsByPage: M
        }) && (K = j) : await Pa.canCreateStructureTree({
          catalogRef: P,
          pdfManager: a,
          newAnnotationsByPage: M
        }) && (K = null);
        const L = la.generateImages(v.values(), U, a.evaluatorOptions.isOffscreenCanvasSupported), V = K === void 0 ? T : [];
        for (const [he, te] of M)
          V.push(a.getPage(he).then((_) => {
            const de = new Sa(`Save (editor): page ${he}`);
            return g(de), _.saveNewAnnotations(u, de, te, L, C).finally(function() {
              p(de);
            });
          }));
        K === null ? T.push(Promise.all(V).then(async () => {
          await Pa.createStructureTree({
            newAnnotationsByPage: M,
            xref: U,
            catalogRef: P,
            pdfManager: a,
            changes: C
          });
        })) : K && T.push(Promise.all(V).then(async () => {
          await K.updateStructureTree({
            newAnnotationsByPage: M,
            pdfManager: a,
            changes: C
          });
        }));
      }
      if (w)
        T.push(a.ensureDoc("serializeXfaData", [v]));
      else
        for (let L = 0; L < S; L++)
          T.push(a.getPage(L).then(function(V) {
            const he = new Sa(`Save: page ${L}`);
            return g(he), V.save(u, he, v, C).finally(function() {
              p(he);
            });
          }));
      const xe = await Promise.all(T);
      let X = null;
      if (w) {
        if (X = xe[0], !X)
          return O.bytes;
      } else if (C.size === 0)
        return O.bytes;
      const ye = H && N instanceof B && C.values().some((L) => L.needAppearances), we = N instanceof B && N.get("XFA") || null;
      let D = null, G = !1;
      if (Array.isArray(we)) {
        for (let L = 0, V = we.length; L < V; L += 2)
          we[L] === "datasets" && (D = we[L + 1], G = !0);
        D === null && (D = U.getNewTemporaryRef());
      } else we && F("Unsupported XFA type.");
      let R = /* @__PURE__ */ Object.create(null);
      if (U.trailer) {
        const L = /* @__PURE__ */ new Map(), V = U.trailer.get("Info") || null;
        if (V instanceof B)
          for (const [he, te] of V)
            typeof te == "string" && L.set(he, Ve(te));
        R = {
          rootRef: P,
          encryptRef: U.trailer.getRaw("Encrypt") || null,
          newRef: U.getNewTemporaryRef(),
          infoRef: U.trailer.getRaw("Info") || null,
          infoMap: L,
          fileIds: U.trailer.get("ID") || null,
          startXRef: J,
          filename: k
        };
      }
      return d7({
        originalData: O.bytes,
        xrefInfo: R,
        changes: C,
        xref: U,
        hasXfa: !!we,
        xfaDatasetsRef: D,
        hasXfaDatasetsEntry: G,
        needAppearances: ye,
        acroFormRef: H,
        acroForm: N,
        xfaData: X,
        useXrefStream: s1(U.topDict, "XRef")
      }).finally(() => {
        U.resetNewTemporaryRef();
      });
    }), u.on("GetOperatorList", function(w, S) {
      const v = w.pageIndex;
      a.getPage(v).then(function(k) {
        const A = new Sa(`GetOperatorList: page ${v}`);
        g(A);
        const C = o >= Cs.INFOS ? Date.now() : 0;
        k.getOperatorList({
          handler: u,
          sink: S,
          task: A,
          intent: w.intent,
          cacheKey: w.cacheKey,
          annotationStorage: w.annotationStorage,
          modifiedIds: w.modifiedIds
        }).then(function(T) {
          p(A), C && Ue(`page=${v + 1} - getOperatorList: time=${Date.now() - C}ms, len=${T.length}`), S.close();
        }, function(T) {
          p(A), !A.terminated && S.error(T);
        });
      });
    }), u.on("GetTextContent", function(w, S) {
      const {
        pageIndex: v,
        includeMarkedContent: k,
        disableNormalization: A
      } = w;
      a.getPage(v).then(function(C) {
        const T = new Sa("GetTextContent: page " + v);
        g(T);
        const M = o >= Cs.INFOS ? Date.now() : 0;
        C.extractTextContent({
          handler: u,
          task: T,
          sink: S,
          includeMarkedContent: k,
          disableNormalization: A
        }).then(function() {
          p(T), M && Ue(`page=${v + 1} - getTextContent: time=${Date.now() - M}ms`), S.close();
        }, function(O) {
          p(T), !T.terminated && S.error(O);
        });
      });
    }), u.on("GetStructTree", function(w) {
      return a.getPage(w.pageIndex).then((S) => a.ensure(S, "getStructTree"));
    }), u.on("FontFallback", function(w) {
      return a.fontFallback(w.id, u);
    }), u.on("Cleanup", function(w) {
      return a.cleanup(!0);
    }), u.on("Terminate", function(w) {
      i = !0;
      const S = [];
      if (a) {
        a.terminate(new _t("Worker was terminated."));
        const v = a.cleanup();
        S.push(v), a = null;
      } else
        Jo();
      s?.(new _t("Worker was terminated."));
      for (const v of r)
        S.push(v.finished), v.terminate();
      return Promise.all(S).then(function() {
        u.destroy(), u = null;
      });
    }), u.on("Ready", function(w) {
      y(e), e = null;
    }), d;
  }
  static initializeFromPort(e) {
    const n = new Zl("worker", "main", e);
    this.setup(n, e), n.send("ready", null);
  }
};
typeof window > "u" && !Vh && typeof self < "u" && typeof self.postMessage == "function" && "onmessage" in self && gc.initializeFromPort(self);
let Bo = gc;
globalThis.pdfjsWorker = {
  WorkerMessageHandler: Bo
};
export {
  Bo as WorkerMessageHandler
};
